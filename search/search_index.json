{"config":{"lang":["it"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#inizia-da-qui","title":"Inizia da qui","text":""},{"location":"#benvenut","title":"Benvenut\u0259","text":"<p>Quando ho scoperto Processing diversi anni fa \u2013 sono, ormai, passati quasi 10 anni \u2013 la mia vita \u00e8 completamente cambiata: avevo gi\u00e0 esperienze di programmazione in altri linguaggi ma nessuno mi aveva mai dato la possibilit\u00e0 di sviluppare prototipi o idee pi\u00f9 o meno complesse velocemente e con facilit\u00e0.</p> <p>La comunit\u00e0 di Processing e la miriade di contenuti gratuiti che si possono trovare facilmente in rete sono stati fondamentali per permettermi di imparare a usarlo al meglio. Un giorno di luglio nel 2015 ho deciso di cominciare a scrivere degli articoli \u2013 inizialmente sul mio blog \u2013 in italiano per dare la possibilit\u00e0 anche a chi non conosce l'inglese di imparare a usare questo strumento incredibile.</p> <p>Nel corso degli anni ho avuto la fortuna di tenere diversi workshop su Processing arrivando persino a ottenere la cattedra della materia Linguaggi Visuali per Sistemi Complessi all'interno del corso Comunicazione Multimediale e Tecnologie dell'Informazione presso l'Universit\u00e0 di Udine dal 2017 al 2021.</p> <p>Gli impegni lavorativi, purtroppo, non mi hanno permesso di tenere il blog aggiornato come avrei voluto e il numero di articoli pubblicati \u00e8 via via diminuito nel corso degli anni.</p> <p>All'alba del 2023 ho deciso che era arrivato il momento di rinnovare il sito e ricominciare pubblicare nuovi contenuti e, nel contempo, revisionare quelli gi\u00e0 pubblicati. Il primo passaggio \u00e8 stato migrare la piattaforma da Wordpress a MkDocs e utilizzare un nuovo sottodominio: processing.federicopepe.com.</p> <p>Credo sia il caso di riprendere un paio di frasi scritte nella prima versione dell'introduzione che rimangono ancora valide oggi:</p> <p>Se siete arrivat\u0259 su questa pagina e state leggendo queste parole, probabilmente siete interessat\u0259 a imparare a programmare in Processing o, pi\u00f9 in generale, ad avventurarvi nel magico mondo del creative coding. In tal caso, vi do il benvenuto.</p> <p>Info</p> <p>Gli articoli che trovate su queste pagine sono stati scritti nel corso degli anni: nonostante io abbia cercato di mantenerli sempre aggiornati \u00e8 possibile che contengano degli errori o delle imprecisioni o che, semplicemente, il codice non funzioni pi\u00f9 correttamente.</p> <p>Questo \u00e8 progetto che sar\u00e0 sempre\u00a0in progress\u00a0e, per questo, mi fa piacere ricevere commenti e feedback per poter migliorare e mantenere aggiornati tutti i contenuti.</p>"},{"location":"#chi-sono-e-contatti","title":"Chi sono e contatti","text":"<p>Sono Federico Pepe e mi definisco un esperto di tecnologie musicali. La mia vita \u00e8 sempre stata divisa tra la passione per la musica e quella per la tecnologia e la programmazione. Mi sono laureato in Contemporary Popular Music e tutto quello che ho imparato a livello informatico l'ho studiato da autodidatta (quindi c'\u00e8 speranza per tutti!). Per fortuna ho scoperto il creative coding e ho capito che potevo unire le mie due passioni. Sono stato un pessimo studente, soprattutto al liceo e, forse, questo mi ha aiutato a essere un buon insegnante.</p> <p>Il mio curriculum \u00e8 visionabile su LinkedIn. Mi trovate su quasi tutti i social network. Per comodit\u00e0 seguite questo link.</p> <p>Se ti interessa ricevere aggiornamenti via email, ho creato una newsletter. </p>"},{"location":"#riconoscimenti","title":"Riconoscimenti","text":"<p>Come ho gi\u00e0 scritto, l'approccio inclusivo e open source dell'intera comunit\u00e0 di Processing \u00e8 stato fondamentale per imparare a programmare e per migliorarmi in tutti questi anni. Ci tengo, comunque, a fare dei riconoscimenti specifici a quelle persone o a quelle risorse che mi hanno dato tanto e da cui ho preso - e ancora oggi prendo - ispirazione ogni giorno.</p> <ul> <li> <p> Daniel Shiffman \u00e8 la persona a cui devo pi\u00f9 di tutti. Ho imparato Processing grazie ai suoi video pubblicati prima su Vimeo e poi su YouTube sul canale The Coding Train.</p> </li> <li> <p> Processing: A Programming Handbook for Visual Designers, Second Edition di Casey Reas e Ben Fry.</p> </li> <li> <p> Learning Processing, Second Edition: A Beginner's Guide to Programming Images, Animation, and Interaction di Daniel Shiffman</p> </li> <li> <p> Generative Art di Matt Pearson</p> </li> <li> <p> Programming Interactivity di Joshua Noble</p> </li> <li> <p> Visualizing Data di Ben Fry</p> </li> <li> <p> Generative Design di Hartmut Bohnacker, Benedikt Gross, Julia Laub, e Claudius Lazzeroni</p> </li> </ul>"},{"location":"2016-05-11-librerie-di-processing/","title":"Librerie: estendere le funzionalit\u00e0 di Processing","text":"","tags":["contributed-libraries","contribution-manager","librerie"]},{"location":"2016-05-11-librerie-di-processing/#librerie-estendere-le-funzionalita-di-processing","title":"Librerie: estendere le funzionalit\u00e0 di Processing","text":"<p>\u00c8 possibile estendere le funzionalit\u00e0 di base di Processing utilizzando delle librerie esterne. Una libreria non \u00e8 altro che un insieme di classi, funzioni e variabili pensate e progettate con\u00a0il preciso scopo di semplificare l'esecuzione di determinate operazioni\u00a0che, se programmate da zero,\u00a0renderebbero il nostro programma troppo verboso.</p> <p>L'idea\u00a0che sta alla base delle librerie \u00e8 di fare in modo di non appesantire troppo i programmi che non le richiedono motivo per cui, quando decidiamo di usarne una, dobbiamo usare una sintassi ben precisa per dire al programma \"carica questa libreria perch\u00e9 ho intenzione di usarla\".</p>","tags":["contributed-libraries","contribution-manager","librerie"]},{"location":"2016-05-11-librerie-di-processing/#librerie-built-in","title":"Librerie built-in","text":"<p>Esistono una serie di librerie che sono incluse gi\u00e0 all'interno del pacchetto di Processing:</p> <ul> <li>Serial:\u00a0quando dobbiamo interfacciare il nostro sketch con hardware esterno attraverso la porta seriale</li> <li>Network:\u00a0per creare applicazioni client e server comunicanti via internet</li> <li>PDF:\u00a0per grafiche di alta qualit\u00e0 esportate in formato PDF</li> <li>DXF:\u00a0per esportare grafiche in formato DXF</li> </ul> <p>Ci sono poi le librerie\u00a0Sound\u00a0e\u00a0Video che sono sviluppate dalla Processing Foundation ma che \u00e8 necessario scaricare attraverso il menu\u00a0<code>Sketch &gt; Import Library &gt; Add Library</code>.</p>","tags":["contributed-libraries","contribution-manager","librerie"]},{"location":"2016-05-11-librerie-di-processing/#contributed-libraries","title":"Contributed Libraries","text":"<p>Oltre quelle sviluppate dalla Processing Foundation, esistono numerose librerie di terze parti. Partendo dal menu\u00a0<code>Sketch &gt; Import Library &gt; Add Library</code> \u00e8 possibile scaricarle e installarle sul nostro computer. Le\u00a0contributed libraries\u00a0che compaiono nel\u00a0Contribution Manager rispettano degli standard\u00a0ben precisi che possono essere consultati sul repository ufficiale di GitHub\u00a0e sono progettate per segnalare automaticamente eventuali aggiornamenti.</p> <p>Scorrendo rapidamente la lista di tutte le librerie disponibili potete notare la quantit\u00e0 di funzionalit\u00e0 che possono essere aggiunte ai nostri programmi; per fare degli esempi:\u00a0integrazione di\u00a0messaggi MIDI, OSC, creazione di GUI, utilizzo di hardware esterno (Leap Motion, Microsoft Kinect), simulazioni di engine 2D e molto altro.</p> <p>In futuro dedicher\u00f2 alcuni articoli e guide a quelle\u00a0pi\u00f9 conosciute e utilizzate, nel frattempo, per\u00f2, potete consultare gli esempi che trovate nel menu\u00a0<code>File &gt; Examples &gt; Libraries / Contributed Libraries</code> che vengono installati insieme alla libreria.</p>","tags":["contributed-libraries","contribution-manager","librerie"]},{"location":"2016-05-11-librerie-di-processing/#installare-librerie-manualmente","title":"Installare librerie manualmente","text":"<p>Tutte le librerie vengono installate all'interno della cartella <code>~/Documents/Processing/libraries</code> (su Mac) o\u00a0<code>Documents/Processing</code> (su Windows). Nel caso in cui vogliate installare delle librerie di terze parti non presenti nel Contribution Manager che, generalmente, si trovano in formato .jar \u00e8 sufficiente copiare i file nella cartella di riferimento.\u00a0\u00c8 buona norma inserire il file .jar in una sottocartella con lo stesso nome. Una volta completata l'installazione\u00a0\u00e8 necessario riavviare Processing per poterle utilizzare.</p>","tags":["contributed-libraries","contribution-manager","librerie"]},{"location":"2016-05-11-librerie-di-processing/#utilizzare-le-librerie-installate","title":"Utilizzare le librerie installate","text":"<p>Il comando di cui parlavo all'inizio del post per dire al nostro programma \"carica la libreria perch\u00e9 voglio utilizzarla\" \u00e8 molto semplice: <code>import</code> a cui bisogna aggiungere i componenti che vogliamo caricare.</p> <p></p> <p>Attraverso il menu <code>Sketch &gt; Import Library</code>, selezionando la libreria, Processing aggiunger\u00e0 automaticamente il codice necessario nel nostro sketch.</p>","tags":["contributed-libraries","contribution-manager","librerie"]},{"location":"2017-03-05-processing-ableton-midi-sincronizzare/","title":"Processing e Ableton: sincronizzare musica e visual via MIDI","text":"<p>Oggi sfrutteremo Processing per creare dei semplici visual sincronizzati con la musica attraverso il protocollo MIDI. Il software musicale che user\u00f2 per fare gli esempi \u00e8 Ableton Live 9 ma \u00e8 possibile\u00a0usare qualsiasi Digital Audio Workstation in grado di inviare messaggi MIDI.</p> <p>Lo schema delle connessioni, dunque, sar\u00e0: Ableton Live gestir\u00e0 la musica e invier\u00e0, attraverso dei messaggi MIDI, delle informazioni che Processing acquisir\u00e0 in input per generare i visual.</p>","tags":["albeton-live","midi","processing","sincronizzazione"]},{"location":"2017-03-05-processing-ableton-midi-sincronizzare/#midi-e-the-midibus","title":"MIDI e the MidiBus","text":"<p>Perch\u00e9 ho deciso di sfruttare il protocollo MIDI? Le ragioni sono molto semplici:</p> <ol> <li>\u00e8 uno standard per le applicazioni musicali</li> <li>\u00e8\u00a0un protocollo flessibile</li> <li>\u00e8 semplice\u00a0creare, inviare e monitorare i messaggi MIDI.</li> <li>rende molto semplice la sincronizzazione</li> </ol> <p>Per questioni di spazio, non mi dilungher\u00f2 in questo post sulla spiegazione di come funziona questo protocollo; trattandosi di uno standard sviluppato negli anni '80, ci sono numerose risorse on-line che vi permettono di approfondire.</p>","tags":["albeton-live","midi","processing","sincronizzazione"]},{"location":"2017-03-05-processing-ableton-midi-sincronizzare/#libreria-the-midibus","title":"Libreria: the MidiBus","text":"<p>Anche se Java supporta nativamente il MIDI attraverso il pacchetto java.sound.midi, per\u00a0lavorare con questi tipi di messaggi in\u00a0Processing consiglio di\u00a0installare una libreria.</p> <p></p> <p>Aprite Processing, andate nel menu\u00a0Tool &gt; Add new tool. Nel pannello\u00a0Libraries\u00a0digitate MIDI, selezionate The Midi Bus e cliccate sul pulsante\u00a0Install in basso a destra.</p>","tags":["albeton-live","midi","processing","sincronizzazione"]},{"location":"2017-03-05-processing-ableton-midi-sincronizzare/#macos-iac-driver","title":"macOS: IAC Driver","text":"<p>Di norma per inviare\u00a0e ricevere messaggi MIDI \u00e8 necessario dotarsi di una scheda e dei relativi cablaggi. Nel nostro caso, per\u00f2, dovendo inviare e ricevere messaggi tra due applicazioni\u00a0possiamo\u00a0sfruttare lo IAC Driver: una scheda virtuale\u00a0che ci permette di gestire tutte le connessioni internamente al computer.</p> <p>Nota: Per Windows esistono delle applicazioni da installare che hanno la stessa funzione del driver IAC. Con una veloce ricerca su Google ho trovato\u00a0LoopBe1\u00a0e MIDI Yoke\u00a0che non ho provato personalmente ma sono consigliate su diversi forum.</p> <p>Per configurare lo IAC Driver su macOS aprite\u00a0Applicazioni &gt; Utility &gt; Configurazione MIDI Audio.\u00a0Cliccate su\u00a0Finestra &gt; Mostra Studio MIDI \u23182</p> <p></p> <p>Fate doppio click su\u00a0IAC Driver e mettete la spunta su\u00a0Il dispositivo \u00e8 acceso.</p> <p></p> <p>Ora che abbiamo attivato il canale di comunicazione interno per inviare e ricevere messaggi MIDI,\u00a0possiamo procedere con Processing.</p>","tags":["albeton-live","midi","processing","sincronizzazione"]},{"location":"2017-03-05-processing-ableton-midi-sincronizzare/#ricezione-messaggi-midi-in-processing","title":"Ricezione messaggi MIDI in Processing","text":"<p>Apriamo un nuovo sketch e verifichiamo subito che Processing veda lo IAC Driver.</p> <pre><code>/*\n * Processing e Ableton: sincronizzare musica e visual via MIDI\n * Federico Pepe, 05.03.2017\n * http://blog.federicopepe.com/processing\n*/\n\nimport themidibus.*;\n\nvoid setup() {\n  size(100, 100);\n  background(0);\n\n  MidiBus.list(); \n}\n\nvoid draw() {\n\n}\n</code></pre> <p>Con queste poche righe di codice abbiamo importato la libreria all'interno del nostro programma e attraverso il comando <code>Midibus.list()</code> possiamo verificare nella console tutte le periferiche MIDI attive.</p> <p>Questo \u00e8 il risultato che ottengo lanciando il programma sul mio Mac. Ovviamente potrebbe cambiare sul vostro; l'importante \u00e8 che sia presente IAC Bus. </p><pre><code>Available MIDI Devices:\n----------Input----------\n[0] \"IAC Bus 1\"\n[1] \"Real Time Sequencer\"\n----------Output----------\n[0] \"Gervill\"\n[1] \"IAC Bus 1\"\n[2] \"Real Time Sequencer\"\n</code></pre>","tags":["albeton-live","midi","processing","sincronizzazione"]},{"location":"2017-03-05-processing-ableton-midi-sincronizzare/#progetto-ableton-live-invio-del-messaggio","title":"Progetto Ableton Live: invio del messaggio","text":"<p>Apriamo Ableton Live e creiamo un nuovo progetto. Apriamo le preferenze e verifichiamo che il driver IAC sia selezionato come scheda sia per l'input che per l'output.</p> <p></p> <p>Nella prima traccia MIDI nella parte di input/output selezioniamo\u00a0MIDI To &gt;\u00a0IAC Driver. In questo modo tutti i messaggi che saranno presenti su questa traccia saranno inviati come output al driver e, di conseguenza, saranno ricevuti da Processing.</p> <p></p> <p>Creiamo una Clip MIDI nel primo slot contenente\u00a0un C3 lungo 1/4. Assicuriamoci che la clip sia il loop quando premiamo il tasto\u00a0play su di essa.</p> <p></p>","tags":["albeton-live","midi","processing","sincronizzazione"]},{"location":"2017-03-05-processing-ableton-midi-sincronizzare/#ricezione-del-messaggio","title":"Ricezione del messaggio","text":"<p>Torniamo su Processing e modifichiamo il nostro programma come segue:</p> <pre><code>/*\n * Processing e Ableton: sincronizzare musica e visual via MIDI\n * Federico Pepe, 05.03.2017\n * http://blog.federicopepe.com/processing\n*/\n\nimport themidibus.*;\n\nMidiBus myBus;\n\nvoid setup() {\n  size(100, 100);\n  background(0);\n\n  MidiBus.list(); \n\n  myBus = new MidiBus(this, 0, 1);\n}\n\nvoid draw() {\n\n}\n\nvoid noteOn(int channel, int pitch, int velocity) {\n  println();\n  println(\"Note On:\" + \" Channel: \"+channel + \" Pitch: \"+pitch + \" Velocity: \"+velocity);\n  println(\"--------\");\n}\n</code></pre> <p>Rispetto al codice scritto in precedenza, abbiamo aggiunto e inizializzato un oggetto di tipo MidiBus: <code>myBus = new MidiBus(this, 0, 1);</code>. In questa fase \u00e8 fondamentale inserire i parametri corretti: il primo \u00e8 il\u00a0parent a cui la libreria \u00e8 collegata, il secondo \u00e8 l'input e l'ultimo\u00a0l'output. I dati sono facilmente individuabili grazie al comando\u00a0.list() dato in precedenza.</p> <p>Abbiamo, infine, aggiunto una funzione che \u00e8 presente all'interno della libreria: noteOn() e\u00a0che restituisce i valori MIDI: canale, pitch e velocity di tutte le note ricevute.</p>","tags":["albeton-live","midi","processing","sincronizzazione"]},{"location":"2017-03-05-processing-ableton-midi-sincronizzare/#verifichiamo-il-funzionamento","title":"Verifichiamo il funzionamento","text":"<p>Facciamo partire la nostra clip su Ableton Live e avviamo il nostro sketch su Processing. Se in console appare un messaggio come quello qui di seguito, siamo riusciti nel nostro intento:</p> <pre><code>Available MIDI Devices:\n----------Input----------\n[0] \"IAC Bus 1\"\n[1] \"Real Time Sequencer\"\n----------Output----------\n[0] \"Gervill\"\n[1] \"IAC Bus 1\"\n[2] \"Real Time Sequencer\"\n\nNote On: Channel: 0 Pitch: 60 Velocity: 127\n--------\n</code></pre> <p>Processing sta\u00a0ricevendo tramite IAC Driver un messaggio Note On con i seguenti parametri:</p> <ul> <li>Canale: 0</li> <li>Pitch: 60 (che corrisponde al C3)</li> <li>Velocity: 127</li> </ul> <p>Adesso, se andiamo a modificare la clip su Ableton inserendo nuovi messaggi, possiamo verificare che anche questi siano ricevuti da Processing.</p>","tags":["albeton-live","midi","processing","sincronizzazione"]},{"location":"2017-03-05-processing-ableton-midi-sincronizzare/#creare-i-visual","title":"Creare i visual","text":"<p>A questo punto non ci resta che sviluppare in Processing i nostri visual\u00a0sfruttando i parametri MIDI\u00a0inviati da Ableton. Nell'esempio molto semplice\u00a0che trovate di seguito, viene disegnato\u00a0un quadrato al centro dello schermo la cui dimensione dipende dal valore di pitch ricevuto via MIDI.\u00a0In aggiunta a quanto visto in questo post, sfrutto la funzione noteOff() per\u00a0impostare la grandezza del quadrato a 0. Di certo non \u00e8 il metodo pi\u00f9 elegante ma di sicuro funziona.</p> <pre><code>/*\n * Processing e Ableton: sincronizzare musica e visual via MIDI\n * Federico Pepe, 05.03.2017\n * http://blog.federicopepe.com/processing\n*/\n\nimport themidibus.*;\n\nMidiBus myBus;\n\nint size;\n\nvoid setup() {\n  size(400, 400);\n  background(0);\n\n  MidiBus.list(); \n\n  myBus = new MidiBus(this, 0, 1);\n}\n\nvoid draw() {\n  background(0);\n  rectMode(CENTER);\n  rect(width/2, height/2, size, size);\n}\n\nvoid noteOn(int channel, int pitch, int velocity) {\n  println();\n  println(\"Note On:\" + \" Channel: \"+channel + \" Pitch: \"+pitch + \" Velocity: \"+velocity);\n  println(\"--------\");\n  size = pitch;\n}\n\nvoid noteOff(int channel, int pitch, int velocity) {\n  size = 0;\n}\n</code></pre> <p>Ed ecco il risultato:</p> <p>https://www.youtube.com/watch?v=eqFHk1_AN84</p>","tags":["albeton-live","midi","processing","sincronizzazione"]},{"location":"2017-05-28-quick-draw-google-processing/","title":"Quick, Draw! + Processing: lavorare con il dataset di Google con pi\u00f9 di 50 milioni di disegni","text":"<p>A\u00a0fine 2016 Google ha\u00a0messo on-line\u00a0Quick, Draw!\u00a0uno dei suoi esperimenti di intelligenza artificiale e machine learning. Il sito chiede alle persone di disegnare delle forme: un maiale, un tubo per annaffiare il prato, una padella, ecc... e in meno di 20 secondi, attraverso una rete\u00a0neurale, il computer prova a indovinare cosa \u00e8 stato disegnato.</p> <p>Pi\u00f9 di 15 milioni di persone hanno partecipato al gioco e, cos\u00ec facendo, Google \u00e8 riuscita a raccogliere un dataset di pi\u00f9 di 50 milioni di disegni che, qualche giorno fa, \u00e8 stato rilasciato pubblicamente.</p> <p>Il dataset si compone di 345 categorie\u00a0e, oltre ai dati vettoriali delle immagini sono inclusi anche una serie di metadati.</p> <p>L'obiettivo del rilascio di questi dati \u00e8:</p> <p>We're sharing them here for developers, researchers, and artists to explore, study, and learn from.</p> <p>Nel giro di poche\u00a0ore sul mio feed twitter sono comparsi i primi esperimenti (i pi\u00f9 interessanti sono quelli di @frauzufall che trovate qui) la maggior parte dei quali, per\u00f2, generati con OpenFrameworks.</p> <p>Non trovando nessuno che stesse utilizzando Processing, ho deciso di\u00a0scrivere un piccolo programma\u00a0in questo linguaggio per dare la possibilit\u00e0 a tutti di utilizzare questo dataset</p>","tags":["data-visualization","dataset","google","processing","quick-draw"]},{"location":"2017-05-28-quick-draw-google-processing/#struttura-dei-dati","title":"Struttura dei dati","text":"<p>I file che si scaricano dal repository rilasciato da Google sono file di tipo .ndjson\u00a0ovvero file con un oggetto di tipo JSON per ogni riga di file.</p> <p>Ciascun oggetto \u00e8 composto dai seguenti dati:</p> <ul> <li>key_id (integer): numero univoco che identifica il disegno</li> <li>word\u00a0(string): la categoria che era stata richiesta</li> <li>recognized\u00a0(boolean): se il disegno era stato riconosciuto (true) oppure no (false)</li> <li>timestamp (datetime): quando il disegno \u00e8 stato creato</li> <li>countrycode (string): due lettere per identificare la nazione del giocatore</li> <li>drawing (string): un array JSON contenente i dati vettoriali del disegno</li> </ul> <pre><code>{ \n    \"key_id\":\"5891796615823360\",\n    \"word\":\"nose\",\n    \"countrycode\":\"AE\",\n    \"timestamp\":\"2017-03-01 20:41:36.70725 UTC\",\n    \"recognized\":true,\n    \"drawing\":[[[129,128,129,129,130,130,131,132,132,133,133,133,133,...]]]\n  }\n</code></pre> <p>Per semplificarmi la vita, mi sono concentrato solo sull'ultimo tipo di dato: il mio obiettivo era caricare i dati del dataset e ridisegnare le forme con Processing.</p> <p>L'array contenente i dati del disegno \u00e8 a sua volta strutturato in questo modo:</p> <pre><code>[ \n  [  // First stroke \n    [x0, x1, x2, x3, ...],\n    [y0, y1, y2, y3, ...],\n    [t0, t1, t2, t3, ...]\n  ],\n  [  // Second stroke\n    [x0, x1, x2, x3, ...],\n    [y0, y1, y2, y3, ...],\n    [t0, t1, t2, t3, ...]\n  ],\n  ... // Additional strokes\n]\n</code></pre> <p>Per fortuna la documentazione di Google \u00e8 molto chiara: x e y sono le coordinate e t \u00e8 il tempo trascorso in millisecondi dal primo punto.</p>","tags":["data-visualization","dataset","google","processing","quick-draw"]},{"location":"2017-05-28-quick-draw-google-processing/#dati-preprocessati","title":"Dati preprocessati","text":"<p>I dati contenuti nel dataset sono molti e, infatti, ciascun file pesa diverse centinaia di megabyte. Per fortuna il team di Google ha messo a disposizione anche dei file preprocessati: sono state rimosse le informazioni temporali e tutti i dati sono stati allineati e ridimensionali in un quadrato di 256x256 pixel.</p> <p>I file .ndjson prepocessati sono disponibili a questo link\u00a0e, come potete notare, la dimensione \u00e8 notevolmente ridotta anche se si tratta, pur sempre, di almeno 40-50 megabyte per file.</p>","tags":["data-visualization","dataset","google","processing","quick-draw"]},{"location":"2017-05-28-quick-draw-google-processing/#importare-i-dati-in-processing","title":"Importare i dati in Processing","text":"<p>Primo problema: in Processing\u00a0non esistono funzioni che ci permettono di lavorare su\u00a0oggetti di tipo JSON differenti a meno che non siano inclusi in un array. All'inizio avevo, dunque, optato per modificare il file dei dati ma, grazie al suggerimento di un utente\u00a0su Facebook, ho scoperto l'esistenza dell'oggetto\u00a0BufferedReader che si usa per leggere un file una riga alla volta.</p> <p>Una volta risolto questo inghippo, tutto \u00e8 diventato pi\u00f9 semplice: le linee restituite dall'oggetto sono di tipo String. Con la funzione\u00a0parseJSONObject() ho convertito la stringa in un oggetto JSON.</p>","tags":["data-visualization","dataset","google","processing","quick-draw"]},{"location":"2017-05-28-quick-draw-google-processing/#quick-draw","title":"Quick, Draw!","text":"<p>  Vorrei conoscere chi ha disegnato questa \"incudine\"</p> <p>Avendo accesso all'oggetto JSON, l'unico passaggio da fare era estrarre\u00a0dall'array\u00a0drawing i dati x e y e assegnarli ai vertici di una forma per poterla disegnare a schermo.</p> <p>Per farli ho usato un'insieme di funzioni di cui parleremo in futuro.</p> <p>Per i pi\u00f9 curiosi, il codice \u00e8 disponibile su questo repository su GitHub.</p>","tags":["data-visualization","dataset","google","processing","quick-draw"]},{"location":"2021-02-22-libreria-nice-color-palettes-per-processing/","title":"Libreria Nice Color Palettes per Processing","text":"<p>Quasi due anni fa ho sviluppato la mia prima libreria per Processing chiamata Nice Color Palettes. Pi\u00f9 che sviluppata da zero sarebbe meglio dire che ho effettuato il porting in Java della libreria nice-color-palettes sviluppata in javascript da Matt Deslauriers.</p> <p>Non ho idea del perch\u00e9 abbia fatto passare due anni prima di scriverne. Ma eccoci qua.</p> <p>Come, forse, avrete capito, sono ossessionato dai colori e dal trovare delle combinazioni che stanno bene insieme. Per mia e nostra fortuna esistono alcuni siti o applicazioni come Coolors.co o Adobe Color che ci aiutano nella ricerca della palette perfetta.</p> <p>Uno dei primi siti a fare questo \u00e8 stato Colour Lovers che, si d\u00e0 il caso, abbia anche un'API che pu\u00f2 essere interrogata per sapere quali sono le palette di colori pi\u00f9 votate dagli utenti.</p> <p>L'idea alla base di questa libreria era avere un modo rapido di accedere a varie combinazioni di colori che, tecnicamente, funzionano bene per usarle subito all'interno dei miei sketch.</p>","tags":["colors","librerie","nice-color-palettes","palette","processing"]},{"location":"2021-02-22-libreria-nice-color-palettes-per-processing/#installazione","title":"Installazione","text":"<p>La libreria pu\u00f2 essere scaricata direttamente da GitHub e installata trascinando i file all'interno della cartella libraries di Processing. Oppure potete pi\u00f9 semplicemente aprire Processing, cliccare nel menu Sketch &gt; Importa Libreria &gt; Aggiungi Libreria.</p> <p>Nella finestra che si apre, cercate Nice Color Palette nel campo di ricerca, la selezionate e cliccate Install.</p> <p></p>","tags":["colors","librerie","nice-color-palettes","palette","processing"]},{"location":"2021-02-22-libreria-nice-color-palettes-per-processing/#come-usare-nice-color-palettes","title":"Come usare Nice Color Palettes","text":"<p>Come prima cosa nel nostro sketch dobbiamo importare la libreria. Di solito l'importazione delle librerie esterne viene fatta come prima cosa nei programmi</p> <pre><code>import nice.palettes.*;\n</code></pre> <p>Dopodich\u00e9 bisogna dichiarare l'oggetto di tipo ColorPalette. In questo caso gli ho assegnato il nome palette ma, ovviamente, potete scegliere quello che pi\u00f9 vi piace.</p> <pre><code>ColorPalette palette;\n</code></pre> <p>Ora, all'interno del ciclo di setup, dobbiamo fare l'inizializzazione</p> <pre><code>palette = new ColorPalette(this);\n</code></pre>","tags":["colors","librerie","nice-color-palettes","palette","processing"]},{"location":"2021-02-22-libreria-nice-color-palettes-per-processing/#ottenere-una-palette-di-colori-in-modo-casuale","title":"Ottenere una palette di colori in modo casuale","text":"<p>A questo punto possiamo chiamare la funzione getPalette() presente all'interno della libreria per ottenere un array di cinque colori scelti casualmente tra i 100 pi\u00f9 votati sul sito Colour Lovers</p> <pre><code>import nice.palettes.*;\nColorPalette palette;\n\nvoid setup() {\n  palette = new ColorPalette(this);\n  printArray(palette.getPalette());\n  noLoop();\n}\n\nvoid draw() {\n}\n</code></pre> <p>Il risultato in console sar\u00e0 simile a questo:</p> <p>[0] -12501430 [1] -9215378 [2] -5013116 [3] -1002338 [4] -531266</p> <p>Ricordatevi che gli array iniziamo sempre a contare da zero. Purtroppo questi numeri non ci dicono molto, quindi realizziamo subito un programma che ci mostri il risultato visivamente</p> <pre><code>import nice.palettes.*;\n\nColorPalette palette;\n\nvoid setup() {\n  size(500, 500);\n  noStroke();\n  palette = new ColorPalette(this);\n  palette.getPalette();\n\n  for(int i = 0; i &lt; 5; i++) {\n    fill(palette.colors[i]);\n    rect(i * width/5, 0, width/5, height);\n  }\n\n  noLoop();\n}\n\nvoid draw() {\n}\n</code></pre> <p>Otterremo qualcosa simile a questo</p> <p></p> <p>Siccome le palette sono caricate in modo casuale, ogni volta che premeremo Run il risultato sar\u00e0 diverso.</p>","tags":["colors","librerie","nice-color-palettes","palette","processing"]},{"location":"2021-02-22-libreria-nice-color-palettes-per-processing/#ottenere-una-palette-specifica","title":"Ottenere una palette specifica","text":"<p>Per ottenere una palette specifica, \u00e8 sufficiente passare un parametro numerico alla nostra funzione getPalette()</p> <p>Sostituendo, ad esempio, nel codice qui sopra la riga palette.getPalette(); con:</p> <pre><code>palette.getPalette(5);\n</code></pre> <p>Otterremo sempre la stessa combinazione di colori</p>","tags":["colors","librerie","nice-color-palettes","palette","processing"]},{"location":"2021-02-22-libreria-nice-color-palettes-per-processing/#altre-funzioni-della-libreria","title":"Altre funzioni della libreria","text":"<p>\u00c8 possibile usare la funzione getPaletteCount() per ottenere il numero di palette disponibili.</p> <pre><code>println(palette.getPaletteCount());\n</code></pre> <p>oppure accedere direttamente all'array di colori presenti dentro l'oggetto:</p> <pre><code>palette.colors[0];\n</code></pre> <p>Ricordatevi che l'array contiene sempre 5 elementi per cui se scrivete palette.colors[5]; restituir\u00e0 un errore.</p> <p>Infine \u00e8 possibile fare un refresh delle palette dal sito:</p> <pre><code>palette.refresh();\n</code></pre> <p>Di default questa funzione restituisce 20 valori ma \u00e8 possibile arrivare fino a 100 (limite massimo dell'API) passando questo valore come parametro:</p> <pre><code>palette.refresh(100)\n</code></pre> <p>La libreria \u00e8 pensata per funzionare anche in assenza di connessione a internet perch\u00e9, al suo interno, contiene un file .json con 100 palette di colori.</p>","tags":["colors","librerie","nice-color-palettes","palette","processing"]},{"location":"coding-rescue/2017-06-11-coding-rescue-1/","title":"Coding Rescue #1 - Invertire sotto-sopra una porzione di un'immagine","text":"","tags":["coding-rescue","image","intlist","loadpixel"]},{"location":"coding-rescue/2017-06-11-coding-rescue-1/#coding-rescue-1-invertire-sotto-sopra-una-porzione-di-unimmagine","title":"Coding Rescue #1 - Invertire sotto-sopra una porzione di un'immagine","text":"<p>Inauguro oggi con questo post una rubrica chiamata Coding Rescue\u00a0ovvero: come risolvere problemi di programmazione che mi vengono posti dai lettori del blog. Ogni tanto capita che qualcuno mi scriva privatamente perch\u00e9 \u00e8 rimasto bloccato con un esercizio in Processing che non riesce a risolvere e mi viene chiesto di dare una mano a trovare una soluzione.</p> <p>Mi piace ricevere questo genere di messaggi perch\u00e9 mi permette di scontrarmi con difficolt\u00e0 a cui non avevo mai pensato. Dal momento che capita a tutti \u2013 sottoscritto compreso \u2013 di rimanere bloccati per giorni, penso che aiutare le persone sia un ottimo modo per allenarsi e imparare qualcosa di nuovo.</p>","tags":["coding-rescue","image","intlist","loadpixel"]},{"location":"coding-rescue/2017-06-11-coding-rescue-1/#il-problema","title":"Il problema","text":"<p>Qualche giorno fa ho ricevuto il seguente messaggio sulla mia pagina Facebook:</p> <p>creare un progettino, ovvero una funzione, che inverte (sotto sopra) l'immagine, solo all'interno di un quadrato che si crea intorno al puntatore del mouse.</p> <p>Il problema \u00e8 interessante perch\u00e9 pone una serie di sfide che, sommate, non sono per nulla semplici:</p> <ol> <li>Dobbiamo lavorare con un'immagine</li> <li>Lo script deve essere dinamico perch\u00e9 in relazione alla posizione del puntatore del mouse</li> <li>Dobbiamo invertire sotto sopra una porzione di un'immagine</li> </ol> <p>Come consiglio sempre: \u00e8 importante concentrarsi sui vari punti uno per volta perch\u00e9, altrimenti, si rischia di non arrivare facilmente alla soluzione.</p>","tags":["coding-rescue","image","intlist","loadpixel"]},{"location":"coding-rescue/2017-06-11-coding-rescue-1/#la-soluzione-in-pseudo-codice","title":"La soluzione in pseudo-codice","text":"<p>Prima di cominciare a scrivere il codice, proviamo a descrivere il funzionamento del programma a parole; ho sottolineato con il corsivo le parole chiave: il nostro sketch dovr\u00e0, all'avvio, caricare un'immagine. Intorno alla posizione del mouse disegneremo un quadrato e, una volta analizzati i pixel presenti all'interno di questo quadrato, creeremo e disegneremo una nuova immagine che avr\u00e0\u00a0dimensione pari a quella del quadrato i cui pixel, rispetto all'originale, saranno invertiti sotto-sopra.</p>","tags":["coding-rescue","image","intlist","loadpixel"]},{"location":"coding-rescue/2017-06-11-coding-rescue-1/#la-soluzione-passo-dopo-passo","title":"La soluzione: passo dopo passo","text":"","tags":["coding-rescue","image","intlist","loadpixel"]},{"location":"coding-rescue/2017-06-11-coding-rescue-1/#1-carichiamo-limmagine","title":"1. Carichiamo l'immagine","text":"<p>Per prima cosa dobbiamo ripassare come si lavora sulle immagini:</p> <ul> <li>Utilizzare immagini in Processing: PImage, loadimage() e image()</li> <li>Array di pixel: loadPixels() e updatePixels()</li> </ul> <p>Per risolvere il problema avremo bisogno di due oggetti immagine: il primo sar\u00e0 l'immagine originale mentre, la seconda, sar\u00e0 l'immagine con i pixel invertiti che chiamer\u00f2\u00a0flipped. Avremo inoltre bisogno di impostare una variabile che determiner\u00e0 la larghezza del quadrato e, di conseguenza, la grandezza dell'immagine che andr\u00f2 a creare. Per questo esercizio, ho deciso di usare la foto di un corgi.</p> <p>Nella funzione draw, per il momento, mi preoccupo solo di disegnare un quadrato intorno alla posizione del mouse.</p> <pre><code>/*\n * Coding Rescue #1 - Invertire sotto-sopra una porzione di un'immagine\n * Federico Pepe, 11.06.2017\n * http://blog.federicopepe.com/processing\n */\n\n// Creo i due oggetti immagine\nPImage img, flipped;\n\n// Variabile che determina la larghezza del quadrato\nint w = 100;\n\nvoid setup() {\n  size(700, 542);\n  // Carico l'immagine originale e la disegno\n  img = loadImage(\"corgi-photo.jpg\");\n  image(img, 0, 0);\n  // Creo l'immagine flipped\n  flipped = createImage(w, w, RGB);\n  noFill();\n}\n\nvoid draw() {\n  image(img, 0, 0);\n\n  rectMode(CENTER);\n  rect(mouseX, mouseY, w, w);\n}\n</code></pre>","tags":["coding-rescue","image","intlist","loadpixel"]},{"location":"coding-rescue/2017-06-11-coding-rescue-1/#2-carichiamo-i-pixel-di-riferimento-in-un-array","title":"2. Carichiamo i pixel di riferimento in un array","text":"<p>Il prossimo passaggio sar\u00e0 analizzare i pixel all'interno del quadrato disegnato e inserirli uno per uno all'interno di un array: avendo come riferimento la posizione del mouse e volendo tenere quel punto al centro del quadrato creo quattro variabili:\u00a0startX, startY, endX\u00a0ed\u00a0endY che mi serviranno come riferimento per i cicli for.</p> <p>Invece di utilizzare un array classico, decido di usare una variabile di tipo\u00a0IntList questo perch\u00e9 si tratta di un tipo di dato pi\u00f9 flessibile che gestisce gli elementi al suo interno in modo pi\u00f9 dinamico e rapido. Operazioni quali l'aggiunta, la modifica, la lettura dei dati al suo interno sono pi\u00f9 veloci e semplici da eseguire rispetto ai comuni array.</p> <pre><code>/*\n * Coding Rescue #1 - Invertire sotto-sopra una porzione di un'immagine\n * Federico Pepe, 11.06.2017\n * http://blog.federicopepe.com/processing\n */\n\n// Creo i due oggetti immagine\nPImage img, flipped;\n\n// Variabile che determina la larghezza del quadrato\nint w = 100;\n\n// Variabile nella quale inserir\u00f2 tutti i pixel analizzati\nIntList arrayPixel = new IntList();\n\nvoid setup() {\n  size(700, 542);\n  // Carico l'immagine originale e la disegno\n  img = loadImage(\"corgi-photo.jpg\");\n  image(img, 0, 0);\n  // Creo l'immagine flipped\n  flipped = createImage(w, w, RGB);\n  noFill();\n}\n\nvoid draw() {\n  image(img, 0, 0);\n\n  int startX = mouseX-w/2;\n  int startY = mouseY-w/2;\n  int endX = mouseX + w/2;\n  int endY = mouseY + w/2;\n\n  img.loadPixels();\n\n  for (int y = startY; y &lt; endY; y++) {\n    for (int x = startX; x &lt; endX; x++) {\n      arrayPixel.append(get(x, y));\n    }\n  }\n\n  rectMode(CENTER);\n  rect(mouseX, mouseY, w, w);\n}\n</code></pre> <p>Problema:</p> <p>In questo momento ad ogni iterazione di draw, la variabile arrayPixel, grazie alla funzione append(), viene ingrandita di 10.000 valori (100*100). Per vedere cosa accade, provate ad aggiungere:\u00a0<code>println(arrayPixel.size());</code>. Se provassimo a disegnare un'immagine con una dimensione variabile, il programma andrebbe in crash. \u00c8 importante, dunque, svuotare l'array prima dei cicli for con la funzione clear():\u00a0<code>arrayPixel.clear();</code></p>","tags":["coding-rescue","image","intlist","loadpixel"]},{"location":"coding-rescue/2017-06-11-coding-rescue-1/#3-aggiungiamo-i-pixel-analizzati-nellimmagine-di-destinazione","title":"3. Aggiungiamo i pixel analizzati nell'immagine di destinazione","text":"<p>Ora che i pixel contenuti nel quadrato di riferimento sono stati aggiunti all'array dobbiamo trasferirli tutti all'interno della nostra immagine di destinazione che abbiamo creato in precedenza.</p> <p>Carichiamo, quindi, i pixel dell'immagine di destinazione e, attraverso un ciclo for, assegniamo a ogni pixel il pixel relativo presente all'interno dell'array:</p> <pre><code>flipped.loadPixels();\nfor (int i = 0; i &lt; arrayPixel.size(); i++) {\n  flipped.pixels[i] = arrayPixel.get(i);\n}\nflipped.updatePixels();\n</code></pre> <p>Aggiungendo\u00a0<code>image(flipped, 0, 0);</code> alla fine del ciclo draw e cliccando su Run dovreste vedere in alto a sinistra un quadrato di 100 pixel contenente la stessa immagine del quadrato di riferimento disegnato intorno alla posizione del mouse.</p> <p>Ora non ci resta che completare il lavoro.</p>","tags":["coding-rescue","image","intlist","loadpixel"]},{"location":"coding-rescue/2017-06-11-coding-rescue-1/#4-invertire-limmagine-di-destinazione-sotto-sopra","title":"4. Invertire l'immagine di destinazione sotto-sopra","text":"<p>Mentre lavoravo all'esercizio, arrivato a questo punto mi sono bloccato. Per invertire un'immagine sottosopra avrei dovuto modificare l'ultimo ciclo for scritto per fare in modo che i pixel venissero scritti nell'immagine di destinazione invertiti rispetto all'originale. Su questa cosa ho sbattuto la testa per qualche giorno poi \u00e8 arrivata l'illuminazione: anzich\u00e9 andare a complicarmi la vita con i pixel, avrei potuto usare le funzioni di trasformazione.</p> <p>In particolare, dopo aver fatto una veloce ricerca, se passiamo valori negativi alla funzione scale(), otteniamo l'immagine invertita.</p> <pre><code>pushMatrix();\ntranslate(startX, startY+w);\nscale(1, -1);\nimage(flipped, 0, 0);\npopMatrix();\n</code></pre> <p>Ecco che con queste poche righe di codice, siamo giunti alla fine: se non vi ricordate come funzionano, potete ripassare pushMatrix() e popMatrix() a questo indirizzo.</p>","tags":["coding-rescue","image","intlist","loadpixel"]},{"location":"coding-rescue/2017-06-11-coding-rescue-1/#risultato-finale","title":"Risultato finale:","text":"","tags":["coding-rescue","image","intlist","loadpixel"]},{"location":"coding-rescue/2017-10-26-coding-rescue-2-binarizza/","title":"Coding Rescue #2 - Binarizza un'immagine","text":""},{"location":"coding-rescue/2017-10-26-coding-rescue-2-binarizza/#coding-rescue-2-binarizza-unimmagine","title":"Coding Rescue #2 - Binarizza un'immagine","text":"<p>Secondo capitolo della rubrica Coding Rescue dove provo a risolvere i vostri problemi con Processing. Questa volta la consegna \u00e8 piuttosto articolata, riassumo i punti salienti:</p> <ul> <li>Lo scopo del programma \u00e8 quello di \"binarizzare\" un'immagine ovvero fare in modo che, al click del mouse, i colori dell'immagine vengano modificati utilizzando la funzione binarize().\u00a0La funzione imposta un pixel bianco se la sua luminosit\u00e0 \u00e8 maggiore di una soglia impostata e\u00a0nero se inferiore.</li> <li>per calcolare la luminosit\u00e0, si deve utilizzare la funzione brightness().</li> <li>impostare la soglia iniziale a un valore predefinito (a scelta) ma implementare una funzione calculateThreshold()\u00a0con cui ricalcolarla dinamicamente utilizzando al distanza percorsa dal mouse tra due frame successivi.</li> </ul>"},{"location":"coding-rescue/2017-10-26-coding-rescue-2-binarizza/#binarizza-unimmagine-la-soluzione","title":"Binarizza un'immagine, la soluzione","text":"<p>Ecco qui il codice:</p> <pre><code>/*\n * Coding Rescue #2 - Binarizzare un'immagine\n * Federico Pepe, 26.10.2017\n * http://blog.federicopepe.com/processing\n */\nfloat threshold = 150;\nPImage immagine, imgbin;\nboolean bin = true;\n\nvoid setup() {\n  size(700, 542);\n  immagine = loadImage(\"corgi-photo.jpg\");\n  image(immagine, 0, 0);\n  frameRate(2);\n} \n\nvoid draw() {\n  threshold = calculateThreshold();\n  if (bin) {\n    imgbin = immagine.copy();\n    image(binarize(imgbin), 0, 0);\n  } else {\n    image(immagine, 0, 0);\n  }\n}\n\nvoid mouseClicked() {\n  bin = !bin;\n}  \n\nPImage binarize(PImage img) {\n  img.loadPixels();\n  for (int y = 0; y &lt; img.height; y++) {\n    for (int x = 0; x &lt; img.width; x++) { int loc = x + y * img.width; if (brightness(img.pixels[loc]) &gt; threshold) {\n        img.pixels[loc] = color(0);\n      } else {\n        img.pixels[loc] = color(255);\n      }\n    }\n  }\n  img.updatePixels();\n  return img;\n}\n\nfloat calculateThreshold() {\n  float d = dist(pmouseX, pmouseY, mouseX, mouseY);\n  threshold = d;\n  return threshold;\n}\n</code></pre>"},{"location":"coding-rescue/2018-01-21-coding-rescue-3-cambiare-la-tonalita-pixel/","title":"Coding Rescue #3 \u2013 Cambiare la tonalit\u00e0 di alcuni pixel","text":"","tags":["coding-rescue","loadpixels","processing"]},{"location":"coding-rescue/2018-01-21-coding-rescue-3-cambiare-la-tonalita-pixel/#coding-rescue-3-cambiare-la-tonalita-di-alcuni-pixel","title":"Coding Rescue #3 \u2013 Cambiare la tonalit\u00e0 di alcuni pixel","text":"<p>Negli ultimi giorni ho ricevuto diverse richieste di aiuto per problemi di codice in Processing; ecco la soluzione a uno dei problemi che mi sono stati posti.</p> <p>Ho deciso di chiamare questo Coding Rescue:\u00a0cambiare la tonalit\u00e0 di alcuni pixel.</p>","tags":["coding-rescue","loadpixels","processing"]},{"location":"coding-rescue/2018-01-21-coding-rescue-3-cambiare-la-tonalita-pixel/#il-problema","title":"Il problema","text":"<p>Il quesito era piuttosto articolato:</p> <ul> <li>Il programma deve caricare un'immagine dal disco.</li> <li>Il programma decide se modificare o no il pixel in base ad un valore casuale.</li> <li>Il processo di trasformazione viene controllato dal click \u00a0del mouse: un primo click avvia la trasformazione che, con un successivo click, viene messa in pausa. Un ulteriore click fa ripartire la trasformazione e cos\u00ec via.</li> <li>I pixel devono essere modificati di continuo.</li> <li>Il compito deve essere svolto mediante la funzione creaImmagine(), che accetta in ingresso un oggetto di tipo PImage e rende in uscita un oggetto di tipo PImage, che sar\u00e0\u00a0l\u2019immagine modificata come da specifiche, e la funzione calcolaPixel(), che accetta in ingresso un oggetto di tipo color e rende in uscita un oggetto di tipo color, che sar\u00e0 il pixel\u00a0modificato come da specifiche.</li> <li>creaImmagine() crea una nuova immagine utilizzando su ciascun pixel la funzione calcolaPixel().</li> <li>calcolaPixel() calcola il nuovo pixel nel seguente modo: siano r, g, b i livelli di canale di un pixel.\u00a0Sia treshold un valore numerico posto inizialmente a 0.5.\u00a0Sia r un valore casuale compreso tra 0 e 1, generato per ogni pixel.\u00a0Se r&gt;soglia, allora la funzione lascia il pixel inalterato, in caso contrario\u00a0il programma calcola i nuovi valori rm, gm, bm\u00a0(che definiscono il pixel modificato) nel seguente modo:<ul> <li>rm = 0.393\u2217r+0.769\u2217g+0.189\u2217b</li> <li>gm = 0.349\u2217r+0.686\u2217g+0.168\u2217b</li> <li>bm = 0.272\u2217r+0.534\u2217g+0.131\u2217bIn ogni caso i valori finali di r, g, b devono essere valori leciti, cio\u00e8 compresi tra 0 e 255.</li> </ul> </li> <li>Quando l'utente preme il tasto \"+\" la soglia viene incrementata di 0.1 mentre, con la pressione del tasto \"-\" la soglia viene decrementata di 0.1.</li> </ul>","tags":["coding-rescue","loadpixels","processing"]},{"location":"coding-rescue/2018-01-21-coding-rescue-3-cambiare-la-tonalita-pixel/#la-soluzione","title":"La soluzione","text":"<pre><code>/*\n * Coding Rescue #3 - Cambiare la tonalit\u00e0 di alcuni pixel\n * Federico Pepe, 21.01.2018\n * http://blog.federicopepe.com/processing\n */\n\n// Creo le variabili necessarie;\nfloat threshold = 0.5;\nboolean work = true;\nPImage original, edited;\n\nvoid setup() {\n  // Nella funzione di setup carico il file dall'hard disk;\n  size(1, 1);\n  surface.setResizable(true);\n  selectInput(\"Select a file to process:\", \"fileSelected\");\n}\n\nvoid draw() {\n  if (original != null) {\n    edited = original.copy();\n    /*\n     * Se la variabile work, il cui valore dipende dal click del mouse \u00e8 true, mostro\n     * l'immagine originale, altrimenti avvio la modifica\n     */\n    if (work) {\n      image(edited, 0, 0);\n    } else {\n      image(creaImmagine(edited), 0, 0);\n    }\n  }\n}\n\n// Funzione per gestire il caricamento dei file da HD\n// https://processing.org/reference/selectInput_.html\nvoid fileSelected(File selection) {\n  if (selection == null) {\n    println(\"Window was closed or the user hit cancel.\");\n  } else {\n    println(\"User selected \" + selection.getAbsolutePath());\n    original = loadImage(selection.getAbsolutePath());\n    surface.setSize(original.width, original.height);\n  }\n}\n\n// Funzione creaImmagine che, come da specifiche, accetta in ingresso un oggetto PImage\n// e restituisce un oggetto PImage;\nPImage creaImmagine(PImage img) {\n  // Carico i pixel in un array\n  img.loadPixels();\n  for (int y = 0; y &lt; img.height; y++) {\n    for (int x = 0; x &lt; img.width; x++) {\n      int loc = x + y * img.width;\n      // Ottengo i valori R, G, B di ciascun pixel;\n      float r = red(img.pixels[loc]);\n      float g = green(img.pixels[loc]);\n      float b = blue(img.pixels[loc]);\n      // Lancio la funziona calcolaPixel\n      img.pixels[loc] = calcolaPixel(color(r, g, b));\n    }\n  }\n  img.updatePixels();\n  return img;\n}\n\ncolor calcolaPixel(color c) {\n  // Valore casuale, come da specifiche\n  float r = random(0, 1);\n\n  if (r &gt; threshold) {\n    // Se r \u00e8 maggiore della soglia, restituisco il colore originale\n    return c;\n  } else {\n    // Altrimenti calcolo il nuovo valore del pixel come richiesto\n    // la funzione constrain mi assicura che il valore calcolato sia compreso tra 0 e 255;\n    float rm = constrain(0.393*red(c)+0.769*green(c)+0.189*blue(c), 0, 255);\n    float gm = constrain(0.349*red(c)+0.686*green(c)+0.168*blue(c), 0, 255);\n    float bm = constrain(0.272*red(c)+0.534*green(c)+0.131*blue(c), 0, 255);\n    // Restituisco i nuovi valori\n    return color(rm, gm, bm);\n  }\n}\n\n// Con la funzione keyPressed determino la pressione dei tasti + e -\nvoid keyPressed() {\n  if (key == '+') {\n    threshold += 0.1;\n  }\n  if (key == '-') {\n    threshold -= 0.1;\n  }\n  // Utilizzo la funzione round (di seguito) per arrotondare il valore a 2 decimali;\n  round(threshold, 2);\n}\n// Alla pressione del mouse, cambio il valore di work da true a false e viceversa\nvoid mouseClicked() {\n  work = !work;\n}\n// Funzione utile per limitare il numero di decimali in un float\n// https://stackoverflow.com/questions/9627182/how-do-i-limit-decimal-precision-in-processing\nfloat round(float number, float decimal) {\n  return (float)(round((number*pow(10, decimal))))/pow(10, decimal);\n} \n</code></pre>","tags":["coding-rescue","loadpixels","processing"]},{"location":"data/2018-01-07-lavorare-con-i-dati/","title":"Lavorare con i dati","text":"<p>Nel mondo digitale tutto \u00e8 un insieme di dati: che si tratti di un testo, una foto oppure un video, stiamo parlando di una sequenza di 1 e 0 che chiamiamo comunemente\u00a0file.</p> <p>Con questo post inauguro una nuovo capitolo su questo blog in cui scopriremo insieme come utilizzare Processing per lavorare con file e dati.</p> <p>Quale potrebbe essere il vantaggio di utilizzare un linguaggio di programmazione per questo genere di attivit\u00e0? Perch\u00e9 non possiamo utilizzare strumenti per grafici o designer come Photoshop o Illustrator? La risposta \u00e8 semplice: uno dei vantaggi dei computer rispetto alla mente umana \u00e8 che sono in grado di processare velocemente numeri ed eseguire operazioni ripetitive e complesse molto velocemente.</p> <p>La vista di un file di Excel pieno di righe e colonne pu\u00f2 scatenare il panico nelle persone sane di mente ma per un software non servono altro che\u00a0due cicli for per accedere al contenuto di ciascuna cella. Quello che impareremo a fare sar\u00e0, poi, assegnare quel contenuto a una (o pi\u00f9) variabili e il gioco \u00e8 fatto.</p> <p>Pensiamo alle visualizzazioni di dati che negli ultimi anni sono diventate onnipresenti su siti web, riviste e quotidiani. Il loro successo \u00e8 dovuto al fatto che, grazie a un linguaggio di tipo visuale, rendono pi\u00f9 accessibile il contenuto della storia, anche quando include una grande mole di dati. A differenza della carta stampata realizzando un'infografica con Processing si apre un ventaglio di possibilit\u00e0: possiamo renderla interattiva, in 3D, pu\u00f2 essere su uno schermo oppure proiettata su una parete.</p>"},{"location":"data/2018-01-07-lavorare-con-i-dati/#tipi-di-dato","title":"Tipi di dato","text":"<p>Quali saranno i tipi di dati su cui lavoreremo? Abbiamo gi\u00e0 avuto modo di parlare di immagini e pixel\u00a0(tema che approfondiremo), ma in questa sezione ci concentreremo su:</p> <ul> <li>File di testo (.txt)</li> <li>Tabelle di dati di Excel (.csv, .tsv)</li> <li>Pagine web (.html)</li> <li>Feed (.xml)</li> <li>API (.json)</li> </ul>"},{"location":"data/2018-03-25-dati-read-file-csv/","title":"Leggere file CSV","text":"<p>Cominciamo il nostro percorso per imparare a lavorare con i dati: in questo post vedremo insieme come utilizzare i file di tipo CSV in Processing.</p> <p>Per chi non conoscesse questo tipo di file o ci li avesse mai usati si tratta, in breve, di file di testo in cui i valori sono separati da virgole. CSV, infatti, sta per\u00a0comma separated values. Nella maggior parte dei casi questi file vengono esportati da Microsoft Excel, uno dei programmi pi\u00f9 diffusi (e odiati) per gestire tabelle di dati.</p> <p>Per dare la possibilit\u00e0 a chiunque mi segua sul blog di seguire gli esercizi, utilizzer\u00f2\u00a0Google Sheet, alternativa gratuita e accessibile via browser del blasonato programma di Microsoft.</p> <p>Ecco, quindi, il nostro primo set di dati: le\u00a0statistiche metoclimatiche degli ultimi 10 anni (2008-2017) della regione Veneto, prese dal sito del\u00a0Mipaaf\u00a0e portate su Google Sheet.</p> <p>Scarica i dati</p> <p>Per esportare il file come CSV cliccate su\u00a0File &gt; Scarica Come &gt; Valori separati da virgola (.csv, foglio corrente).\u00a0Di seguito le immagini di come si presenta il file prima e dopo l'esportazione:</p> <p>[caption id=\"attachment_1477\" align=\"aligncenter\" width=\"1024\"] I dati visti in Google Sheet[/caption]</p> <p>[caption id=\"attachment_1478\" align=\"aligncenter\" width=\"1024\"] Gli stessi dati, esportati in CSV[/caption]</p>","tags":["csv","dati","getcolumncount","getrowcount","loadstrings","loadtable","table"]},{"location":"data/2018-03-25-dati-read-file-csv/#dati-in-un-file-csv-semplice-testo","title":"Dati in un file CSV: semplice testo","text":"<p>Come dicevamo all'inizio, il file CSV esportato non \u00e8 altro che un file di testo contenente dei valori. Per cominciare a leggerne il contenuto \u00e8 sufficiente utilizzare la funzione\u00a0loadStrings(): tale funzione accetta in input un file di testo e restituisce un array di stringhe.</p> <p>Prima di procedere, consiglio di rinominare il file scaricato in\u00a0data.csv. Non dimenticate di trascinarlo all'interno della finestra di Processing per aggiungerlo al nostro sketch.</p> <pre><code>/*\n * Leggere file CSV\n * Federico Pepe, 25.03.2018\n * http://blog.federicopepe.com/processing\n */\n\nString[] csv;\n\nvoid setup() {\n  csv = loadStrings(\"data.csv\");\n  printArray(csv);\n  noLoop();\n}\n\nvoid draw() {\n}\n</code></pre> <p>Con queste poche righe di codice nella console ogni riga del file viene mostrata come un nuovo elemento dell'array di stringhe.</p> <p>[0] \"Descrizione,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017\" [1] \"Temp. minima (\u00b0C),6.9,7.3,6.7,7.4,7.2,7.7,8.7,8,7.6,7.1\"</p> <p>Fino a qui niente di difficile ma a noi interessa accedere ai singoli valori presenti in ciascuna colonna. A questo punto ci torna utile riprendere gli\u00a0array bidimensionali: un sistema che ci permette di rappresentare facilmente una struttura formata da righe e colonne, proprio come un file excel/csv.</p> <p>Modifichiamo, dunque, il nostro codice come segue:</p> <pre><code>/*\n * Leggere file CSV\n * Federico Pepe, 25.03.2018\n * http://blog.federicopepe.com/processing\n */\n\nString[] csv;\nString[][] dati;\n\nvoid setup() {\n  csv = loadStrings(\"data.csv\");\n  dati = new String[csv.length][10]; \n\n  for(int i = 0; i &lt; csv.length; i++) {\n    dati[i] = csv[i].split(\",\");\n    printArray(dati[i]);\n  }\n\n  noLoop();\n}\n\nvoid draw() {\n}\n</code></pre> <p>Abbiamo aggiunto un array bidimensionale chiamato dati la cui dimensione \u00e8 determinata dal numero di righe <code>[csv.length]</code> e dal numero di colonne meno uno perch\u00e9 si conta sempre da zero <code>[10]</code>.</p> <p>Con un semplice ciclo for accediamo a tutte le righe del file e, utilizzando la funzione <code>.split(\",\")</code> separiamo tutti i valori che sono separati dalla virgola.</p> <p>Affinch\u00e9 sia tutto il pi\u00f9 chiaro possibile possiamo fare un po' di esperimenti con println inserendo nel primo valore dell'array il numero della riga e nel secondo quello della colonna.</p> <p><code>println(dati[3][2]);</code> restituisce il valore 0.7 che corrisponde, infatti, alla cella nella quarta riga \"Scarto dal clima\" e nella terza colonna \"2009\".</p>","tags":["csv","dati","getcolumncount","getrowcount","loadstrings","loadtable","table"]},{"location":"data/2018-03-25-dati-read-file-csv/#leggere-file-csv-in-modo-piu-semplice-table","title":"Leggere file CSV in modo pi\u00f9 semplice: Table","text":"<p>Siamo riusciti nel nostro intento ma credo sia ovvio che il metodo che abbiamo usato non sia il pi\u00f9 congeniale.</p> <p>Per nostra fortuna i creatori di Processing avevano gi\u00e0 pensato a questa evenienza e hanno creato un oggetto specifico chiamato\u00a0Table\u00a0che, come \u00e8 facile intuire dal nome, rappresenta gi\u00e0 una tabella completa di righe e colonne.</p> <p>Grazie ai numerosi metodi disponibili per gli oggetti di tipo Table\u00a0\u00e8 possibile lavorare con i dati in modo semplice e intuitivo.</p> <p>Aggiorniamo il nostro codice:</p> <pre><code>/*\n * Leggere file CSV\n * Federico Pepe, 25.03.2018\n * http://blog.federicopepe.com/processing\n */\n\nTable csv;\n\nvoid setup() {\n  csv = loadTable(\"data.csv\", \"header\");\n\n  println(\"Numero righe: \" + csv.getRowCount());\n  println(\"Numero colonne: \" + csv.getColumnCount());\n\n  for(int i = 0; i &lt; csv.getRowCount(); i++) {\n    println(csv.getFloat(i, 2));\n  }\n\n  noLoop();\n}\n\nvoid draw() {\n}\n</code></pre> <p>Abbiamo sostituito i due array di stringhe con un oggetto di tipo Table chiamato csv. Attraverso la funzione loadTable() carichiamo i dati all'interno della variabile. Passando il parametro \"header\" stiamo dicendo a Processing di ignorare la prima riga del file che contiene l'intestazione.</p> <p>Attraverso le funzioni\u00a0.getRowCount()\u00a0e\u00a0.getColumnCount() accediamo al numero di righe e colonne del file e, infine, con il nostro ciclo for stampiamo in console i valori\u00a0di tipo\u00a0float contenuti nella terza colonna (quindi quelli relativi al 2009).</p>","tags":["csv","dati","getcolumncount","getrowcount","loadstrings","loadtable","table"]},{"location":"data/2018-03-25-dati-read-file-csv/#conclusione","title":"Conclusione","text":"<p>In questo post abbiamo messo molta carne al fuoco e abbiamo cominciato ad addentrarci nel mondo dei dati e dei file CSV. Assicuratevi di aver compreso bene tutte le funzioni e gli esempi inseriti in questo post prima di proseguire con la lettura del prossimo.</p>","tags":["csv","dati","getcolumncount","getrowcount","loadstrings","loadtable","table"]},{"location":"data/2018-04-01-da-una-tabella-csv-agli-array/","title":"Da una tabella CSV agli array","text":"<p>Una volta capito come leggere con Processing i dati contenuti in un file CSV, il passaggio successivo \u00e8 rendere questi dati leggibili e modificabili facilmente all'interno del programma convertendoli in variabili e array.</p> <p>Ripartiamo dal nostro esempio precedente utilizzando sempre lo stesso data set:</p> <pre><code>/*\n * Leggere file CSV\n * Federico Pepe, 25.03.2018\n * http://blog.federicopepe.com/processing\n */\n\nTable csv;\n\nvoid setup() {\n  csv = loadTable(\"data.csv\", \"header\");\n\n  println(\"Numero righe: \" + csv.getRowCount());\n  println(\"Numero colonne: \" + csv.getColumnCount());\n\n  for(int i = 0; i &lt; csv.getRowCount(); i++) {\n    println(csv.getFloat(i, 2));\n  }\n\n  noLoop();\n}\n\nvoid draw() {\n}\n</code></pre> <p>Prima di procedere, assicuriamoci che il programma funzioni cliccando su run: nella console dovrebbero comparire i dati contenuti nella colonna relativa al 2009.</p>","tags":["append","array","csv","dati","getfloat","getint","getstring","table"]},{"location":"data/2018-04-01-da-una-tabella-csv-agli-array/#utilizzare-i-metodi-corretti-per-leggere-i-dati","title":"Utilizzare i metodi corretti per leggere i dati","text":"<p>Un aspetto importante da tenere presente \u00e8 di utilizzare i metodi corretti per accedere ai dati. Spulciando nel reference di Table noterete che esistono diverse funzioni come\u00a0.getFloat(),\u00a0.getInt(),\u00a0.getString().</p> <p>Se sostituiamo nell'esempio precedente la riga\u00a0<code>println(csv.getFloat(i, 2));</code> con\u00a0<code>println(csv.getString(i, 2));</code> Processing non generer\u00e0 nessun errore e continuer\u00e0 a far girare il nostro programma ma, ora, quei valori sono considerati stringhe (quindi testo) e non pi\u00f9 numeri.</p> <p>Tutti questi metodi accettano due parametri: il primo indica la riga della tabella, il secondo la colonna. Per quest'ultimo possiamo usare sia un numero, partendo, come sempre a contare da 0, oppure una stringa contenente il nome della colonna.</p> <p>Il codice, pu\u00f2 essere sostituito con: <code>println(csv.getFloat(i, \"2009\"));</code></p> <p>Se sostituite sempre la stessa riga con <code>println(csv.getFloat(i, \"Descrizione\"));</code> la console vi restituir\u00e0 tutti valori NaN ovvero Not a Number. Come dicevo, il programma continuer\u00e0 a funzionare ma non in modo corretto.</p>","tags":["append","array","csv","dati","getfloat","getint","getstring","table"]},{"location":"data/2018-04-01-da-una-tabella-csv-agli-array/#dal-tabella-csv-allarray","title":"Dal tabella CSV all'array","text":"<p>Passare tutti i dati in un array pu\u00f2 essere molto comodo per utilizzare alcune funzioni specifiche di calcolo, come, ad esempio,\u00a0min() e\u00a0max() che restituiscono, rispettivamente, il valore minimo e massimo di un array.</p> <p>Anche se in questo momento siamo ancora lontani dall'idea di creare una visualizzazione di dati, dovremmo comunque cominciare a pensare a come utilizzeremo questi numeri.</p> <p>Per come \u00e8 stato strutturato il file CSV, ciascuna colonna rappresenta un anno con valori di vario tipo: temperatura minima, temperatura massima, eccetera; ma se noi volessimo rappresentare la variazione di uno stesso valore nel tempo dovremmo lavorare orizzontalmente e non verticalmente.</p> <p>Sfruttiamo questo esempio per capire come passare i dati dal CSV a un array:</p> <p>Creiamo un array di tipo float chiamato\u00a0tempMin nel quale inseriremo tutti i valori di temperatura minima e modifichiamo il nostro ciclo\u00a0for\u00a0per girare non pi\u00f9 sul numero di righe ma su quello delle colonne. Impostiamo l'inizio del ciclo for a 1 per saltare la prima colonna.</p> <pre><code>/*\n * Da una tabella CSV agli array\n * Federico Pepe, 01.04.2018\n * http://blog.federicopepe.com/processing\n */\n\nTable csv;\n\nfloat tempMin[];\n\nvoid setup() {\n  csv = loadTable(\"data.csv\", \"header\");\n\n  println(\"Numero righe: \" + csv.getRowCount());\n  println(\"Numero colonne: \" + csv.getColumnCount());\n\n  tempMin = new float[csv.getColumnCount()];\n\n  for(int i = 1; i &lt; csv.getColumnCount(); i++) {\n    tempMin[i] = csv.getFloat(0, i);\n  }\n\n  printArray(tempMin);\n\n  noLoop();\n}\n\nvoid draw() {\n}\n</code></pre> <p>La dimensione dell'array \u00e8 uguale al numero di colonne all'interno del file <code>tempMin = new float[csv.getColumnCount()];</code> e inseriamo all'interno dell'array i valori float provenienti dalla riga 0, perch\u00e9 stiamo ignorando l'header, e di ciascuna colonna: <code>tempMin[i] = csv.getFloat(0, i);</code></p> <p>Dal risultato in console notiamo subito un problema: il primo valore dell'array \u00e8\u00a00.0 perch\u00e9, effettivamente, l'array contiene un valore in pi\u00f9, quello della colonna\u00a0Descrizione.</p> <p>Abbiamo due possibilit\u00e0 per risolvere il problema:</p> <p>Modificare la grandezza dell'array sottraendo 1: <code>tempMin = new float[csv.getColumnCount()-1];</code> e modificando l'inserimento dei valori nell'array sempre spostando l'indice indietro di 1 <code>tempMin[i-1] = csv.getFloat(0, i);</code>.</p> <p>Questa soluzione funziona ma non \u00e8 molto elegante, meglio cambiare il codice come segue: inizializziamo l'array con grandezza pari a 0: <code>tempMin = new float[0];</code> e poi utilizziamo la funzione append() che espande l'array di un elemento e aggiunge il dato nella nuova posizione <code>tempMin = append(tempMin, csv.getFloat(0, i));</code></p>","tags":["append","array","csv","dati","getfloat","getint","getstring","table"]},{"location":"data/2018-04-01-da-una-tabella-csv-agli-array/#il-codice-completo","title":"Il codice completo","text":"<pre><code>/*\n * Da una tabella CSV agli array\n * Federico Pepe, 01.04.2018\n * http://blog.federicopepe.com/processing\n */\n\nTable csv;\n\nfloat tempMin[];\n\nvoid setup() {\n  csv = loadTable(\"data.csv\", \"header\");\n\n  println(\"Numero righe: \" + csv.getRowCount());\n  println(\"Numero colonne: \" + csv.getColumnCount());\n\n  tempMin = new float[0];\n\n  for(int i = 1; i &lt; csv.getColumnCount(); i++) {\n    tempMin = append(tempMin, csv.getFloat(0, i));\n  }\n\n  printArray(tempMin);\n\n  noLoop();\n}\n\nvoid draw() {\n}\n</code></pre> <p>Ora l'array \u00e8 corretto e contiene esattamente tutti i valori previsti. Come dicevo, ora possiamo sfruttare l'array per ottenere il valore minimo e quello massimo molto semplicemente:</p> <pre><code>println(\"Il valore minimo \u00e8: \" + min(tempMin));\nprintln(\"Il valore massimo \u00e8: \" + max(tempMin));\n</code></pre>","tags":["append","array","csv","dati","getfloat","getint","getstring","table"]},{"location":"data/2018-04-22-grafico-a-barre-in-processing/","title":"Creiamo il nostro primo grafico a barre","text":"<p>Abbiamo imparato come leggere un file CSV in Processing e come cominciare a lavorare sui dati passando da una tabella a un array. Ora \u00e8 arrivato il momento di creare il nostro primo grafico a barre.</p> <p>Per fare un velocissimo recap: stiamo lavorando in Processing con un file CSV che rappresenta\u00a0le statistiche metoclimatiche degli ultimi 10 anni (2008-2017) della regione Veneto, prese dal sito del Mipaaf.</p> <p>Il file contiene diverse informazioni interessanti ma, per il momento, abbiamo creato un array in cui abbiamo salvato solo i valori delle\u00a0temperature minime:</p> <p>[0] 6.9 [1] 7.3 [2] 6.7 [3] 7.4 [4] 7.2 [5] 7.7 [6] 8.7 [7] 8.0 [8] 7.6 [9] 7.1</p> <p>Il primo valore si riferisce all'anno 2008 mentre quello inserito alla posizione [9] \u00e8 il dato del 2017.</p>","tags":["bar-graph","data","data-visualization","grafico-a-barre","infografiche","rect"]},{"location":"data/2018-04-22-grafico-a-barre-in-processing/#disegniamo-il-grafico-a-barre","title":"Disegniamo il grafico a barre","text":"<p>Disegnare un grafico a barre non \u00e8 difficile: devo creare dei rettangoli della stessa larghezza e la cui altezza sia legata al dato che voglio rappresentare.</p> <p>Creiamo una finestra di 500x500 pixel e, siccome i valori sono 10 divido, ciascun rettangolo avr\u00e0 una larghezza pari a 50 pixel.</p> <p>Utilizzo un ciclo for per leggere dall'array i singoli valori e li assegno direttamente all'altezza dei rettangoli</p> <pre><code>/*\n * Creiamo il nostro primo grafico a barre\n * Federico Pepe, 22.04.2018\n * http://blog.federicopepe.com/processing\n */\n\nTable csv;\n\nfloat tempMin[];\n\nvoid setup() {\n  // Dimensione della finestra\n  size(500, 500);\n\n  csv = loadTable(\"data.csv\", \"header\");\n\n  println(\"Numero righe: \" + csv.getRowCount());\n  println(\"Numero colonne: \" + csv.getColumnCount());\n\n  // Creazione dell'array\n  tempMin = new float[0];\n  // Inserimento dei dati nell'array\n  for(int i = 1; i &lt; csv.getColumnCount(); i++) {\n    tempMin = append(tempMin, csv.getFloat(0, i));\n  }\n  printArray(tempMin);\n  // Disegno il grafico\n  for(int j = 0; j &lt; tempMin.length; j++) {\n    rect(j * 50, 0, 50, tempMin[j]);\n  }\n\n  noLoop();\n}\n\nvoid draw() {\n}\n</code></pre> <p>La riga di codice pi\u00f9 importante \u00e8:\u00a0<code>rect(j * 50, 0, 50, tempMin[j]);</code>. Ricordo che la funzione rect() accetta quattro parametri: posizione x, posizione y, larghezza e altezza del rettangolo. Il codice, quindi, dovrebbe essere chiaro e non dovrebbe necessitare di ulteriori spiegazioni.</p> <p></p> <p>Il risultato, come possiamo vedere nell'immagine, non \u00e8, per\u00f2, molto soddisfacente: i grafici a barre generalmente vengono disegnati dal basso verso l'alto e, in questo caso, il valore dell'altezza dei rettangoli \u00e8 troppo basso per essere comprensibile.</p> <p>\u00c8 sufficiente modificare una sola riga di codice:</p> <p><code>rect(j * 50, height, 50, tempMin[j] * - 20);</code></p> <p>per ottenere un risultato completamente differente:</p> <p></p> <p>Aggiungiamo un po' di margine dai bordi della finestra e tra le varie barre del nostro grafico:</p> <pre><code>// Disegno il grafico\n  int x = 50;\n  for(int j = 0; j &lt; tempMin.length; j++) {\n    rect(x, height - 50, 36, tempMin[j] * - 20);\n    x += 40;\n  }\n</code></pre> <p>e un po' di colore <code>fill(100, 190, 255);</code></p> <p></p> <p>Ecco il codice completo:</p> <pre><code>/*\n * Creiamo il nostro primo grafico a barre\n * Federico Pepe, 22.04.2018\n * http://blog.federicopepe.com/processing\n */\n\nTable csv;\n\nfloat tempMin[];\n\nvoid setup() {\n  // Dimensione della finestra\n  size(500, 500);\n  background(255);\n  csv = loadTable(\"data.csv\", \"header\");\n\n  println(\"Numero righe: \" + csv.getRowCount());\n  println(\"Numero colonne: \" + csv.getColumnCount());\n\n  // Creazione dell'array\n  tempMin = new float[0];\n  // Inserimento dei dati nell'array\n  for(int i = 1; i &lt; csv.getColumnCount(); i++) {\n    tempMin = append(tempMin, csv.getFloat(0, i));\n  }\n  printArray(tempMin);\n  // Disegno il grafico\n  int x = 50;\n  fill(100, 190, 255);\n  for(int j = 0; j &lt; tempMin.length; j++) {\n    rect(x, height - 50, 36, tempMin[j] * - 20);\n    x += 40;\n  }\n\n  noLoop();\n}\n\nvoid draw() {\n}\n</code></pre> <p>Per il momento possiamo fermarci qui. Per chi volesse spingersi un po' oltre, un buon esercizio potrebbe essere, partendo dal codice qui sopra, aggiungere al grafico anche le temperature massime con dei rettangoli colorati di rosso.</p>","tags":["bar-graph","data","data-visualization","grafico-a-barre","infografiche","rect"]},{"location":"data/2018-04-29-grafico-a-barre-2/","title":"Grafico a barre II","text":"<p>Nell'articolo precedente abbiamo cominciato a lavorare al nostro primo grafico a barre utilizzando come fonte i dati presenti all'interno di un file CSV.</p> <p>In questo articolo andremo a completare la visualizzazione inserendo anche le temperature massime e dei riferimenti.</p>","tags":["data-visualization","grafico-a-barre","processing","visualizzazione-di-dati"]},{"location":"data/2018-04-29-grafico-a-barre-2/#array-delle-temperature-massime","title":"Array delle temperature massime","text":"<p>I dati relativi alle temperature massime sono gi\u00e0 presenti dentro al file CSV. Come abbiamo gi\u00e0 visto, per comodit\u00e0 inseriamo questi dati in un array.</p> <p>Dove abbiamo dichiarato le variabili, aggiungiamo:</p> <pre><code>float tempMin[], tempMax[];\n</code></pre> <p>Inizializziamo l'array:</p> <pre><code>tempMax = new float[0];\n</code></pre> <p>Inseriamo i dati utilizzando lo stesso ciclo for per non appesantire troppo il programma</p> <pre><code>for (int i = 1; i &lt; csv.getColumnCount(); i++) {\n  tempMin = append(tempMin, csv.getFloat(0, i));\n  tempMax = append(tempMax, csv.getFloat(3, i));\n}\n</code></pre>","tags":["data-visualization","grafico-a-barre","processing","visualizzazione-di-dati"]},{"location":"data/2018-04-29-grafico-a-barre-2/#grafico-a-barre-delle-temperature-massime","title":"Grafico a barre delle temperature massime","text":"<p>Utilizzando sempre il codice che abbiamo gi\u00e0 scritto, aggiungiamo nel ciclo for in cui andavamo a disegnare i rettangoli delle temperature minime, quelli relativi alle massime. Per differenziarle a livello visivo utilizzeremo il colore rosso.</p> <pre><code>fill(255, 100, 100);\nrect(x, height - 50, 36, tempMax[i] * - 20);\n</code></pre> <p>Siccome i rettangoli rossi saranno pi\u00f9 alti rispetto a quelli azzurri, assicuriamoci di disegnarli per primi.</p> <p>Nel mio codice ho aggiunto anche un <code>noStroke()</code> per eliminare il bordo.</p> <p></p>","tags":["data-visualization","grafico-a-barre","processing","visualizzazione-di-dati"]},{"location":"data/2018-04-29-grafico-a-barre-2/#aggiungiamo-dei-riferimenti","title":"Aggiungiamo dei riferimenti","text":"<p>Quando si creano delle visualizzazioni di dati pu\u00f2 essere utile dare dei riferimenti a chi sta osservando il nostro lavoro per aiutarli nella comprensione. L'immagine qui sopra presa singolarmente potrebbe rappresentare migliaia di cose differenti.</p> <p>Aggiungere delle linee di riferimento \u00e8 questione di un semplice ciclo for:</p> <pre><code>for (int j = 0; j &lt;= 20; j++) {\n  stroke(0, 30);\n  line(30, height - 50 + (j * - 20), 470, height - 50 + (j * - 20));\n}\n</code></pre> <p></p> <p>Ora non ci resta che aggiungere il testo (aggiungiamo un paio di linee di codice al precedente ciclo for):</p> <pre><code>textAlign(RIGHT, CENTER);\nfor (int j = 0; j &lt;= 20; j++) {\n  fill(0, 127);\n  text(j + \"\u00b0\", 25, height - 52 + (j * - 20));\n  stroke(0, 30);\n  line(30, height - 50 + (j * - 20), 470, height - 50 + (j * - 20));\n}\n</code></pre> <p></p> <p>Per rendere il grafico pi\u00f9 leggibile facciamo dei piccoli miglioramenti: scriviamo il valore numerico ogni cinque gradi e schiariamo leggermente le altre linee:</p> <pre><code>textAlign(RIGHT, CENTER);\n\nfor (int j = 0; j &lt;= 20; j++) {\n  if (j % 5 == 0) {\n    fill(0, 127);\n    text(j + \"\u00b0\", 25, height - 52 + (j * - 20));\n    stroke(0, 30);\n  } else {\n    stroke(0, 15);\n  }\n  line(30, height - 50 + (j * - 20), 470, height - 50 + (j * - 20));\n}\n</code></pre> <p></p> <p>Non ci resta che aggiungere l'anno di riferimento in fondo al grafico: avendo aggiunto l'opzione header nella lettura del file CSV viene saltata completamente la prima riga che include proprio questo dato. Potremmo riscrivere il codice ma, per questa volta, adotteremo una soluzione pi\u00f9 semplice anche se non proprio elegante. Per completezza includo tutto il codice del programma:</p> <pre><code>/*\n * Grafico a barre, 2\n * Federico Pepe, 29.04.2018\n * http://blog.federicopepe.com/processing\n */\n\nTable csv;\n\nfloat tempMin[], tempMax[];\n\nvoid setup() {\n  size(500, 500);\n  background(255);\n  noStroke();\n  csv = loadTable(\"data.csv\", \"header\");\n\n  println(\"Numero righe: \" + csv.getRowCount());\n  println(\"Numero colonne: \" + csv.getColumnCount());\n\n  tempMin = new float[0];\n  tempMax = new float[0];\n\n  for (int i = 1; i &lt; csv.getColumnCount(); i++) {\n    tempMin = append(tempMin, csv.getFloat(0, i));\n    tempMax = append(tempMax, csv.getFloat(3, i));\n  }\n\n  printArray(tempMin);\n\n  println(\"Il valore minimo \u00e8: \" + min(tempMin));\n  println(\"Il valore massimo \u00e8: \" + max(tempMin));\n\n  noLoop();\n\n  int x = 50;\n  int year = 2008;\n\n  for (int i = 0; i &lt; tempMin.length; i++) {\n    fill(255, 100, 100);\n    rect(x, height - 50, 36, tempMax[i] * - 20);\n    fill(100, 190, 255);\n    rect(x, height - 50, 36, tempMin[i] * - 20);\n    fill(0, 127);\n    text(year, x + 2, height - 30);\n    x += 40;\n    year++;\n  }\n\n  textAlign(RIGHT, CENTER);\n\n  for (int j = 0; j &lt;= 20; j++) {\n    if (j % 5 == 0) {\n      fill(0, 127);\n      text(j + \"\u00b0\", 25, height - 52 + (j * - 20));\n      stroke(0, 30);\n    } else {\n      stroke(0, 15);\n    }\n    line(30, height - 50 + (j * - 20), 470, height - 50 + (j * - 20));\n  }\n}\n\nvoid draw() {\n}\n</code></pre> <p></p>","tags":["data-visualization","grafico-a-barre","processing","visualizzazione-di-dati"]},{"location":"data/2018-05-20-grafico-a-linee/","title":"Grafico a linee","text":"<p>Partiamo sempre dall'esempio su cui stiamo lavorando da un po' di tempo a questa parte e creiamo un grafico a linee in Processing.</p> <p>L'unica modifica al codice che dobbiamo fare \u00e8 quella relativa alla grafica: lasciamo, dunque, inalterata la prima parte, quella relativa alla lettura dei dati dal file .csv e l'inserimento degli stessi in un array e passiamo direttamente alla grafica.</p>","tags":["beginshape","data-visualization","endshape","grafico-a-linee","infografiche","vertex"]},{"location":"data/2018-05-20-grafico-a-linee/#ripensare-la-posizione-della-x","title":"Ripensare la posizione della x","text":"<p>La prima differenza rispetto al grafico a barre\u00a0sar\u00e0 determinare correttamente la posizione x del valore estratto dall'array. Se, infatti, il ciascuna barra del grafico aveva una sua larghezza, ora dobbiamo rappresentare solo un punto.</p> <p>Per risolvere il problema, pur mantenendo il risultato finale che avevamo realizzato nell'ultimo post, creo una nuova variabile chiamata x1 che mi servir\u00e0 come nuovo riferimento e aggiungo un nuovo ciclo for solo per disegnare i punti di riferimento nel grafico.</p> <pre><code>int x1 = 68;\n\nfor(int i = 0; i &lt; tempMin.length; i++) {\n  ellipse(x1, height - 50 + tempMin[i] * - 20, 10, 10);\n  ellipse(x1, height - 50 + tempMax[i] * - 20, 10, 10);\n  x1 += 40;\n}\n</code></pre> <p>Ecco il risultato:</p> <p></p>","tags":["beginshape","data-visualization","endshape","grafico-a-linee","infografiche","vertex"]},{"location":"data/2018-05-20-grafico-a-linee/#creiamo-il-grafico-a-linee","title":"Creiamo il grafico a linee","text":"<p>Creare un grafico a linee potrebbe essere pi\u00f9 complesso di quanto ipotizzato: dovremmo, infatti, creare manualmente una linea per congiungere tra loro i punti disegnati in precedenza.</p> <p>Per fortuna ci vengono in aiuto alcune funzione di Processing:\u00a0beginShape(),\u00a0vertex() ed\u00a0endShape().</p> <p>Con beginShape() diciamo al programma di iniziare a creare una forma, aggiungiamo tutti i vertici che la compongono con vertex()\u00a0e, una volta richiamata la funzione endShape(), Processing si preoccuper\u00e0 di collegare insieme tutti i punti.</p> <p>Come al solito, consiglio di verificare sul\u00a0reference i parametri opzionali che possiamo usare per ciascuna funzione. Per questo esempio il comportamento di default \u00e8 quello che fa al caso nostro ma in futuro potrebbero tornarvi utili anche le altre possibilit\u00e0.</p> <p>Dovendo creare due grafici a barre, dovremo utilizzare due cicli for:</p> <pre><code>int x1 = 68;\n\nbeginShape();\nfor (int i = 0; i &lt; tempMin.length; i++) {\n  vertex(x1, height - 50 + tempMin[i] * - 20);\n  ellipse(x1, height - 50 + tempMin[i] * - 20, 10, 10);\n  x1 += 40;\n}\nendShape();\n\nx1 = 68;\nbeginShape();\nfor (int i = 0; i &lt; tempMax.length; i++) {\n  vertex(x1, height - 50 + tempMax[i] * - 20);\n  ellipse(x1, height - 50 + tempMax[i] * - 20, 10, 10);\n  x1 += 40;\n}\nendShape();\n</code></pre> <p></p> <p>A questo punto possiamo eliminare i grafici a barre che avevamo tenuto come riferimento e andare a sistemare i colori per ottenere un risultato finale soddisfacente:</p> <p></p>","tags":["beginshape","data-visualization","endshape","grafico-a-linee","infografiche","vertex"]},{"location":"data/2018-05-20-grafico-a-linee/#codice-completo","title":"Codice completo","text":"<p>Guardando il codice vi sembrer\u00e0 un po' verboso, in particolare per quanto riguarda le assegnazioni dei colori. Facendo qualche esperimento vi renderete conto di quanto sia importante inserire le istruzioni giuste per evitare problemi di visualizzazione.</p> <pre><code>/*\n * Grafico a linee\n * Federico Pepe, 20.05.2018\n * http://blog.federicopepe.com/processing\n */\n\nTable csv;\n\nfloat tempMin[], tempMax[];\n\nvoid setup() {\n  size(500, 500);\n  background(255);\n  noStroke();\n  csv = loadTable(\"data.csv\", \"header\");\n\n  println(\"Numero righe: \" + csv.getRowCount());\n  println(\"Numero colonne: \" + csv.getColumnCount());\n\n  tempMin = new float[0];\n  tempMax = new float[0];\n\n  for (int i = 1; i &lt; csv.getColumnCount(); i++) {\n    tempMin = append(tempMin, csv.getFloat(0, i));\n    tempMax = append(tempMax, csv.getFloat(3, i));\n  }\n\n  printArray(tempMin);\n\n  println(\"Il valore minimo \u00e8: \" + min(tempMin));\n  println(\"Il valore massimo \u00e8: \" + max(tempMin));\n\n  noLoop();\n\n  // Scritte relative all'anno\n  int x = 50;\n  int year = 2008;\n\n  for (int i = 0; i &lt; tempMin.length; i++) {\n    fill(0, 127);\n    text(year, x + 2, height - 30);\n    x += 40;\n    year++;\n  }\n\n  // Temperature minime\n  int x1 = 68;\n  beginShape();\n  for (int i = 0; i &lt; tempMin.length; i++) {\n    fill(100, 190, 255);\n    vertex(x1, height - 50 + tempMin[i] * - 20);\n    noStroke();\n    ellipse(x1, height - 50 + tempMin[i] * - 20, 10, 10);\n    x1 += 40;\n    stroke(100, 190, 255);\n    noFill();\n  }\n  endShape();\n\n  // Temperature massime\n  x1 = 68;\n  beginShape();\n  for (int i = 0; i &lt; tempMax.length; i++) {\n    fill(255, 100, 100);\n    vertex(x1, height - 50 + tempMax[i] * - 20);\n    noStroke();\n    ellipse(x1, height - 50 + tempMax[i] * - 20, 10, 10);\n    x1 += 40;\n    stroke(255, 100, 100);\n    noFill();\n  }\n  endShape();\n\n  // Griglia di riferimento\n  textAlign(RIGHT, CENTER);\n  for (int j = 0; j &lt;= 20; j++) {\n    if (j % 5 == 0) {\n      fill(0, 127);\n      text(j + \"\u00b0\", 25, height - 52 + (j * - 20));\n      stroke(0, 30);\n    } else {\n      stroke(0, 15);\n    }\n    line(30, height - 50 + (j * - 20), 470, height - 50 + (j * - 20));\n  }\n}\n\nvoid draw() {\n}\n</code></pre>","tags":["beginshape","data-visualization","endshape","grafico-a-linee","infografiche","vertex"]},{"location":"data/2019-06-23-universita-cmti-2018-2019/","title":"Alcuni lavori dei miei studenti del corso CMTI dell'Universit\u00e0 di Udine","text":"<p>Due anni fa ho iniziato a lavorare come docente a contratto per il corso di Laurea Magistrale in Comunicazione Multimediale e Tecnologie dell'Informazione (CMTI) dell'Universit\u00e0 degli Studi di Udine.</p> <p>La materia che insegno si chiama Linguaggi Visuali per Sistemi Complessi e, all'interno del percorso, offre un punto di contatto tra l'anima informatica (Virtual Reality, Machine Learning, Cybersecurity ecc...) e tra il mondo del design (Design dello Spazio, Interaction Design, ecc...).</p> <p>In questo post ho deciso di condividere \u2013 con il loro permesso \u2013 alcuni dei lavori presentati al primo appello d'esame da alcuni studenti e studentesse del corso.</p> <p>La scelta del tema era libera e ciascuno/a ha sviluppato in completa autonomia sia il lavoro di ricerca che di visualizzazione.</p>","tags":["data-visualization","infografiche","processing","universita-degli-studi-di-udine"]},{"location":"data/2019-06-23-universita-cmti-2018-2019/#premessa-il-background-e-i-contenuti-del-corso","title":"Premessa: il background e i contenuti del corso","text":"<p>Il background di chi frequenta il corso \u00e8 molto vario ma, in generale, chi ha competenze in ambito informatico non ha mai lavorato prima con la grafica e viceversa.</p> <p>Nel percorso didattico che ho sviluppato e che sto perfezionando di anno in anno, cerco di portare tutti ad acquisire delle competenze in entrambi questi ambiti attraverso lo studio della programmazione in Processing e con analisi ed esercitazioni in classe di data visualisation.</p>","tags":["data-visualization","infografiche","processing","universita-degli-studi-di-udine"]},{"location":"data/2019-06-23-universita-cmti-2018-2019/#loccupazione-dei-neo-laureati","title":"L'occupazione dei neo-laureati","text":"<p>Partendo dai dati di Almalaurea, Michelangelo ha deciso di fare una visualizzazione interattiva e animata sulle percentuali di neo-laureati che trovano lavoro dopo un anno dal conseguimento del titolo.</p> <p></p> <p>Data Visualisation di Michelangelo Campanella, fonte dati: Almalaurea</p>","tags":["data-visualization","infografiche","processing","universita-degli-studi-di-udine"]},{"location":"data/2019-06-23-universita-cmti-2018-2019/#i-colori-di-un-film","title":"I colori di un film","text":"<p>Kristian si \u00e8 concentrato sull'analisi dei colori dei suoi film preferiti (Apocalypse Now, Blade Runner, Mad Max, ecc...). Nel realizzare questo progetto ha incontrato due difficolt\u00e0:</p> <ul> <li>estrarre i dati analizzando i film frame per frame</li> <li>creare una visualizzazione unica che permettesse l'interpretazione dei dati raccolti.</li> </ul> <p></p> <p>Un'analisi approfondita sull'utilizzo del colore nel cinema di Kristian Simonato</p> <p>Anche in questo caso, trattandosi di una visualizzazione interattiva, lo screenshot che ho condiviso non rende giustizia al lavoro svolto. Partendo da questo studio sull'utilizzo dei colori nel cinema, il primo grafico (in alto) mostra quanto ciascun frame tende a uno dei sette colori principali analizzati nello studio.</p> <p>Nella parte centrale \u00e8 possibile vedere il colore predominante in ciascun frame, vedere il frame di riferimento nel film un'analisi pi\u00f9 approfondita con le percentuali di ciascun colore.</p> <p>Il grafico 3D sulla sinistra, che si pu\u00f2 ruotate, presenta un'analisi completa e numerica delle componenti colore dell'intero film.</p>","tags":["data-visualization","infografiche","processing","universita-degli-studi-di-udine"]},{"location":"data/2019-06-23-universita-cmti-2018-2019/#mappare-le-nascite-del-friuli-venezia-giulia","title":"Mappare le nascite del Friuli Venezia Giulia","text":"<p>Una mappa interattiva per mappare le nascite nel Friuli Venezia Giulia di Michele Dal Zotto, fonte dati: ISTAT</p> <p>Prendendo i dati dell'ISTAT, Michele ha visualizzato su una mappa interattiva le nascite dal 2013 al 2017 nella sua regione, il Friuli Venezia Giulia.</p> <p>\u00c8 possibile interagire con la mappa cliccando sui comuni per vedere il dettaglio oppure selezionando il dato generale o quello di maschi/femmine.</p>","tags":["data-visualization","infografiche","processing","universita-degli-studi-di-udine"]},{"location":"data/2019-06-23-universita-cmti-2018-2019/#featuring-tra-rapper-e-artisti-italiani","title":"Featuring tra rapper e artisti italiani","text":"<p>Sfruttando i dati presi dall'API di Spotify, Niccol\u00f2 \u00e8 andato ad analizzare alcuni dei suoi musicisti/cantanti preferiti e le loro collaborazioni.</p> <p>Ne nasce un grafico interattivo dove ciascun artista \u00e8 rappresentato da un cerchio, il cui colore varia in base al genere musicale di riferimento (scelto in modo arbitrario). I featuring tra gli artisti sono rappresentati dalle linee di collegamento: pi\u00f9 \u00e8 spessa la linea, maggiori sono le collaborazioni tra i due artisti.</p> <p></p> <p></p> <p>Cliccando su un artista (immagine sopra) si pu\u00f2 entrare nel dettaglio mentre, cliccando sui nodi (immagine sotto) che rappresentano le collaborazioni \u00e8 possibile visualizzare dei dati aggiuntivi sui brani.</p> <p>Nella versione animata, le barre verdi si muovono come fossero animate dall'audio del brano.</p> <p></p>","tags":["data-visualization","infografiche","processing","universita-degli-studi-di-udine"]},{"location":"data/2019-06-23-universita-cmti-2018-2019/#la-diffusione-delle-microplastiche-nellacqua","title":"La diffusione delle microplastiche nell'acqua","text":"<p>Il lavoro di Tania e Silvia si pu\u00f2 vedere on-line. Hanno deciso di concentrare la loro attenzione su un tema molto attuale: la diffusione delle microplastiche nelle acque.</p> <p></p> <p>Microplastic: il lavoro di Tania Scorpio e Silvia Gioia Florio. In questa immagine un mock-up di una locandina per un'esibizione.</p> <p>Cliccando sul menu a destra \u00e8 possibile visualizzare informazioni diverse sulla mappa. La cosa interessante \u00e8 che i dati raccolti provengono dal database di Adventure Scientists, un gruppo volontari che raccolgono dati in giro per il mondo per aiutare gli scienziati.</p> <p></p> <p>Fonte dati: Adventure Scientists</p> <p>L'area dell'Oceano Atlantico che salta subito all'occhio non \u00e8 pi\u00f9 inquinata delle altre, semplicemente in quella fascia sono stati raccolti moltissimi campioni durante una competizione nautica.</p> <p>Interessante anche il grafico forecast che vuole azzardare una previsione di quanto saranno inquinati gli oceani da qui al 2050 se non dovessimo cambiare immediatamente il nostro modo di produrre microplastiche.</p> <p></p>","tags":["data-visualization","infografiche","processing","universita-degli-studi-di-udine"]},{"location":"data/2019-06-23-universita-cmti-2018-2019/#analisi-di-una-relazione-su-telegram","title":"Analisi di una relazione su Telegram","text":"<p>Sicuramente ispirato dal progetto che ho mostrato in classe Call me Adele, Francesco ha deciso di analizzare i dati generati dalla chat di Telegram con la sua fidanzata (pi\u00f9 di 80 mila messaggi).</p> <p>I risultati sono molto interessanti e credo che le immagini parlino da sole; anche in questo caso l'applicazione originale \u00e8 interattiva e permette di navigare facilmente tra le varie schermate e di scendere nel dettaglio quando necessario.</p> <p></p> <p></p> <p></p> <p></p>","tags":["data-visualization","infografiche","processing","universita-degli-studi-di-udine"]},{"location":"data/2019-07-24-universita-cmti-2018-2019-2/","title":"Alcuni lavori dei miei studenti del corso CMTI dell'universit\u00e0 di Udine #2","text":"<p>Il primo articolo con la spiegazione e un po' di background in merito al corso e ai lavori di data visualization dei miei studenti lo trovate qui.</p> <p>In questo post pubblico, con il loro permesso, le infografiche realizzate dagli studenti che hanno sostenuto l'esame al secondo appello.</p>","tags":["data-visualization","infografiche","processing","universita-degli-studi-di-udine"]},{"location":"data/2019-07-24-universita-cmti-2018-2019-2/#passione-film-con-i-dati-di-imdb","title":"Passione film con i dati di IMDB","text":"<p>Il primo lavoro \u00e8 di Omar Frasson, appassionato di cinema, che grazie ai dati raccolti su IMDB ha sviluppato una visualizzazione piuttosto articolata.</p> <p></p> <p>La prima schermata, che funge da splash screen, \u00e8 gi\u00e0, di per s\u00e9, una visualizzazione: i nomi dei registi dei film appaiono, infatti, a grandezza differente in base al numero di lungometraggi visti. La posizione sullo schermo, invece, \u00e8 casuale.</p> <p></p> <p>Nella prima schermata, tutti i film vengono ordinati sull'asse delle x per anno di uscita. Sull'asse delle y, invece, la durata del film e, attraverso il colore, \u00e8 possibile vedere il voto assegnato.</p> <p>Passando con il mouse sopra a ciascun rettangolo compaiono alcuni dati sul film.</p> <p></p> <p>La visualizzazione per generi con animazione controllata dallo slider in alto con riferimento sempre l'anno di uscita del film. Sulla destra, invece, alcuni eventi rilevanti della storia del cinema.</p> <p></p> <p>Terza schermata: visualizzazione per registi con comparazione tra la votazione assegnata dallo studente e quella media generale di tutti gli utenti di IMDB.</p> <p></p> <p>Schermata che rappresenta dei dati relativamente alla durata dei film e alle valutazioni assegnate.</p> <p></p> <p>E, infine, una comparazione tra tutti i film visti da Omar nel 2017 e nel 2018.</p>","tags":["data-visualization","infografiche","processing","universita-degli-studi-di-udine"]},{"location":"data/2019-07-24-universita-cmti-2018-2019-2/#tutto-sugli-avengers","title":"Tutto sugli Avengers","text":"<p>Rimaniamo in ambito cinematografico con il lavoro di Giulia Nard\u00f2 che ha deciso di creare una data visualization sulla serie degli Avengers. I dati sono stati raccolti da varie fonti (Wikipedia, IMDB, ecc...) e assemblati in un file excel.</p> <p></p> <p></p> <p>Una prima schermata mostra l'universo degli Avengers con tutti i personaggi (cerchio esterno) e film (cerchi interni). Muovendosi con il mouse \u00e8 possibile vedere quali personaggi erano presenti nei film. La legenda sulla sinistra aiuta molto a capire le varie relazioni e la scelta dei colori.</p> <p></p> <p>Dettaglio sul personaggio Iron Man</p> <p></p> <p>Dettaglio sul personaggio Ronan the accuser</p> <p>Cliccando sui personaggi o sul film \u00e8 possibile avere ulteriori dettagli</p> <p></p> <p>Dettaglio su: Avengers: Endgame.</p>","tags":["data-visualization","infografiche","processing","universita-degli-studi-di-udine"]},{"location":"data/2019-07-24-universita-cmti-2018-2019-2/#visualizzare-i-dati-raccolti-con-lapp-salute-su-ios","title":"Visualizzare i dati raccolti con l'App Salute su iOS","text":"<p>Il progetto di Erika Corallo, invece, si \u00e8 concentrato sulla visualizzazione dei dati raccolti con l'App Salute su iOS: battito cardiaco, distanze percorse e passi.</p> <p>L'approccio \u00e8 stato piuttosto semplice nel disegnare i grafici ma la parte, a mio modo di vedere, pi\u00f9 interessante, sono le schermate iniziali che sono animate e gi\u00e0 rappresentano i dati in modo molto creativo.</p> <p></p> <p></p> <p></p> <p>Per ciascun dato esiste, poi una vista dettagliata suddivisa per mese oppure generale per anno.</p> <ul> <li> <p></p> </li> <li> <p></p> </li> <li> <p></p> </li> </ul>","tags":["data-visualization","infografiche","processing","universita-degli-studi-di-udine"]},{"location":"data/2019-07-24-universita-cmti-2018-2019-2/#clash-of-clans","title":"Clash of Clans","text":"<p>Williams Piazza ha utilizzato i dati presi dall'API del gioco Clash of Clans per valutare il rendimento di ciascun giocatore del suo clan per capire come migliorare le prestazioni di gioco.</p> <ul> <li> <p></p> </li> <li> <p></p> </li> <li> <p></p> </li> </ul>","tags":["data-visualization","infografiche","processing","universita-degli-studi-di-udine"]},{"location":"data/2019-08-15-il-problema-dei-grafici-a-linee-curve/","title":"Il problema dei grafici a linee curve","text":"<p>Dopo aver realizzato il nostro grafico a linee, potremmo pensare di utilizzare delle linee curve. Ma, come vedremo in questo articolo, ci troveremo ad affrontare una serie di problemi.</p>","tags":["beziervertex","curvevertex","data-visualization","grafico-a-linee","infografiche"]},{"location":"data/2019-08-15-il-problema-dei-grafici-a-linee-curve/#dalle-linee-dritte-a-linee-curve","title":"Dalle linee dritte a linee curve","text":"<p>Ripartendo dal codice nell'articolo precedente e cambiato le seguenti righe:</p> <pre><code>vertex(x1, height - 50 + tempMin[i] * - 20);\n</code></pre> <pre><code>vertex(x1, height - 50 + tempMax[i] * - 20);\n</code></pre> <p>utilizzando curveVertex() al posto di vertex() otteniamo questo risultato:</p> <p></p> <p>Notiamo subito che mancano dei collegamenti con il primo e l'ultimo punto della serie di dati. Come indicato nel reference, questa funzione utilizza il primo e l'ultimo punto vengono usati per guidare la curvatura della linea.</p> <p>A questo punto dobbiamo arbitrariamente aggiungere due punti e, in questo caso, conviene farlo prima e dopo il ciclo for. Qui sorge il secondo problema: che coordinate diamo a questi due punti che non derivano dal nostro dataset?</p> <p>La soluzione pi\u00f9 ovvia \u00e8 utilizzare le coordinate del primo e dell'ultimo punto:</p> <pre><code>// Temperature minime\n  int x1 = 68;\n  beginShape();\n  curveVertex(x1, height - 50 + tempMin[0] * - 20); \n  for (int i = 0; i &lt; tempMin.length; i++) {\n    fill(100, 190, 255);\n    curveVertex(x1, height - 50 + tempMin[i] * - 20);\n    noStroke();\n    ellipse(x1, height - 50 + tempMin[i] * - 20, 10, 10);\n    x1 += 40;\n    stroke(100, 190, 255);\n    noFill();\n  }\n  curveVertex(x1, height - 50 + tempMin[tempMin.length - 1] * - 20); \n  endShape();\n\n  // Temperature massime\n  x1 = 68;\n  beginShape();\n  curveVertex(x1, height - 50 + tempMax[0] * - 20); \n  for (int i = 0; i &lt; tempMax.length; i++) {\n    fill(255, 100, 100);\n    curveVertex(x1, height - 50 + tempMax[i] * - 20);\n    noStroke();\n    ellipse(x1, height - 50 + tempMax[i] * - 20, 10, 10);\n    x1 += 40;\n    stroke(255, 100, 100);\n    noFill();\n  }\n  curveVertex(x1, height - 50 + tempMax[tempMax.length - 1] * - 20); \n  endShape();\n</code></pre> <p>Se lanciamo il programma, il nostro grafico a linee curve diventa cos\u00ec:</p> <p></p> <p>Il risultato potrebbe sembrare soddisfacente ma un occhio esperto si potrebbe accorgere di un altro problema: la curvatura delle linee intorno ai punti dei dati pu\u00f2 confonderci e portarci in errore quando leggiamo il grafico.</p>","tags":["beziervertex","curvevertex","data-visualization","grafico-a-linee","infografiche"]},{"location":"data/2019-08-15-il-problema-dei-grafici-a-linee-curve/#lerrore-di-precisione","title":"L'errore di precisione","text":"<p>Questo set di dati ha dei data point molto vicini tra loro e, quindi, il fenomeno non si vede chiaramente.</p> <p>Ho realizzato quest'altra immagine per mostrarlo meglio: questa volta i punti sono inseriti in un array in modo casuale ma il principio \u00e8 lo stesso di quello utilizzato nello sketch che stiamo realizzando.</p> <p></p> <p>\u00c8 evidente l'errore che esiste tra i primi due punti e gli ultimi due: la linea curva va oltre i valori in modo anomalo e portando a un'interpretazione errata del grafico.</p> <p>Come trovare la soluzione definita al nostro problema? Abbiamo due possibilit\u00e0:</p> <ol> <li>Rinunciare alle linee curve una volta per tutte</li> <li>Non usare la funzione curveVertex() ma usare le curve di B\u00e9zier e, quindi, la funzione bezierVertex().</li> </ol> <p>La difficolt\u00e0 dell'usare queste curve \u00e8 di dover passare alla funzione tre coordinate x e y: due per i punti di controllo e una per il punto di ancoraggio. Se volete capire come funzionano, consiglio di provare a giocare al The B\u00e9zier Game (io ho rinunciato dopo poco).</p>","tags":["beziervertex","curvevertex","data-visualization","grafico-a-linee","infografiche"]},{"location":"data/2020-05-31-creare-delle-palette-di-colori-in-modo-casuale/","title":"Creare delle palette di colori che stanno bene insieme in modo casuale","text":"<p>Un paio di giorni fa su Twitter ho seguito un piccolo thread partito da Vegard Myklebust che spiegava come creare delle palette di colori che funzionano bene insieme in modo del tutto casuale.</p> <p>Il sistema \u00e8 davvero semplice e, dopo aver fatto qualche esperimento, posso dire che funziona ottimamente. Ho pensato che potesse valere la pena di realizzare un piccolo programma in Processing per generare palette di colori al bisogno.</p> <p>https://twitter.com/usefulslug/status/1265604318016811011</p> <p>Il thread originale su Twitter</p>","tags":["colormode","hsb","palette","processing"]},{"location":"data/2020-05-31-creare-delle-palette-di-colori-in-modo-casuale/#regole-per-creare-una-palette","title":"Regole per creare una palette","text":"<p>Queste sono le regole da seguire per creare la palette di colori:</p> <ol> <li>Non lavorare in uno spazio colore RGB (red, green and blue), meno intuitivo per le persone, ma in HSB (hue, saturation and brightness).</li> <li>La chiave di tutto sta nel valore di hue, ovvero la scelta del colore. Se consideriamo i valori possibili di hue su una circonferenza i suoi valori andranno da 0 a 360.      Scegliamone un valore in modo del tutto casuale.</li> <li>Scegliere in modo del tutto casuale anche i valori di saturation e brightness.</li> <li>Ora abbiamo ottenuto il nostro primo colore, quello posizionato al centro della palette.</li> <li>Scegliamo un altro valore numerico in modo del tutto casuale. Il sistema funziona al meglio se questo nuovo valore \u00e8 compreso tra 0 e 180. Sommiamo e sottraiamo questo valore al valore di hue scelto precedentemente.</li> <li>In questo modo abbiamo ottenuto i due colori da posizionare accanto a quello centrale.</li> <li>Ripetiamo l'operazione al punto 5 sommando e sottraendo nuovamente il valore scelto in quel punto a entrambi i colori ottenuti precedentemente.</li> <li>Per ottenere i risultati migliori, assegnare in modo casuale saturation e brightness a tutti i colori.</li> </ol>","tags":["colormode","hsb","palette","processing"]},{"location":"data/2020-05-31-creare-delle-palette-di-colori-in-modo-casuale/#il-programma-in-processing","title":"Il programma in Processing","text":"<pre><code>/*\n * Create a palette of 5 random colours with a techniques explained\n * here https://twitter.com/usefulslug/status/1265604318016811011\n *\n * Sketch made by Federico Pepe\n * http://www.federicopepe.com\n * 27.05.2020\n *\n*/\n\ncolor palette[] = new color[5];\n\nvoid setup() {\n  size(540, 540);\n\n  colorMode(HSB, 360, 100, 100);\n\n  noStroke();\n\n  createPalette();\n  drawPalette();\n}\n\nvoid draw() {\n}\n\nvoid mousePressed() {\n  background(0);\n  createPalette();\n  drawPalette();\n}\n\nvoid keyPressed() {\n  if(key == 's') {\n    saveFrame(\"######-palette.png\");\n  }\n}\n\nvoid createPalette() {\n  int hue = round(random(360));\n  int r1  = round(random(180));\n  palette[0] = color(hue - (r1*2), round(random(100)), round(random(100)));\n  palette[1] = color(hue - r1, round(random(100)), round(random(100)));\n  palette[2] = color(hue, round(random(100)), round(random(100)));\n  palette[3] = color(hue + r1, round(random(100)), round(random(100)));\n  palette[4] = color(hue + (r1*2), round(random(100)), round(random(100)));\n\n  println(\"#\" + hex(palette[0], 6), \n    \"#\" + hex(palette[1], 6), \n    \"#\" + hex(palette[2], 6), \n    \"#\" + hex(palette[3], 6), \n    \"#\" + hex(palette[4], 6));\n\n}\n\nvoid drawPalette() {\n  fill(palette[0]);\n  rect(0, 0, width/5, height);\n  fill(palette[1]);\n  rect(width/5, 0, width/5, height);\n  fill(palette[2]);\n  rect(width/5*2, 0, width/5, height);\n  fill(palette[3]);\n  rect(width/5*3, 0, width/5, height);\n  fill(palette[4]);\n  rect(width/5*4, 0, width/5, height);\n}\n</code></pre> <p>Il programma \u00e8 molto semplice: ho creato due funzioni personalizzate createPalette() e drawPalette() per gestire al meglio la creazione e la rappresentazione a schermo delle palette.</p> <p>I colori vengono salvati in un array nominato palette per comodit\u00e0.</p> <p>Ad ogni click del mouse viene generata una nuova palette mentre, premendo il tasto s sulla tastiera, viene salvata un'immagine nella cartella del programma.</p> <p>In console \u00e8 possibile vedere i valori esadecimali dei colori ottenuti richiamando la funzione hex() sui dati di tipo color all'interno dell'array.</p> <p>Ecco qualche esempio:</p> <p></p> <p></p>","tags":["colormode","hsb","palette","processing"]},{"location":"immagini/2017-03-12-utilizzare-immagini-in-processing/","title":"Utilizzare immagini in Processing: PImage, loadimage() e image()","text":"<p>In tutti gli sketch che abbiamo creato fino a oggi abbiamo sempre utilizzato Processing per generare forme sullo schermo. Con questo post, invece, cominceremo ad ampliare i nostri orizzonti e inizieremo a utilizzare nei nostri programmi\u00a0immagini esterne.</p> <p>A differenza dei\u00a0programmi di editing pi\u00f9 comuni \u2013 penso per esempio a Photoshop o Pixelmator \u2013 con Processing possiamo\u00a0lavorare in modo pi\u00f9 preciso e dettagliato\u00a0su ogni singola foto andando a regolare, a nostro piacimento, ogni pixel.</p>","tags":["image","immagini","loadimage","pimage"]},{"location":"immagini/2017-03-12-utilizzare-immagini-in-processing/#le-immagini-sono-dati","title":"Le immagini sono dati","text":"<p>Le immagini digitali non sono altro che un insieme di dati, ovvero\u00a0numeri.\u00a0Per cercare di spiegarlo nel modo pi\u00f9 semplice possibile, ciascun dato rappresenta i valori di rosso, verde e blu (RGB) di un punto preciso all'interno di una griglia.</p> <p>Di fatto possiamo immaginare ogni foto come una griglia di pixel dove ciascun pixel avr\u00e0 diversi valori di rosso, verde e blu.\u00a0Con la programmazione e un po' di fantasia possiamo avere accesso a tutti questi dati e usarli\u00a0a nostro piacimento.</p>","tags":["image","immagini","loadimage","pimage"]},{"location":"immagini/2017-03-12-utilizzare-immagini-in-processing/#pimage-loadimage-e-image","title":"PImage, loadImage() e image()","text":"<p>Abbiamo gi\u00e0 parlato di tipi di dati e classi. Processing ha al suo interno la classe\u00a0PImage la cui funzione principale \u00e8 quella di permetterci di caricare e visualizzare un'immagine.</p> <p>La funzione\u00a0loadImage(), che accetta un parametro di tipo\u00a0String,\u00a0carica il file all'interno della memoria. Nell'esempio riportato in seguito, il\u00a0parametro passato alla funzione \u00e8 il nome del file comprensivo di estensione. La funzione andr\u00e0 a cercare se quel file \u00e8 presente all'interno della sottocartella\u00a0data\u00a0presente all'interno del nostro sketch.</p> <p>Per chi non lo ricordasse, in questo post abbiamo gi\u00e0 trattato come caricare file esterni all'interno del nostro sketch in Processing.</p> <p>Mettiamo tutto insieme:</p> <pre><code>/*\n * Utilizzare immagini in Processing: PImage, loadimage() e image()\n * Federico Pepe, 12.03.2017\n * http://blog.federicopepe.com/processing\n*/\n\nPImage immagine;\n\nvoid setup() {\n  size(500, 500);\n  immagine = loadImage(\"logo_federicopepe.png\");\n}\n\nvoid draw() {\n  image(immagine, 0, 0);\n}\n</code></pre> <p>Ho\u00a0creato una variabile di tipo\u00a0PImage chiamata\u00a0immagine; attraverso la funzione\u00a0loadImage()\u00a0carico il file chiamato\u00a0logo_federicopepe.png\u00a0che, in precedenza, avevo gi\u00e0 spostato all'interno della cartella\u00a0data e, infine, con la funzione\u00a0image() visualizzo l'immagine facendo in modo che il bordo in alto a sinistra corrisponda alle coordinate 0, 0.</p> <p>Ecco il\u00a0risultato:</p> <p></p> <p>L'immagine viene visualizzata correttamente perch\u00e9 il file originale \u00e8 di 500 x 500 pixel. Per completezza\u00a0condivido anche lo screenshot della cartella dello sketch.</p> <p></p> <p>Processing accetta i seguenti tipi di file:\u00a0GIF, JPG, TGA\u00a0e\u00a0PNG.</p>","tags":["image","immagini","loadimage","pimage"]},{"location":"immagini/2017-03-12-utilizzare-immagini-in-processing/#un-paio-di-precisazioni","title":"Un paio di precisazioni","text":"<p>Abbiamo detto che PImage \u00e8 una classe. Perch\u00e9 non abbiamo\u00a0mai chiamato un\u00a0constructor per inizializzarla? La funzione\u00a0loadImage() in questo caso ha la funzione del constructor restituendo una nuova istanza dell'oggetto PImage generata dal file che carichiamo.</p> <p>Se quest'ultima frase vi sembra arabo, consiglio di ripassare i post dedicati alla programmazione ad oggetti:</p> <ul> <li>Introduzione agli oggetti</li> <li>OOP: Sintassi di classi e oggetti</li> <li>OOP: Classi e oggetti, parte 2</li> </ul> <p>Come illustrato nel\u00a0reference la funzione\u00a0image()\u00a0richiede un minimo di tre parametri: immagine da caricare, posizione x e y. \u00c8 possibile passare alla funzione due parametri ulteriori per specificare la larghezza e l'altezza dell'immagine: un metodo comodo e veloce per ridimensionare le foto:</p> <pre><code>/*\n * Utilizzare immagini in Processing: PImage, loadimage() e image()\n * Federico Pepe, 12.03.2017\n * http://blog.federicopepe.com/processing\n*/\n\nPImage immagine;\n\nvoid setup() {\n  size(500, 500);\n  immagine = loadImage(\"logo_federicopepe.png\");\n}\n\nvoid draw() {\n  // Utilizzo due parametri aggiuntivi per ridimensionare la foto\n  image(immagine, 0, 0, 100, 100);\n}\n</code></pre> <p></p>","tags":["image","immagini","loadimage","pimage"]},{"location":"immagini/2017-03-19-modificare-immagini-tint-filtro/","title":"Modificare le immagini: tint(), filter()","text":"<p>Proseguiamo\u00a0l'approfondimento su Processing e immagini. Nell'era di Instagram siamo abituati a cambiare l'aspetto delle nostre foto prima di condividerle con gli altri. Le funzioni tint() e\u00a0filter()\u00a0\u2013 gi\u00e0 incluse\u00a0all'interno del linguaggio \u2013 ci consentono di alterare\u00a0le immagini a nostro piacimento.</p>","tags":["filter","tint"]},{"location":"immagini/2017-03-19-modificare-immagini-tint-filtro/#la-funzione-tint","title":"La funzione tint()","text":"<p>Questa funzione\u00a0consente\u00a0di alterare il colore generale delle foto. L'effetto non \u00e8 permanente tanto che invocando la funzione\u00a0noTint() \u00e8 possibile ritornare all'originale.</p> <p>I parametri accettati vanno da uno a quattro come\u00a0specificato\u00a0nel reference.\u00a0Prendendo quest'immagine di partenza \u2013chi non ama i gatti? \u2013 facciamo qualche esempio:</p> <p> Immagine di partenza, presa da Pixabay\u00a0(CC)</p> <p>Passiamo alla funzione un solo parametro per applicare un filtro \"grigio\":</p> <pre><code>/*\n * Immagini: tint(), filter() e masking\n * Federico Pepe, 19.03.2017\n * http://blog.federicopepe.com/processing\n*/\n\nPImage immagine;\n\nvoid setup() {\n  size(640, 535);\n  immagine = loadImage(\"cat.jpg\");\n  tint(100);\n  image(immagine, 0, 0);\n}\n\nvoid draw() {\n\n}\n</code></pre> <p></p> <p>Passiamo a tint() tre parametri: <code>tint(255, 255, 50);</code>. \u00c8 possibile\u00a0usare\u00a0tre valori RGB che HSB in base alla funzione\u00a0colorMode()\u00a0precedentemente impostata.</p> <p></p> <p>Se avete un background\u00a0in web design, sappiate che Processing accetta anche valori esadecimali <code>tint(#FF55EE);</code></p> <p></p> <p>\u00c8 possibile anche sfruttare il parametro della trasparenza\u00a0alpha.</p> <pre><code>tint(#FF55EE, 70);\nimage(immagine, 0, 0);\ntint(255, 255, 50, 50);\nimage(immagine, 0, 0);\n</code></pre> <p>Questo codice dar\u00e0 il seguente risultato:</p> <p></p>","tags":["filter","tint"]},{"location":"immagini/2017-03-19-modificare-immagini-tint-filtro/#aggiungere-un-filtro-con-la-funzione-filter","title":"Aggiungere un filtro\u00a0con la funzione filter()","text":"<p>Oltre alla funzione tint(), Processing ha al suo interno la funzione filter() che, come i comuni programmi di grafica come Adobe Photoshop o GIMP, permette di applicare dei filtri alle foto.</p> <p>I parametri sono otto e devono essere sempre indicati in maiuscolo: THRESHOLD, GRAY, INVERT, POSTERIZE, BLUR, OPAQUE, ERODE e DILATE. Alcuni di essi accettano un secondo parametro mentre altri no.</p> <p>Mentre la funzione\u00a0tint()\u00a0doveva essere dichiarata prima di mostrare l'immagine, la funzione\u00a0filter() \u00e8 inserita successivamente, come indicato nel seguente esempio:</p> <pre><code>/*\n * Immagini: tint(), filter() e masking\n * Federico Pepe, 19.03.2017\n * http://blog.federicopepe.com/processing\n*/\n\nPImage immagine;\n\nvoid setup() {\n  size(640, 535);\n  immagine = loadImage(\"cat.jpg\");\n  tint(100);\n  image(immagine, 0, 0);\n}\n\nvoid draw() {\n\n}\n</code></pre>","tags":["filter","tint"]},{"location":"immagini/2017-03-19-modificare-immagini-tint-filtro/#threshold","title":"THRESHOLD","text":"<p>Converte\u00a0i pixel di un'immagine in bianco o nero in base alla soglia impostata\u00a0che pu\u00f2 assumere\u00a0un valore compreso tra 0 e 1. Se non viene indicato, il valore di default \u00e8 0.5.</p> <p>[gallery link=\"file\" size=\"medium\" ids=\"1154,1155,1156\"]</p>","tags":["filter","tint"]},{"location":"immagini/2017-03-19-modificare-immagini-tint-filtro/#blur","title":"BLUR","text":"<p>Applica un filtro di sfocatura gaussiana. Il secondo parametro indica il raggio della sfocatura.</p> <p>[gallery size=\"medium\" link=\"file\" ids=\"1159,1160,1161\"]</p>","tags":["filter","tint"]},{"location":"immagini/2017-03-19-modificare-immagini-tint-filtro/#posterize","title":"POSTERIZE","text":"<p>Limita ciascun canale dell'immagine al numero di colori passati come parametro. I valori accettati vanno da 2 a 255.</p> <p>[gallery link=\"file\" size=\"medium\" ids=\"1162,1163,1164\"]</p>","tags":["filter","tint"]},{"location":"immagini/2017-03-19-modificare-immagini-tint-filtro/#gray","title":"GRAY","text":"<p>Converte i colori dell'immagine nel loro valore corrispondente in scala di grigi.</p>","tags":["filter","tint"]},{"location":"immagini/2017-03-19-modificare-immagini-tint-filtro/#opaque","title":"OPAQUE","text":"<p>Imposta il canale trasparenza (alpha) opaco.</p>","tags":["filter","tint"]},{"location":"immagini/2017-03-19-modificare-immagini-tint-filtro/#invert","title":"INVERT","text":"<p>Inverte il valore di ciascun pixel.</p>","tags":["filter","tint"]},{"location":"immagini/2017-03-19-modificare-immagini-tint-filtro/#erode-e-dilate","title":"ERODE e DILATE","text":"<p>Il primo riduce le aree illuminate mentre il secondo le aumenta.</p> <p>[gallery link=\"file\" columns=\"5\" size=\"medium\" ids=\"1165,1166,1167,1168,1169\"]</p> <p>Le funzioni che abbiamo visto oggi sono solo l'inizio; prossimamente vedremo come creare i nostri filtri personalizzati andando a lavorare sui singoli pixel.</p>","tags":["filter","tint"]},{"location":"immagini/2017-03-26-array-pixel-loadpixels-updatepixels/","title":"Array di pixel: loadPixels() e updatePixels()","text":"<p>Avevo parlato di pixel in uno dei primissimi post su Processing in questo blog. Grazie alle competenze che abbiamo acquisito nelle ultime settimane, possiamo fare un ulteriore passo in avanti.</p> <p>Le funzioni\u00a0che abbiamo usato fino a oggi ci hanno permesso di disegnare linee e forme sullo schermo o, come visto di recente, di\u00a0mostrare un'immagine.\u00a0Queste funzioni che, all'apparenza, sembrano eseguire operazioni molto semplici, in realt\u00e0 nascondono\u00a0un principio molto complesso: stabilire\u00a0se ciascun pixel sullo schermo deve essere accesso o spento e, se acceso,\u00a0il colore che deve rappresentare.</p>","tags":["2d-array","loadpixels","pixels-length","updatepixels"]},{"location":"immagini/2017-03-26-array-pixel-loadpixels-updatepixels/#array-di-pixel","title":"Array di pixel","text":"<p>Siamo abituati a pensare ai pixel come ad una griglia sullo schermo; quindi ad\u00a0un array bidimensionale.</p> <p></p> <p>In Processing, per\u00f2,\u00a0il valore di ciascuno di essi viene salvato in un classico array monodimensionale.</p> <p></p> <p>\u00c8 possibile accedere\u00a0a queste informazioni e modificarle a nostro piacimento? Ovviamente si, utilizzando le funzioni\u00a0loadPixels() e\u00a0updatePixels().</p>","tags":["2d-array","loadpixels","pixels-length","updatepixels"]},{"location":"immagini/2017-03-26-array-pixel-loadpixels-updatepixels/#loadpixels-e-updatepixels","title":"loadPixels() e updatePixels()","text":"<p>Con la prima funzione stiamo dicendo\u00a0a Processing che intendiamo lavorare sull'array di pixel e che, quindi, deve caricarlo in una variabile. updatePixels(),\u00a0invece, la usiamo quando abbiamo apportato tutte le modifiche e vogliamo che il programma\u00a0aggiorni le informazioni sullo schermo.</p> <p>Facciamo un esempio pratico:</p> <pre><code>/*\n * Array di pixel: loadPixels() e updatePixels()\n * Federico Pepe, 26.03.2017\n * http://blog.federicopepe.com/processing\n */\n\nvoid setup() {\n  size(500, 500);\n  loadPixels();  \n\n  for (int i = 0; i &lt; pixels.length; i++) {\n    float rand = random(255);\n    color c = color(0, 0, rand);\n    pixels[i] = c;\n  }\n\n  updatePixels();\n}\n</code></pre> <p>In questo programma\u00a0carichiamo tutti i valori di una finestra di 500x500 pixel. Con il ciclo\u00a0for partiamo dal primo valore presente nel nostro array e arriviamo fino all'ultimo, identificato, per comodit\u00e0, dalla funzione <code>pixel.length</code> e assegniamo a ciascuno un colore casuale <code>float rand = random(255);</code> nella scala dei blu <code>color c = color(0, 0, rand);</code>.</p> <p>Assegniamo il nuovo colore al pixel <code>pixels[i] = c;</code> e, una volta usciti dal loop, chiediamo a Processing di aggiornare e mostrare tutte le modifiche che abbiamo effettuato <code>updatePixels();</code>.</p> <p>Il risultato sar\u00e0 il seguente:</p> <p></p>","tags":["2d-array","loadpixels","pixels-length","updatepixels"]},{"location":"immagini/2017-03-26-array-pixel-loadpixels-updatepixels/#modificare-un-pixel-conoscendone-la-posizione-x-e-y","title":"Modificare un pixel conoscendone la posizione x e y","text":"<p>A questo punto, immagino, potr\u00e0 esservi sorta spontaneamente una domanda: \u00e8 possibile accedere a un determinato pixel conoscendone la posizione x e y all'interno della finestra come siamo stati abituati a fare fino a ora?</p> <p>Riprendendo l'immagine della griglia pi\u00f9 sopra, proviamo a capire come accedere al pixel 19: la sua posizione\u00a0\u00e8 x = 5, y = 2. A questo punto \u00e8 importante ricordare che, per questi valori, partiamo a contare da 0 mentre, per la larghezza della finestra, da 1.</p> <p>Ora dobbiamo sommare\u00a0il valore di x al valore di y moltiplicato alla larghezza.</p> <p>La formula \u00e8, dunque: <code>x + (y * width)</code></p> <p>5 + (2 * 7) = 19</p> <p>I conti tornano!</p> <p>Proviamo a\u00a0modificare il codice di prima come segue:</p> <pre><code>/*\n * Array di pixel: loadPixels() e updatePixels()\n * Federico Pepe, 26.03.2017\n * http://blog.federicopepe.com/processing\n */\n\nvoid setup() {\n  size(500, 500);\n  loadPixels();  \n  color c;\n  for (int x = 0; x &lt; width; x++) {\n    for (int y = 0; y &lt; height; y++) {\n      float rand = random(255);\n      int pos = x + y * width;\n      if(x % 2 == 0) {\n        c = color(0, 0, rand);\n      } else {\n        c = color(rand, 0, 0);\n      }\n      pixels[pos] = c;\n    }\n  }\n\n  updatePixels();\n}\n</code></pre> <p></p> <p>Zoomando l'immagine noterete che una riga \u00e8 rossa e una riga \u00e8, invece, blu. Il prossimo passo sar\u00e0 applicare quello che abbiamo appena imparato su un'immagine. Provate a pensare a tutte le operazioni che potremmo compiere andando a modificare individualmente ogni singolo pixel.</p>","tags":["2d-array","loadpixels","pixels-length","updatepixels"]},{"location":"immagini/2017-04-29-processare-le-immagini-processing/","title":"Processare le immagini in Processing","text":"<p>In questo post vedremo come unire le nozioni che abbiamo appreso relativamente al caricamento e all' utilizzo delle immagini in Processing e alle possibilit\u00e0 creative che abbiamo a disposizione lavorando sui singoli pixel\u00a0per imparare a\u00a0processore le immagini a nostro piacimento.</p> <p>Riprendiamo l'immagine del gatto che abbiamo gi\u00e0 usato in precedenza\u00a0e carichiamola all'interno di un nuovo sketch. Invece di utilizzare la funzione image() per mostrarla nella finestra, questa volta andremo a caricare tutti i pixel che compongono l'immagine.</p> <pre><code>/*\n * Processare le immagini in Processing\n * Federico Pepe, 29.04.2017\n * http://blog.federicopepe.com/processing\n */\n\nPImage img;\n\nvoid setup() {\n  size(640, 536);\n  img = loadImage(\"cat-300572_640.jpg\");\n}\n\nvoid draw() {\n  // Carichiamo i pixel della finestra\n  loadPixels();\n  // Carichiamo i pixel dell'immagine\n  img.loadPixels();\n  for(int y = 0; y &lt; height; y++) {\n    for(int x = 0; x &lt; width; x++) {\n      int pos = x + y * width;\n\n      float r = red(img.pixels[pos]);\n      float g = green(img.pixels[pos]);\n      float b = blue(img.pixels[pos]);\n\n      pixels[pos] = color(r, g, b);\n    }\n  }\n  updatePixels();\n}\n</code></pre> <p>Analizziamo velocemente il codice qui sopra concentrandoci, in particolare, sulle cose che non abbiamo mai visto prima:\u00a0come indicato nei commenti, oltre a caricare i pixel della finestra dobbiamo caricare anche quelli relativi all'immagine. Per farlo utilizziamo <code>img.loadPixels();</code> dove\u00a0img\u00a0fa riferimento al\u00a0nome della variabile che abbiamo dichiarato all'inizio del programma.</p> <p>Con due loop for andiamo a caricare ogni singolo pixel e,\u00a0utilizzando le funzioni\u00a0red(),\u00a0green(),\u00a0blue()\u00a0otteniamo i valori R, G e B. Attraverso\u00a0<code>pixels[pos] = color(r, g, b);</code> assegniamo i valori al pixel sullo schermo.</p> <p>Il nostro programma, in pratica, lavora come segue: che valori di rosso,\u00a0verde e\u00a0blu\u00a0ha il pixel nell'immagine che ha coordinate x = 0, y = 0? Una volta ottenuti, applica quei valori al pixel\u00a0con posizione x = 0 e y = 0 della finestra. Dopodich\u00e9, il ciclo for prosegue e analizzer\u00e0 il pixel con coordinate x = 1 e y = 0 e avanti cos\u00ec.</p> <p>Con l'updatePixel() finale\u00a0aggiorniamo tutti i valori presenti nell'array della finestra. Il risultato finale sar\u00e0, dunque, vedere visualizzata sullo schermo l'immagine.</p> <p>La domanda che sorge spontanea \u00e8: perch\u00e9 dovrei scrivere tutte queste righe di codice quando avrei potuto usare la funzione image() e risparmiare un sacco di fatica? La risposta \u00e8 semplice:\u00a0avendo accesso ai dati grezzi dell'immagine possiamo modificarli a nostro piacimento.</p> <p>Proviamo, ad esempio, ad aggiungere la riga in grassetto al nostro codice:</p> <p>r = constrain(r, 0, 100);</p> <p>pixels[pos] = color(r, g, b);</p> <p>Il risultato sar\u00e0 che il valore del\u00a0rosso non potr\u00e0 avere un valore compreso tra 0 e 255 come previsto normalmente ma sar\u00e0 limitato a valori compresi tra 0, 100 grazie alla funzione\u00a0constrain.</p> <p></p> <p>Siamo riusciti a creare il nostro primo filtro personalizzato per le immagini. Ora possiamo\u00a0dare sfogo alla nostra fantasia.</p> <p>Facciamo un altro esperimento: rimpiazziamo l'ultima riga di codice che abbiamo aggiunto con quella seguente:</p> <p>r = map(mouseX, 0, width, 0, 255);</p> <p>Il\u00a0rosso ora \u00e8 controllato dalla posizione x del mouse.</p>","tags":["blue","color","constrain","green","map","red"]},{"location":"immagini/2017-04-29-processare-le-immagini-processing/#usare-un-solo-ciclo-for","title":"Usare un solo ciclo for","text":"<p>Prima di concludere questo post ci tengo a fare una precisazione: volendo \u00e8 possibile utilizzare un solo ciclo for per ottenere lo stesso effetto riducendo, cos\u00ec, le righe di codice del nostro programma:</p> <p>for(int i = 0; i &lt; pixels.length; i++)</p> <p>Se decidiamo di intraprendere questa strada dobbiamo eliminare la variabile\u00a0pos e sostituirla con\u00a0i:</p> <p>float r = red(img.pixels[i]);</p> <p>Come avevamo discusso nel post relativo all'array di pixel la differenza tra i due approcci dipende se consideriamo\u00a0l'immagine un array monodimensionale o bidimensionale.</p>","tags":["blue","color","constrain","green","map","red"]},{"location":"immagini/2017-06-25-modificare-la-dimensione-della-finestra-base-allimmagine-caricata/","title":"Modificare la dimensione della finestra in base all'immagine caricata","text":"<p>Negli esempi che abbiamo visto fino ad ora relativi all'uso delle immagini all'interno di Processing abbiamo sempre impostato a priori la grandezza della finestra del nostro sketch in base alla dimensione dell'immagine caricata.</p> <p>\u00c8 un metodo molto semplice ma decisamente scomodo se dobbiamo utilizzare tante immagini diverse oppure se vogliamo rendere il nostro programma\u00a0universale.</p> <p>Nella versione precedente di Processing era possibile utilizzare delle variabili all'interno della funzione size(). Questa opzione, per\u00f2, bench\u00e9 fortemente osteggiata dagli sviluppatori fin dal 2009 \u00e8 stata definitivamente rimossa con l'aggiornamento a Processing 3 perch\u00e9 impediva miglioramenti in termini di performance, velocit\u00e0 e compatibilit\u00e0 cross-platform.</p> <p>Non disperate! Esiste una soluzione alternativa che, per\u00f2, non \u00e8 ben descritta nel\u00a0reference del linguaggio. Ecco perch\u00e9 ho pensato fosse interessante scrivere un breve articolo a riguardo.</p> <p>Ecco come fare:</p> <ul> <li>All'interno di setup() \u00e8 comunque necessario indicare una dimensione di partenza con la funzione size(). Per semplicit\u00e0 possiamo scrivere: size(1, 1);</li> <li>Dopodich\u00e9 aggiungiamo la seguente linea di codice: <code>surface.setResizable(true);</code> mi raccomando, fate attenzione alle maiuscole!</li> <li>A questo punto, nel punto in cui abbiamo la necessit\u00e0 di reimpostare la dimensione \u00e8 sufficiente scrivere: <code>surface.setSize(larghezza, altezza);</code> dove\u00a0larghezza\u00a0e\u00a0altezza sono i nostri parametri.</li> </ul> <p>Ecco un esempio con un'immagine:</p> <pre><code>/*\n * Modificare la dimensione della finestra in base all'immagine caricata\n * Federico Pepe, 25.06.2017\n * http://blog.federicopepe.com/processing\n*/\n\nPImage img;\n\nvoid setup() {\n  size(1, 1);\n  surface.setResizable(true);\n  img = loadImage(\"immagine.jpg\");\n  surface.setSize(img.width, img.height);  \n}\n\nvoid draw() {\n}\n</code></pre> <p>Per cambiare la dimensione a ogni click del mouse:</p> <pre><code>/*\n * Modificare la dimensione della finestra in base all'immagine caricata\n * Federico Pepe, 25.06.2017\n * http://blog.federicopepe.com/processing\n*/\n\nvoid setup() {\n  size(100, 100);\n  surface.setResizable(true);\n}\n\nvoid draw() {\n}\n\nvoid mousePressed() {\n  surface.setSize(round(random(100, 500)), round(random(100, 500)));  \n}\n</code></pre>","tags":["setup","size","surface-setresizable","surface-setsize"]},{"location":"immagini/2017-08-28-palette-colori-da-immagine/","title":"Una palette di colori da un'immagine","text":"<p>Nelle ultime settimane mi \u00e8 capitato di fare diversi lavori di grafica \u2013 che non \u00e8 propriamente il campo in cui sono pi\u00f9 ferrato \u2013 e mi sono sempre trovato in crisi nella scelta della palette di colori pi\u00f9 adatta a quello che stavo facendo.</p> <p>Mentre ero alla ricerca della giusta combinazioni di colori su siti come Coolors e Adobe Color mi \u00e8 tornata in mente una frase di Joshua Davis detta in uno dei suoi video (non cito testualmente, vado a memoria): le palette di colori che funzionano meglio sono quelle legate a immagini a cui siamo abituati, come un tramonto sul mare oppure le gradazioni di verde in un bosco in montagna. Ecco perch\u00e9 estrarre i colori da una foto \u00e8 uno dei modi migliori per trovare delle combinazioni che funzionano.</p> <p>Da qui l'illuminazione: perch\u00e9 non creare uno sketch in Processing per aiutarmi?</p>","tags":["hex","pimage","savestrings","stringlist"]},{"location":"immagini/2017-08-28-palette-colori-da-immagine/#leggere-i-colori-da-unimmagine","title":"Leggere i colori da un'immagine","text":"<p>Partiamo riciclando il codice visto nell'ultimo post: Modificare la dimensione della finestra in base all'immagine caricata. Creiamo un oggetto di tipo PImage e facciamo in mondo che la finestra si ridimensioni automaticamente al caricamento del file. Nel codice sotto riportato noterete un +50 pixel nell'altezza che servir\u00e0 come spazio per rappresentare i colori della palette in tempo reale.</p> <p>Per questo sketch ho deciso di utilizzare l'immagine di un prato fiorito: </p> <p>Ricordatevi di inserire l'immagine nella cartella /data come spiegato qui.</p> <pre><code>/*\n * Una palette di colori da un'immagine\n * Federico Pepe, 28.08.2017\n * http://blog.federicopepe.com/processing\n*/\n\nPImage img;\n\nvoid setup() {\n  size(1, 1);\n  surface.setResizable(true);\n  img = loadImage(\"flowers.jpg\");\n  surface.setSize(img.width, img.height+50); \n}\n\nvoid draw() {\n}\n</code></pre> <p>Creiamo due variabili di tipo integer: la prima,\u00a0numPoints indica il numero di colori di cui sar\u00e0 composta la nostra palette. Ho deciso di chiamarla\u00a0points perch\u00e9 prenderemo i dati colori da dei punti nell'immagine. La seconda\u00a0pointX la utilizzeremo come riferimento per calcolare il valore di x dei punti scelti che, ai fini di questo esempio, saranno equidistanti.</p> <p>Aggiungiamo un po' di codice nel ciclo draw(): mostriamo l'immagine come sfondo e carichiamo l'array di pixel. Come anticipato, assegniamo a pointX il valore della larghezza della foto caricata diviso il numero di punti.</p> <p>Utilizziamo il classico ciclo for per trovare i colori dei punti. Creo un minimo di interfaccia per aiutarmi nel lavoro: intorno ai punti di riferimento disegno un cerchio.</p> <pre><code>/*\n * Una palette di colori da un'immagine\n * Federico Pepe, 28.08.2017\n * http://blog.federicopepe.com/processing\n*/\n\nPImage img;\n// Numero di \"punti\" della nostra palette\nint numPoints = 5;\n// Valore x di riferimento\nint pointX;\n\nvoid setup() {\n  size(1, 1);\n  surface.setResizable(true);\n  img = loadImage(\"flowers.jpg\");\n  surface.setSize(img.width, img.height+50); \n}\n\nvoid draw() {\n  image(img, 0, 0);\n  img.loadPixels();\n  pointX = img.width / numPoints;\n\n  for(int i = 0; i &lt;= numPoints-1; i++) {\n    int x = pointX*i;\n    int y = mouseY;\n\n    if(mouseY &lt;= 0 || mouseY &gt;= img.height) {\n      y = img.height/2;\n    }\n    stroke(255);\n    noFill();\n    ellipse(x, y, 25, 25);\n    color c = img.pixels[x + y * img.width];\n    println(c);\n  }\n\n}\n</code></pre> <p>Avendo deciso di lasciare il valore di y variabile e dipendente dalla posizione y del mouse, ho deciso di inserire un controllo condizionale per verificare di non uscire dall'immagine stessa causando un errore Array out of bounds sull'array di pixel.</p> <p>Nella console vengono mostrati i valori di c ma non sono utilizzabili in alcun programma di grafica perch\u00e9 non sono i classici valori HEX, RGB o HSB.</p>","tags":["hex","pimage","savestrings","stringlist"]},{"location":"immagini/2017-08-28-palette-colori-da-immagine/#mostriamo-la-palette-di-colori","title":"Mostriamo la palette di colori","text":"<p>Sfrutto i 50 pixel di margine di abbondanza rispetto alla foto per mostrare in tempo reale i colori dei pixel di riferimento. Farlo \u00e8 molto semplice: creo dei rettangoli con, come fill, il colore estratto in precedenza. Sfrutto questo passaggio per centrare i punti di analisi rispetto alla larghezza della finestra e ai rettangoli in basso.</p> <p></p> <pre><code>/*\n * Una palette di colori da un'immagine\n * Federico Pepe, 28.08.2017\n * http://blog.federicopepe.com/processing\n */\n\nPImage img;\n// Numero di \"punti\" della nostra palette\nint numPoints = 5;\n// Valore x di riferimento\nint pointX;\n\nvoid setup() {\n  size(1, 1);\n  surface.setResizable(true);\n  img = loadImage(\"flowers.jpg\");\n  surface.setSize(img.width, img.height+50);\n}\n\nvoid draw() {\n  image(img, 0, 0);\n  img.loadPixels();\n  pointX = img.width / numPoints;\n\n  for (int i = 0; i &lt;= numPoints-1; i++) {\n    int x = pointX/2+pointX*i;\n    int y = mouseY;\n\n    if (mouseY &lt;= 0 || mouseY &gt;= img.height) {\n      y = img.height/2;\n    }\n\n    stroke(255);\n    noFill();\n    ellipse(x, y, 25, 25);\n\n    color c = img.pixels[x + y * img.width];\n\n    fill(c);\n    rect(pointX*i, img.height, pointX, 50);\n  }\n}\n</code></pre>","tags":["hex","pimage","savestrings","stringlist"]},{"location":"immagini/2017-08-28-palette-colori-da-immagine/#otteniamo-i-valori-hex-dei-colori","title":"Otteniamo i valori HEX dei colori","text":"<p>A questo punto il programma funziona nel modo corretto, non ci resta che fare dei piccoli miglioramenti all'interfaccia: grazie alla funzione\u00a0hex(value, digits) possiamo ottenere il valore esadecimale del colore. Come indicato nel reference, il numero viene rappresentato con un massimo di 8 caratteri ma possiamo ottenerne 6, come siamo abituati, aggiungendo indicando il secondo parametro alla funzione.</p> <p></p> <p>Ecco qui il codice:</p> <pre><code>/*\n * Una palette di colori da un'immagine\n * Federico Pepe, 28.08.2017\n * http://blog.federicopepe.com/processing\n */\n\nPImage img;\n// Numero di \"punti\" della nostra palette\nint numPoints = 5;\n// Valore x di riferimento\nint pointX;\n\nvoid setup() {\n  size(1, 1);\n  surface.setResizable(true);\n  img = loadImage(\"flowers.jpg\");\n  surface.setSize(img.width, img.height+50);\n}\n\nvoid draw() {\n  image(img, 0, 0);\n  img.loadPixels();\n  pointX = img.width / numPoints;\n\n  for (int i = 0; i &lt;= numPoints-1; i++) {\n    int x = pointX/2+pointX*i;\n    int y = mouseY;\n\n    if (mouseY &lt;= 0 || mouseY &gt;= img.height) {\n      y = img.height/2;\n    }\n\n    stroke(255);\n    noFill();\n    ellipse(x, y, 25, 25);\n\n    color c = img.pixels[x + y * img.width];\n\n    fill(c);\n    rect(pointX*i, img.height, pointX, 50);\n\n    fill(255);\n    textAlign(CENTER);\n    text(\"#\"+hex(c,6), x, img.height+30);\n\n  }\n}\n</code></pre>","tags":["hex","pimage","savestrings","stringlist"]},{"location":"immagini/2017-08-28-palette-colori-da-immagine/#salvare-la-palette-di-colori-in-un-file-di-testo","title":"Salvare la palette di colori in un file di testo","text":"<p>Siamo quasi alla fine del nostro lavoro: l'unico passaggio che ci manca \u00e8 salvare la palette di colori in un file .txt in modo da poterli usare a nostro piacimento anche in programmi esterni.</p> <p>Aggiungiamo qualche riga di codice: creiamo una nuova variabile di tipo StringList il cui contenuto verr\u00e0 inizializzato a ogni ciclo di draw con la funzione .clear();</p> <p>Alla pressione del tasto del mouse, verr\u00e0 salvato il file chiamato palette.txt. La conversione della StringList in array \u00e8 necessaria perch\u00e9 la funzione saveStrings si aspetta come secondo parametro un array e non una lista.</p> <pre><code>/*\n * Una palette di colori da un'immagine\n * Federico Pepe, 28.08.2017\n * http://blog.federicopepe.com/processing\n */\n\nPImage img;\n// Numero di \"punti\" della nostra palette\nint numPoints = 5;\n// Valore x di riferimento\nint pointX;\n// Salviamo i valori HEX in una lista di stringhe\nStringList palette = new StringList();\n\nvoid setup() {\n  size(1, 1);\n  surface.setResizable(true);\n  img = loadImage(\"flowers.jpg\");\n  surface.setSize(img.width, img.height+50);\n}\n\nvoid draw() {\n  image(img, 0, 0);\n\n  img.loadPixels();\n  pointX = img.width / numPoints;\n\n  palette.clear();\n\n  for (int i = 0; i &lt;= numPoints-1; i++) {\n    int x = pointX/2+pointX*i;\n    int y = mouseY;\n\n    if (mouseY &lt;= 0 || mouseY &gt;= img.height) {\n      y = img.height/2;\n    }\n\n    stroke(255);\n    noFill();\n    ellipse(x, y, 25, 25);\n\n    color c = img.pixels[x + y * img.width];\n\n    fill(c);\n    rect(pointX*i, img.height, pointX, 50);\n\n    fill(255);\n    textAlign(CENTER);\n    text(\"#\"+hex(c,6), x, img.height+30);\n    // Aggiungiamo il colore come stringa all'array\n    palette.append(\"#\"+hex(c,6));\n\n  }\n}\n\nvoid mousePressed() {\n  saveStrings(\"palette.txt\", palette.array());\n}\n</code></pre>","tags":["hex","pimage","savestrings","stringlist"]},{"location":"immagini/2017-09-23-glitch-di-unimmagine/","title":"Glitch di un'immagine con Processing","text":"","tags":["brightness","glitch","glitch-art","saturation"]},{"location":"immagini/2017-09-23-glitch-di-unimmagine/#breve-introduzione-alla-glitch-art","title":"Breve introduzione alla Glitch Art","text":"<p>Per\u00a0Glitch Art intendiamo la pratica sfruttare e/o introdurre in un'opera degli errori analogici o digitali per fini estetici. Nel mondo dell'analogico si interviene direttamente sugli apparecchi elettronici che registrano o riproducono l'opera. Per quanto riguarda il digitale, invece, tale manipolazione \u00e8 resa ancora pi\u00f9 semplice dagli strumenti tecnologici di cui disponiamo che ci consentono di accedere direttamente ai dati e di farne ci\u00f2 che vogliamo. Questa pratica \u00e8 anche chiamata\u00a0databending.</p> <p>Non si tratta di un movimento artistico nato, come si potrebbe pensare, negli ultimi anni con la democratizzazione della tecnologia e degli strumenti creativi ma, al contrario, affonda le sue radici nella prima met\u00e0 del novecento: il filmato qui sotto A Colour Box dell'artista neo-zelandese Len Lye e datato 1935 \u00e8 considerato uno dei primi esempi di glitch art.</p> <p>https://www.youtube.com/watch?v=q-4k3A-ZHqM</p> <p>Bench\u00e9 negli ultimi anni abbia riscosso un sempre maggiore successo, questo movimento artistico non \u00e8 mai diventato mainstream. Possiamo sfruttare quello che abbiamo imparato a fare con Processing per fare i nostri esperimenti di glitch art e per studiare qualche nuova funzione del linguaggio.</p>","tags":["brightness","glitch","glitch-art","saturation"]},{"location":"immagini/2017-09-23-glitch-di-unimmagine/#usiamo-processing-per-creare-un-effetto-glitch","title":"Usiamo Processing per creare un effetto glitch","text":"<p>Lo scopo di oggi \u00e8 prendere una foto e glitcharla.\u00a0Nell'esempio proposto non andr\u00f2 a introdurre un vero e proprio errore nell'immagine ma andr\u00f2 a manipolare direttamente l'array di pixel per ricreare un effetto artistico simil-glitch. Il motivo \u00e8 presto detto: per ottenere un effetto artistico godibile \u00e8 meglio evitare di usare variabile non controllabili.</p> <p>[caption id=\"attachment_1260\" align=\"aligncenter\" width=\"640\"] Immagine di partenza[/caption]</p> <p>L'immagine di partenza non \u00e8 stata scelta in modo casuale: dal momento che useremo la funzione\u00a0brightness(),\u00a0che restituisce il valore della luminosit\u00e0 di un colore, la foto presenta un forte contrasto tra lo sfondo e le sagome nere e la parte centrale illuminata dalle fiamme.</p> <pre><code>/*\n * Glitch di un'immagine con Processing\n * Federico Pepe, 23.09.2017\n * http://blog.federicopepe.com/processing\n */\n\nPImage img;\nint minThreshold = 200;\nint maxThreshold = 255;\n\nvoid setup() {\n  size(1, 1);\n  surface.setResizable(true);\n  img = loadImage(\"fire.jpg\");\n  surface.setSize(img.width, img.height);  \n\n  noStroke();\n  noLoop();\n}\n\nvoid draw() {\n  background(255);\n  image(img, 0, 0);\n  img.loadPixels();\n\n  for (int y = 0; y &lt; height; y++) {\n    for (int x = 0; x &lt; width; x++) {\n\n      if (brightness(img.pixels[y*width+x]) &gt; minThreshold &amp;&amp; brightness(img.pixels[y*width+x]) &lt; maxThreshold) {\n        color c = get(x, y);\n        stroke(c);\n        line(x, y, x, y+2);\n        noFill();\n      }\n    }\n  }\n}\n\nvoid mousePressed() {\n  save(\"export/export.png\");\n}\n</code></pre> <p>Rispetto al codice visto negli ultimi post, ho aggiunto due variabili di soglia\u00a0minTreshold e\u00a0maxThreshold e, all'interno del classico ciclo for che va ad analizzare ogni singolo pixel dell'immagine, introdotto un semplice controllo condizionale che, qualora il risultato sua\u00a0true disegna una linea verticale di 2 pixel dello stesso colore del pixel analizzato.</p> <p></p> <p>Il risultato \u00e8 sicuramente particolare e d'effetto. Potete provare a giocare un po' con i parametri di soglia oppure sostituendo il disegno della linea con un quadrato. Un'altra possibilit\u00e0 potrebbe essere quella di non utilizzare il parametro della\u00a0luminosit\u00e0 ma andare a scegliere la saturazione o il colore stesso.</p> <p>[caption id=\"attachment_1263\" align=\"aligncenter\" width=\"640\"] Lo stesso identico codice di prima ma, in questo esempio, ho sostituito line() con rect()[/caption]</p>","tags":["brightness","glitch","glitch-art","saturation"]},{"location":"introduzione/2016-05-04-ricominciare/","title":"Ricominciamo?","text":"<p>Sono passati un paio di mesi dall\u2019ultimo articolo su Processing che ho pubblicato qui. Come avevo scritto nel post di conclusione della prima parte ho sentito la necessit\u00e0 di fermarmi a riflettere su come continuare questo progetto.</p> <p>I problemi emersi erano principalmente due: quali argomenti trattare e come ristrutturare i contenuti fin qui pubblicati (pi\u00f9 quelli futuri) per renderli pi\u00f9 accessibili. Se devo essere sincero, non sono arrivato a una conclusione definitiva per nessuna delle due questioni. Non avendo mai focalizzato la mia attivit\u00e0 solo sulla scrittura di codice, ho sempre vissuto la programmazione non tanto come un\u2019attivit\u00e0 da portare a termine con consegne e scadenze definite quanto, piuttosto, come uno sviluppo di idee creative o un esercizio di risoluzione di problemi che io stesso mi ponevo (i nomi dei progetti nella mia sketch folder di Processing sono un esempio palese).</p> <p></p> <p>Sulla questione nuovi contenuti la situazione \u00e8 la seguente: mi ritrovo con una (lunga) lista di argomenti che vorrei trattare e, a differenza degli articoli scritti fino ad ora, il problema risiede nel fatto che queste nuove idee non sono consequenziali. Una volta acquisiti i principi di base che abbiamo trattato nei 30 articoli gi\u00e0 pubblicati, il punto ora \u00e8 risolvere problemi apparentemente pi\u00f9 complessi utilizzando le stesse tecniche. Questo, in fondo, \u00e8 il bello della programmazione.</p> <p>Per tutti questi motivi penso che la soluzione giusta sia cercare di sviluppare i nuovi argomenti per \u201ctema\u201d prediligendo una sviluppo pi\u00f9 \u201ca sentimento\u201d e meno ponderato. Per qualcuno, forse, sar\u00e0 pi\u00f9 complicato seguire i nuovi argomenti ma sono sicuro che, prima o dopo, tutti riusciranno a collegare i puntini e a utilizzare le informazioni che si trovano sul blog. Da parte mia, cercher\u00f2 di fare pi\u00f9 riferimenti possibile tra un argomento e l\u2019altro linkando i vari temi.</p> <p>In merito alla riorganizzazione dei contenuti penso che la soluzione pi\u00f9 comoda ed efficace sia trasferire tutto su GitHub. Cos\u2019\u00e8 GitHub? Come funziona? Le risposte a queste due domande richiederebbero una serie di post a parte. La risposta breve \u00e8 che GitHub \u00e8 una piattaforma pensata per condividere codice e incentivare la collaborazione tra programmatori.</p> <p>\u00c8 utile perch\u00e9 chiunque pu\u00f2 collaborare a un progetto suggerendo modifiche, aggiunge e quant\u2019altro. Daniel Shiffman, uno dei miei mentori ed eroi personali, utilizza GitHub in modo davvero incredibile per sviluppare i contenuti che tratta nei suoi video tutorial. Di recente ha realizzato una serie di video dal titolo \u201cGitHub for Poets\u201d che sono visionabili su YouTube. Se capite l\u2019inglese e volete imparare a utilizzare questa piattaforma, vi consiglio caldamente di vedere questi brevi video-tutorial.</p> <p>Uno degli obiettivi delle prossime settimane sar\u00e0 organizzare questa nuova piattaforma e trasferire l\u00ec tutti i contenuti gi\u00e0 pubblicati. Come al solito, per non perdere pezzi, consiglio vivamente di iscrivervi alla newsletter \u201cCreative Coding\u201d per ricevere nella vostra casella e-mail aggiornamenti e nuovi post.</p>"},{"location":"introduzione/introduzione-a-processing/","title":"Introduzione a Processing","text":""},{"location":"introduzione/introduzione-a-processing/#introduzione-a-processing","title":"Introduzione a Processing","text":"<p>Processing \u00e8 un linguaggio di programmazione creato nel 2001 da Ben Fry e Casey Reas al MIT Media Lab di Boston. L'obiettivo di questo progetto era creare un linguaggio che potesse essere usato dagli artisti che si occupano principalmente di arti visuali per sperimentare nuove forme di comunicazione e, data la sua semplicit\u00e0,\u00a0come strumento di apprendimento per avvicinare le persone alla programmazione.</p> <p>Visuale \u00e8, infatti, il termine chiave perch\u00e9, a differenza della maggior parte degli altri linguaggi, Processing permette anche a chi non ha mai scritto una riga di codice di avere un immediato feedback del proprio lavoro sullo schermo del\u00a0computer.</p>"},{"location":"introduzione/introduzione-a-processing/#download-e-installazione-di-processing","title":"Download e installazione di Processing","text":"<p>Il modo pi\u00f9 semplice per cominciare a programmare in Processing \u00e8 scaricare l'IDE,\u00a0acronimo di\u00a0Integrated Development Enviroment, ovvero\u00a0un programma che include al suo interno tutto quello di cui abbiamo bisogno:</p> <ol> <li>l'editor: la finestra in cui scrivere il codice</li> <li>il compiler: che trasforma il nostro codice in programma</li> <li>il\u00a0debugger:\u00a0che ci permette di verificare la presenza di errori</li> </ol> <p>Processing \u00e8\u00a0open source e scaricabile gratuitamente a questo link: ed\u00a0\u00e8\u00a0compatibile con i sistemi\u00a0Mac, Windows e Linux. </p> <p>Prima di procedere con il download vi verr\u00e0 chiesto di effettuare una donazione non obbligatoria per sostenere la Processing Foundation e lo sviluppo futuro di Processing.</p>"},{"location":"introduzione/introduzione-a-processing/#interfaccia","title":"Interfaccia","text":"<p>L'interfaccia \u00e8 molto semplice e, nel corso degli anni, non \u00e8 cambiata molto. In alto troviamo i pulsanti\u00a0Run  e Stop  che utilizzeremo per avviare e fermare i nostri sketch \u2013\u00a0cos\u00ec vengono chiamati i programmi realizzati in Processing. </p> <p>La parte centrale con sfondo bianco \u00e8 il nostro editor dove andremo a scrivere il nostro codice mentre la sezione in basso con sfondo nero \u00e8 la console che ha un duplice scopo: segnalarci eventuali errori nel codice oppure essere usata per inserire dei messaggi che ci possono aiutare a comprendere il funzionamento del nostro programma.</p>"},{"location":"introduzione/introduzione-a-processing/#algoritmo-e-sintassi","title":"Algoritmo e sintassi","text":"<p>Algoritmo e sintassi sono due parole chiave che ritorneranno spesso nelle prossime lezioni. La prima indica molto semplicemente un insieme di istruzioni eseguite in sequenza ed \u00e8 uno dei concetti di base della programmazione. I computer, infatti, non sono macchine intelligenti e hanno bisogno di ricevere comandi che sono in grado di interpretare: dobbiamo tenere bene a mente che in fase di compilazione, quando, cio\u00e8, il nostro codice viene eseguito premendo sul pulsante Run , le linee di codice vengono processate in sequenza una alla volta e, in mancanza di errori, il programma viene eseguito\u00a0dall'inizio alla fine.</p> <p>Il concetto di algoritmo \u00e8 comunque abbastanza semplice da interiorizzare; in fondo la nostra vita \u00e8 costellata da istruzioni che siamo abituati a seguire in un determinato ordine: basti pensare alle istruzioni di un qualsiasi libro o sito di ricette oppure alle indicazioni che riceviamo dal nostro navigatore quando guidiamo. La nostra fortuna \u00e8 che siamo anche abituati a generare algoritmi\u00a0ogni volta che\u00a0ci troviamo a spiegare qualcosa. Con i computer dobbiamo solo imparare a essere il pi\u00f9 dettagliati e precisi possibile.</p> <p>La Sintassi \u00e8 la grammatica del linguaggio che useremo e, come ben sappiamo, ogni lingua ha le sue regole da rispettare. Per esempio sar\u00e0 importante separare\u00a0ogni istruzione utilizzando il punto e virgola oppure racchiudere i blocchi di codice tra parentesi graffe.\u00a0Non spaventatevi, verr\u00e0 spiegato tutto nel dettaglio a tempo debito; se, comunque, avete voglia di dare un'occhiata al dizionario di Processing, vi rimando alla\u00a0Language Reference\u00a0sempre disponibile sul sito e\u00a0accessibile anche nell'IDE dal menu <code>Help &gt; Reference</code>.</p>"},{"location":"introduzione/introduzione-a-processing/#esempi","title":"Esempi","text":"<p>Prima di cominciare a scrivere le prime linee di codice, \u00e8 importante capire quali sono le potenzialit\u00e0 di questo linguaggio. Se avete gi\u00e0 installato l'IDE sul vostro computer,  attraverso il menu <code>File &gt; Examples</code>, potete navigare una serie di esempi suddivisi\u00a0in varie categorie: Basics, Topics, Demos, Books, Libraries e Contributed Libraries.</p> <p>Oltre a questi, vi\u00a0segnalo alcuni\u00a0dei progetti interessanti realizzati con Processing che, all'inizio del mio percorso, mi hanno ispirato a imparare a sviluppare progetti con questo linguaggio di programmazione.</p>"},{"location":"introduzione/introduzione-a-processing/#kepler-exoplanet-candidate-by-jer-thorp","title":"Kepler Exoplanet Candidate by Jer Thorp","text":""},{"location":"introduzione/introduzione-a-processing/#strata-3-by-quayola","title":"Strata #3 by Quayola","text":""},{"location":"introduzione/introduzione-a-processing/#unnamed-sound-sculpture-by-daniel-franke-cedric-kiefer","title":"Unnamed Sound Sculpture by\u00a0Daniel Franke &amp; Cedric Kiefer","text":""},{"location":"introduzione/introduzione-a-processing/#risorse","title":"Risorse","text":"<p>Esistono numerose risorse per imparare a programmare in Processing, ma la maggior parte di esse sono\u00a0in inglese. Questo \u00e8 il motivo principale che mi ha spinto a\u00a0tenere corsi in Italia e a dedicare\u00a0una sezione del\u00a0mio blog\u00a0all'insegnamento di Processing.</p> <p>Per completezza, segnalo i libri, i video e le risorse web disponibili.</p>"},{"location":"introduzione/introduzione-a-processing/#libri","title":"Libri","text":"<p>Ho gi\u00e0 citato alcuni libri nella sezione riconoscimenti dell'home page. Ci sono, poi, numerosi altri libri disponibili ma vi rimando direttamente alla sezione dedicata sul sito di Processing.</p>"},{"location":"introduzione/introduzione-a-processing/#video","title":"Video","text":"<ul> <li>Learning Processing di Daniel Shiffman</li> <li>Intro to Processing for Data Viz di Matthew Epler</li> <li>Fun Programming di Abe Pazos</li> <li>Creative Coding Essentials by Tim Rodenbroeker</li> <li>Coding for beginners: learn coding by creating art by Jerome Herr</li> </ul>"},{"location":"introduzione/introduzione-a-processing/#web-e-community","title":"Web e community","text":"<ul> <li>Processing Tutorial</li> <li>Processing Forum</li> <li>Open Processing</li> </ul>"},{"location":"introduzione/le-novita-di-processing-3/","title":"Le novit\u00e0 di Processing 3","text":""},{"location":"introduzione/le-novita-di-processing-3/#le-novita-di-processing-3","title":"Le novit\u00e0 di Processing 3","text":"<p>Attenzione</p> <p>Processing \u00e8 un linguaggio di programmazione in costante evoluzione. Fate sempre riferimento al sito ufficiale www.processing.org per verificare qual \u00e8 l'ultima versione disponibile.</p> <p>Il 30 settembre 2015 \u00e8 stata rilasciata una nuova major release di Processing: la versione 3.\u00a0Prendendo spunto dal video ufficiale con cui Daniel Shiffman illustra le principali novit\u00e0 del software, ho deciso di scrivere questo post, soprattutto per chi ha difficolt\u00e0 con l'inglese.</p>"},{"location":"introduzione/le-novita-di-processing-3/#nuova-icona-nuovo-editor","title":"Nuova icona, nuovo editor","text":"<p>Una volta scaricato e installato sul vostro computer\u00a0noterete subito che Processing 3 ha una nuova icona. Le novit\u00e0 grafiche non sono, per\u00f2, finite qui: quando avviate il programma comparir\u00e0 un welcome screen che, la prima volta, vi consiglier\u00e0 di creare una nuova cartella\u00a0sketchbook dove tenere i vostri sketch. \u00c8 consigliabile tenere separati i programmi realizzati per la versione 2 e la versione 3 perch\u00e9, a causa di alcuni cambiamenti nel linguaggio, alcuni vecchi sketch potrebbero non funzionare.</p> <p></p> <p>Oltre alla nuova icona e all'inedito welcome screen, una delle prime cose che notiamo \u00e8 il design dell'editor che \u00e8 stato completamente rivisto: anche in questa finestra troviamo delle nuove icone e, finalmente, i numeri delle linee di codice a sinistra oltre a delle nuove tab in basso.</p> <p></p>"},{"location":"introduzione/le-novita-di-processing-3/#error-checking-e-warning","title":"Error Checking e Warning","text":"<p>Il nuovo sistema di error checking sar\u00e0 di grande aiuto soprattutto per chi sta iniziando a programmare:\u00a0i messaggi di errore sono stati rivisti in modo da essere pi\u00f9 \"leggibili\". Di default verranno visualizzati nella console gli errori\u00a0mentre digitiamo il codice invece che alla pressione del comando Run come accadeva nella versione precedente.</p> <p>In questo modo sar\u00e0 molto pi\u00f9 difficile dimenticarsi un punto e virgola\u00a0alla fine di un'istruzione o una parentesi. I programmatori pi\u00f9 esperti possono disabilitare questa opzione andando nel pannello delle preferenze e deselezionando\u00a0Continuously check for errors.</p> <p>Nel caso in cui nel nostro codice ci fosse pi\u00f9 di un errore, cliccando sulla nuova tab\u00a0Errors,\u00a0presente nella parte inferiore della finestra,abbiamo una panoramica di tutti i problemi presenti nel nostro codice.</p> <p>Un'altra novit\u00e0 sono i Warning: non si tratta di veri e propri errori ma di messaggi che ci avvisano che nel nostro codice c'\u00e8 qualcosa di strano. Ad esempio, se creiamo e inizializziamo una variabile che, per\u00f2, non usiamo da nessuna parte nel nostro programma, ci verr\u00e0 restituito un messaggio di avviso. A differenza degli errori, evidenziati in rosso, i warning vengono sottolineati in\u00a0giallo.</p>"},{"location":"introduzione/le-novita-di-processing-3/#code-completion","title":"Code completion","text":"<p>Questa opzione non \u00e8 attiva di default ma \u00e8 selezionabile nelle preferenze: grazie a essa, premendo Ctrl+spazio\u00a0l'editor ci\u00a0dar\u00e0 dei suggerimenti su come completare il nostro codice. Se utilizzate OS X, verificate che la combinazione Ctrl+spazio sia libera perch\u00e9 su alcuni computer potrebbe lanciare la ricerca Spotlight_._</p> <p></p>"},{"location":"introduzione/le-novita-di-processing-3/#tweak","title":"Tweak","text":"<p>Oltre alla modalit\u00e0\u00a0Run, in Processing 3 \u00e8 stata aggiunta la modalit\u00e0 Tweak.\u00a0Una volta lanciato il nostro sketch in questa modalit\u00e0 (su Mac la scorciatoia \u00e8 \u21e7\u2318T), possiamo modificare \"in diretta\" alcuni parametri del nostro sketch e avere\u00a0un feedback immediato senza\u00a0interrompere il programma.</p> <p>Una volta stoppata la modalit\u00e0 tweak, l'editor ci chieder\u00e0 se vogliamo mantenere le modifiche apportate al nostro codice oppure se vogliamo tornare alla versione originale.</p>"},{"location":"introduzione/le-novita-di-processing-3/#debugger","title":"Debugger","text":"<p>Anche questa novit\u00e0 \u00e8 mutuata da altri linguaggi di programmazione: attivando il debugger, il pulsante a forma di insetto presente in alto a destra, possiamo far girare il nostro programma una linea alla volta\u00a0verificando, dunque, in quali punti viene generato un errore. Per capire meglio come sfruttare questa novit\u00e0, consiglio questo video, sempre realizzato da Dan che ne illustra il funzionamento nel dettaglio.</p>"},{"location":"introduzione/le-novita-di-processing-3/#opengl-fullscreen-e-pixeldensity","title":"OpenGL, fullScreen() e pixelDensity()","text":"<p>Prima di parlare di due nuove funzioni molto interessanti sottolineo che gli sviluppatori hanno lavorato molto per rendere Processing 3 molto pi\u00f9 veloce rispetto alla versione precedente. Questo risultato \u00e8 dovuto principalmente\u00a0alla nuova engine di rendering che non si basa pi\u00f9 su PApplet, una tecnologia ormai in disuso, ma su OpenGL.</p> <p>Venendo alle nuove funzioni, fullScreen()\u00a0sostituisce size(displayWidth, displayHeight) e ci permette di far girare i nostri sketch a pieno schermo. Questa nuova funzione, per\u00f2, non fa soltanto questo: se abbiamo\u00a0uno schermo collegato possiamo passare il parametro fullScreen(1) oppure fullScreen(2) per decidere su quale display verr\u00e0 presentato il nostro programma.</p> <p>Se, invece, abbiamo pi\u00f9\u00a0schermi collegati al computer con fullScreen(SPAN) lo sketch si adatter\u00e0 automaticamente al setup multidisplay occupando tutto lo spazio disponibile. Una cosa importante da sottolineare \u00e8, grazie a questa nuova funzione, size() non accetta pi\u00f9 variabili ma solo parametri hard-coded.</p> <p>Se siete possessori di un computer con schermo Retina, la nuova funzione pixelDensity() vi piacer\u00e0 molto: grazie a essa possiamo aumentare la densit\u00e0 di pixel del nostro sketch per adattarlo\u00a0all'alta risoluzione del nostro schermo. La differenza \u00e8 davvero notevole!</p>"},{"location":"introduzione/le-novita-di-processing-3/#contribution-manager","title":"Contribution Manager","text":"<p>Se utilizzate librerie o tool aggiuntivi nei vostri sketch, il nuovo Contribution Manager\u00a0sar\u00e0 una novit\u00e0 che vi piacer\u00e0 parecchio. In questa nuova finestra potrete cercare,\u00a0installare, disinstallare e aggiornare tutti gli strumenti aggiuntivi che utilizzate e verificarne la compatibilit\u00e0 con la versione di Processing che state utilizzando.</p>"},{"location":"introduzione/le-novita-di-processing-3/#tutte-le-altre-novita","title":"Tutte le altre novit\u00e0","text":"<p>Come anticipavo all'inizio del post, lo scopo di questo articolo era fare una panoramica sulle principali novit\u00e0 introdotte in quest'ultima versione di Processing. Se siete interessati a scoprire nel dettaglio quali sono tutte le novit\u00e0 introdotte in quest'ultima versione, vi consiglio di visitare\u00a0questa pagina su GitHub.</p>"},{"location":"introduzione/programmazione-creative-coding-e-arte-digitale/","title":"Programmazione, creative coding e arte digitale","text":""},{"location":"introduzione/programmazione-creative-coding-e-arte-digitale/#programmazione-creative-coding-e-arte-digitale","title":"Programmazione, Creative Coding e Arte Digitale","text":"<p>Una delle caratteristiche principali degli artisti \u00e8 da sempre quella di dare forma alle proprie visioni\u00a0attraverso strumenti innovativi\u00a0nel tentativo di scardinare lo\u00a0status quo. La manipolazione di immagini, forme, colori e suoni ha contribuito alla creazione di\u00a0nuovi linguaggi espressivi con cui dare forma alle diverse\u00a0sfaccettature della realt\u00e0.</p> <p>Con la rivoluzione digitale e la diffusione dei computer, gli artisti hanno oggi a disposizione un numero sempre maggiore di strumenti per i loro progetti\u00a0e questo ha\u00a0contribuito a dare un forte impulso creativo\u00a0all'arte contemporanea.</p> <p>Uno dei problemi principali che i creativi\u00a0si sono trovati ad affrontare \u00e8 che gran parte dei software a loro disposizione sono stati sviluppati da programmatori e ingegneri, spesso senza alcun background o interesse in ambito artistico. Fortunatamente, per\u00f2, negli ultimi anni\u00a0il muro che separa chi crea gli strumenti da chi li utilizza si \u00e8 assottigliato parecchio anche grazie alla nascita della figura dell'artista-programmatore o creative coder:\u00a0un professionista con competenze sia in ambito artistico che informatico in grado\u00a0di sviluppare i propri strumenti di lavoro, personalizzandoli e adattandoli alle proprie esigenze.</p> <p>Il presupposto di base del\u00a0Creative Coding \u00e8 proprio questo:\u00a0eliminare\u00a0la barriera tra informatica e arte per poter, da un lato, realizzare un numero sempre maggiore di strumenti per\u00a0aiutare gli artisti a trasmettere le loro idee, e dall'altro creare opere d'arte generate da algoritmi sviluppati da persone ma processati da un computer, quella che viene chiamata arte generativa.</p> <p>Dato il mio interesse sia in ambito informatico che artistico, ho cominciato ad appassionarmi al creative coding gi\u00e0 da qualche anno. Solo negli ultimi mesi, per\u00f2, ho notato\u00a0che in Italia non c'\u00e8 nessuna realt\u00e0 che sta promuovendo iniziative in questo ambito mentre all'estero si tengono regolarmente festival, rassegne, workshop e, in alcuni casi, si possono trovare percorsi di laurea dedicati nelle\u00a0universit\u00e0.</p> <p>Questo post vuole essere un'introduzione a un progetto che ho deciso di portare avanti nei prossimi mesi: diffondere la cultura del creative coding attraverso un corso facilmente accessibile che spieghi le basi della programmazione. Il linguaggio che ho scelto \u00e8 Processing: uno dei pi\u00f9 diffusi in questo ambito e, nel contempo, uno dei pi\u00f9 semplici da imparare.</p> <p>Se siete interessati a\u00a0rimanere aggiornati sul creative coding e sugli sviluppi futuri di questo progetto, potete iscrivervi alla newsletter dedicata cliccando qui.</p>"},{"location":"math/2016-05-22-modulo-e-probabilita/","title":"Modulo e probabilit\u00e0","text":"<p>L'ultima volta che abbiamo\u00a0parlato di\u00a0operatori matematici \u00e8 stato un po' di tempo fa. Prima di procedere con nuovi argomenti, per\u00f2, \u00e8 necessario studiare ancora\u00a0un paio di cose legate al mondo della matematica: con il post di oggi approfondiremo\u00a0l'operatore\u00a0modulo e scopriremo\u00a0come effettuare un semplice\u00a0calcolo di probabilit\u00e0\u00a0nei nostri sketch.</p>","tags":["framecount","framerate","modulo","probabilita"]},{"location":"math/2016-05-22-modulo-e-probabilita/#modulo","title":"Modulo","text":"<p>L'operatore modulo \u2013 che viene indicato dal simbolo di percentuale % \u2013\u00a0si trova in tutti i linguaggi di programmazione e ci aiuta a esprimere una funzione matematica molto semplice che conosciamo da quando studiamo le divisioni alle elementari: il calcolo del resto.</p> <p>Possiamo utilizzare questo operatore sia con numeri o variabili di tipo\u00a0integer o\u00a0float:</p> <p>println(10/5); println(10%5);</p> <p>Queste due linee di codice mostreranno nella console due risultati differenti: la prima, infatti, \u00e8 una normale divisione: 10 diviso 5 restituisce 2. La seconda linea restituir\u00e0 0 perch\u00e9 la divisione non ha resto.</p> <p>println(11/5); println(11%5);</p> <p>In questo secondo esempio, invece, la prima riga di codice ci restituir\u00e0 ancora 2 mentre la seconda dar\u00e0 come risultato 1.</p> <p>Perch\u00e9 l'operatore modulo \u00e8\u00a0utile ai fini della programmazione? La risposta \u00e8 abbastanza semplice: se usato in combinazione con il controllo del frame rate \u2013 ovvero il numero di volte al secondo che la funzione draw() ridisegna lo schermo \u2013 possiamo dare un ritmo al nostro programma.</p>","tags":["framecount","framerate","modulo","probabilita"]},{"location":"math/2016-05-22-modulo-e-probabilita/#framerate-e-framecount","title":"frameRate() e frameCount","text":"<p>La funzione frameRate()\u00a0posizionata all'interno di\u00a0setup() imposta il numero di frame per secondo (fps) a cui girer\u00e0 il nostro programma. Ricordo che di default Processing lavora a 60fps. Richiamando la variabile di sistema\u00a0frameCount, invece, ci verr\u00e0 restituito il numero di frame che sono trascorsi dall'avvio del programma.</p> <pre><code>/*\n * Esempio dell'utilizzo di frameRate() e frameCount.\n * In questo esempio, imposto il programma affinch\u00e9 giri a 30fps\n * e visualizzo in console il numero di frame che sono trascorsi\n * dall'avvio.\n*/\nvoid setup() {\n  frameRate(30);\n}\n\nvoid draw() {\n  println(frameCount);\n}\n</code></pre> <p>Mettiamo insieme quanto visto finora e facciamo in modo che il colore di sfondo del nostro sketch cambi ogni 30 frame (ovvero ogni secondo).</p> <pre><code> /*\n * Modulo, frameRate e frameCount\n * In questo programma impostiamo il frameRate a 30fps\n * e cambiamo colore di sfondo una volta ogni secondo.\n*/\n\nvoid setup() {\n  frameRate(30);\n}\n\nvoid draw() {\n  if(frameCount%30 == 0) {\n    background(255, 0, 0);\n  } else {\n    background(255);\n  }\n}\nSign up for free \n</code></pre> <p>Se volessimo modificare il programma in modo che il cambio\u00a0avvenga ogni 2 secondi, sarebbe sufficiente modificare la riga numero 12 cos\u00ec: <code>if(frameCount%60 == 0)</code></p>","tags":["framecount","framerate","modulo","probabilita"]},{"location":"math/2016-05-22-modulo-e-probabilita/#probabilita","title":"Probabilit\u00e0","text":"<p>In programmazione e, in particolare, quando si tratta di creative coding,\u00a0pu\u00f2 essere utile implementare un semplice calcolo di probabilit\u00e0 per stabilire quando far eseguire una certa porzione di codice. Come si fa a stabilire quante possibilit\u00e0 ci sono che un dato evento avvenga? Bisogna dividere il numero di volte che una cosa possa accadere per il numero totale di probabilit\u00e0.</p> <p>Quindi, per fare un esempio, quante possibilit\u00e0 abbiamo che lanciando una moneta esca testa? Su una moneta ci sono due facce: una testa e una croce, quindi 1/2 = 50%.</p> <p>Per simulare un sistema casuale ci aiutiamo con la funzione random(), di cui abbiamo gi\u00e0 parlato in passato. Modifico il programma\u00a0precedente facendo s\u00ec che il cambio di colore di sfondo avvenga con una probabilit\u00e0 del 20%:</p> <pre><code>/*\n * Calcolo delle probabilit\u00e0\n*/\n\nvoid setup() {\n  frameRate(30);\n}\n\nvoid draw() {\n  float prob = 0.2;\n  float random = random(1);\n  if(random &lt; prob) {\n    background(255, 0, 0);\n  } else {\n    background(255);\n  }\n}\n</code></pre>","tags":["framecount","framerate","modulo","probabilita"]},{"location":"math/2016-06-01-random-vs-perlin-noise/","title":"Random e Perlin Noise","text":"<p>In passato abbiamo utilizzato la funzione random() per rendere pi\u00f9 interessanti i nostri sketch. Per fare un breve ripasso: vi ricordo che tale funzione accetta uno o due argomenti e\u00a0restituisce sempre un numero\u00a0casuale di tipo float.\u00a0<code>random(10);</code>\u00a0dar\u00e0 come risultato un numero compreso tra 0 e 10 mentre\u00a0<code>random(5, 10);</code> restituir\u00e0 un valore casuale compreso tra un minimo (5) e un massimo (10).</p> <p>Random \u00e8 una funzione bellissima\u00a0perch\u00e9,\u00a0se usata nel modo giusto, pu\u00f2 generare risultati davvero particolari\u00a0senza complicare troppo il codice. Il problema a cui andiamo incontro, per\u00f2, \u00e8 che utilizzando questa funzione\u00a0perdiamo il controllo del nostro sketch perch\u00e9 ci affidiamo completamente alla casualit\u00e0: spesso i risultati possono sembrare molto caotici e privi di senso.</p> <p>Ecco che in alcuni casi la funzione\u00a0noise()\u00a0ci pu\u00f2 aiutare a creare una casualit\u00e0 \"controllata\".</p>","tags":["noise","perlin-noise","random"]},{"location":"math/2016-06-01-random-vs-perlin-noise/#cose-il-perlin-noise","title":"Cos'\u00e8 il Perlin Noise?","text":"<p>Senza andare troppo nel dettaglio, il Perlin Noise prende il nome da Ken Perlin, un professore di informatica della New York University che negli anni '80 ha sviluppato questa\u00a0tipo di rumore\u00a0per generare texture in modo procedurale. I risultati della sua ricerca hanno reso possibile, nel campo della computer graphics, la rappresentazione della complessit\u00e0 della natura attraverso risultati organici generati da un algoritmo.</p> <p>Aggiornamento 2.06.2016: se siete interessati a capire meglio e in modo davvero approfondito come funziona il Perlin Noise, consiglio la lettura di questo articolo (in inglese).</p> <p>Nel manuale di Processing si trova\u00a0un'informazione molto importante in merito a questa funzione:</p> <p>In contrast to the random() function, Perlin noise is defined in an infinite n-dimensional space, in which each pair of coordinates corresponds to a fixed semi-random value (fixed only for the lifespan of the program). The resulting value will always be between 0.0 and 1.0.</p> <p>A differenza della funzione random(), noise() restituir\u00e0 un risultato sempre compreso tra 0 e 1.\u00a0Teniamo a mente questa informazione e facciamo un\u00a0esempio pratico.</p>","tags":["noise","perlin-noise","random"]},{"location":"math/2016-06-01-random-vs-perlin-noise/#random","title":"Random","text":"<pre><code>// Random e Perlin Noise\n\nvoid setup() {\n  size(500, 500);\n}\n\nvoid draw() {\n  background(255);\n  float x = random(width);\n  ellipse(x, height/2, 50, 50);\n}\n</code></pre> <p>Questo programma mostrer\u00e0 un cerchio con posizione x totalmente casuale e y pari alla met\u00e0 dell'altezza della finestra. Nota:\u00a0Possiamo ridurre la velocit\u00e0 di esecuzione con la funzione frameRate().</p> <p>Ecco l'output grafico in formato GIF:</p> <p></p> <p>Prima di passare all'esempio con la funzione\u00a0noise()\u00a0\u00e8 necessario fare un'altra precisazione. Entrambe le funzioni che stiamo analizzando sono strettamente legate al concetto di tempo: random() genera un nuovo valore casuale ogni volta che viene chiamata la funzione quindi, nell'esempio precedente, 60 volte al secondo; noise(), invece,\u00a0riesce a generare risultati organici perch\u00e9 ciascun valore\u00a0\u00e8 legato temporalmente a quello precedente e al successivo.</p> <p>Possiamo simulare lo scorrimento del tempo utilizzando una variabile che incrementiamo a ogni ciclo di draw; pi\u00f9 piccolo sar\u00e0 l'incremento, maggiore sar\u00e0 la vicinanza dei valori restituiti dalla funzione.</p>","tags":["noise","perlin-noise","random"]},{"location":"math/2016-06-01-random-vs-perlin-noise/#noise","title":"Noise","text":"<pre><code>// Random e Perlin Noise\n\n// Creiamo una variabile per simulare l'avanzamento del tempo\nfloat time; \n\nvoid setup() {\n  size(500, 500);\n}\n\nvoid draw() {\n  background(255);\n  /*\n   * Dal momento che noise restituisce un valore compreso tra 0 e 1, moltiplico\n   * il numero per la larghezza della finestra per ottenere un valore compreso tra\n   * 0 e 500\n  */\n  float x = noise(time) * width;\n  ellipse(x, height/2, 50, 50);\n  // A ogni ciclo draw, aumentiamo la variabile di tempo\n  time += 0.05;\n}\n</code></pre> <p>Per rendere l'esempio il pi\u00f9 chiaro possibile ed evitare di rendere questo post troppo verboso, ho inserito diversi commenti nel codice.\u00a0Come prima, vi mostro l'output grafico in formato GIF:</p> <p></p> <p>Grazie alle due\u00a0immagini animato, \u00e8 semplice\u00a0notare quanto\u00a0i movimenti del secondo cerchio siano pi\u00f9 organici rispetto al precedente. Se volete fare degli esperimenti partendo dal mio esempio, vi consiglio di modificare l'incremento della variabile time.</p> <p>Cosa succede se scriviamo <code>time += 1;</code> oppure <code>time += 0.01;</code>?</p>","tags":["noise","perlin-noise","random"]},{"location":"math/2016-07-07-altri-esempi-con-la-funzione-noise/","title":"Altri esempi con la funzione noise()","text":"<p>Nell'ultimo post abbiamo analizzato la differenza tra la funzione\u00a0random() e\u00a0noise(). La prima, vi ricordo, restituisce dei valori assolutamente casuali che dipendono dai parametri che passiamo alla funzione; la seconda, invece, ci permette di avere una\u00a0sorta di\u00a0casualit\u00e0 controllata.</p> <p>I valori che vengono restituiti dalla funzione noise()\u00a0hanno due caratteristiche fondamentali: sono correlati tra loro e hanno sempre un valore compreso tra 0 e 1.</p> <p>Maggiore sar\u00e0 la vicinanza tra i parametri che passiamo alla funzione, maggiore sar\u00e0, ovviamente, la correlazione tra i valori restituiti in output. \u00c8 possibile verificare quanto ho appena detto utilizzando un paio di righe di codice:</p> <p>println(noise(100)); println(noise(100.01));</p> <p>Questo il risultato visualizzato in console:</p> <p>0.3187103 0.318551</p> <p>I risultati sono davvero molto vicini tra loro. Proviamo ad aumentare la distanza tra i due valori:</p> <p>println(noise(100)); println(noise(101));</p> <p>Ora\u00a0la correlazione tra i due output\u00a0\u00e8\u00a0meno evidente:</p> <p>0.56860673 0.48344862</p> <p>Aumentando ulterioremente la distanza tra i parametri di input, avremo risultati in output sempre pi\u00f9 simili a quelli ottenuti dalla funzione random():</p> <p>println(\"Noise:\"); println(noise(100)); println(noise(500)); println(\"Random:\"); println(random(1)); println(random(1));</p> <p>Pu\u00f2 generare risultati simili a questo:</p> <p>Noise: 0.16914257 0.68422705 Random: 0.48342746 0.89731866</p>","tags":["beginshape","endshape","noise","vertex"]},{"location":"math/2016-07-07-altri-esempi-con-la-funzione-noise/#creare-un-grafico-di-valori-restituiti-da-noise","title":"Creare un grafico di valori restituiti da noise()","text":"<p>Il primo esempio che voglio realizzare oggi \u00e8 un grafico che mi rappresenti, per valori di x crescenti, un valore y restituito da noise().</p> <p>Ecco il codice:</p> <pre><code>/*\n * Noise examples 1\n * by Federico Pepe\n*/\n\nfloat xoff = 0;\nfloat increment = 0.02;\n\nvoid setup() {\n  size(500, 500);\n  background(255);\n  noFill();\n  noLoop();\n}\n\nvoid draw() {\n  beginShape();\n  for(int x = 0; x &lt;= width; x++) {\n    stroke(0);\n    vertex(x, noise(xoff)*height);\n    xoff += increment;\n  }\n  endShape();\n}\n</code></pre> <p>Analizziamo velocemente il codice riportato qui sopra: per prima cosa creo le variabile di tipo float xoff e increment, dopodich\u00e9\u00a0all'interno di setup() imposto la grandezza della finestra, il colore di sfondo, imposto che non ci sia nessun colore di riempimento, con noFill(), e che il programma non vada in loo \u00a0una volta avviato, con\u00a0noLoop().</p> <p>In draw() utilizzo una funzione che non abbiamo ancora visto: beginShape(). Questa funzione\u00a0dice a Processing che vogliamo disegnare una forma complessa che avr\u00e0 un'insieme di vertici \u2013 aggiunti con la funzione vertex() \u2013 che dovranno essere uniti in ordine gli uni agli altri finch\u00e9 non chiuderemo la forma con\u00a0endShape().</p> <p>Perch\u00e9 ho deciso di usare questa funzione?\u00a0Perch\u00e9 cos\u00ec, estraendo per valori di x crescenti dei valori y generati dalla funzione noise(), tutti i punti saranno gi\u00e0 collegati tra loro\u00a0e genereranno un grafico come quello rappresentato qui sotto:</p> <p></p>","tags":["beginshape","endshape","noise","vertex"]},{"location":"math/2016-07-07-altri-esempi-con-la-funzione-noise/#animiamo-il-grafico","title":"Animiamo il grafico","text":"<pre><code>/*\n * Noise example 2\n * by Federico Pepe\n*/\n\nfloat xoff;\nfloat increment = 0.015;\nfloat startPoint;\n\nvoid setup() {\n  size(500, 500);\n  background(255);\n  noFill();\n}\n\nvoid draw() {\n  background(255);\n  xoff = startPoint;\n  beginShape();\n  for(int x = 0; x &lt;= width; x++) {\n    stroke(0);\n    vertex(x, noise(xoff)*height);\n    xoff += increment;\n  }\n  endShape();\n  startPoint += increment;\n}\n</code></pre> <p>Con una veloce modifica al codice \u00e8 possibile animare il grafico: per prima cosa eliminiamo il noLoop() e aggiungiamo una variabile per stabilire di volta in volta quale sar\u00e0 il nostro\u00a0punto di inizio: startPoint. Ovviamente, al termine del loop, dobbiamo incrementare quest'ultima variabile in modo da avere lo scorrimento orizzontale.</p> <p>Ecco il risultato (in formato gif):</p> <p></p>","tags":["beginshape","endshape","noise","vertex"]},{"location":"math/2016-07-12-2d-perlin-noise/","title":"2D Perlin Noise","text":"<p>Nei due post precedenti abbiamo sempre\u00a0usato la funzione noise() in modo mono dimensionale.\u00a0\u00c8 arrivato il momento di fare un passo in avanti e aggiungere la seconda dimensione.</p>","tags":["2d","loadpixels","noise","perlin-noise","pixels","texture","updatepixels"]},{"location":"math/2016-07-12-2d-perlin-noise/#ripasso-1d-perlin-noise","title":"Ripasso: 1D Perlin Noise","text":"<p>Quando parliamo di Perlin Noise mono dimensionale dobbiamo immaginare\u00a0i valori su una linea temporale orizzontale; quando noi chiediamo alla funzione di restituirci un determinato valore di noise, tale valore\u00a0sar\u00e0\u00a0correlato a quello precedente e a quello successivo. Nell'immagine viene rappresentato il valore di noise con parametro xOff pari a 3.32. Come nel post precedente, l'incremento che ho usato per generare l'immagine \u00e8 0.02.</p> <p></p>","tags":["2d","loadpixels","noise","perlin-noise","pixels","texture","updatepixels"]},{"location":"math/2016-07-12-2d-perlin-noise/#2d-perlin-noise","title":"2D Perlin Noise","text":"<p>Quando aggiungiamo una dimensione, invece, dobbiamo pensare a una griglia i cui valori sono correlati tra loro sia sull'asse delle x che su quello delle y.</p> <p></p> <p>Come si evince dall'immagine, la situazione diventa pi\u00f9 complicata perch\u00e9 se analizziamo singolarmente i punti centrali rosso o blu intuiamo facilmente\u00a0la correlazione con i punti che li circondano. Se li consideriamo entrambi contemporaneamente, invece, notiamo subito come ci siano dei\u00a0punti in comune\u00a0che dovranno essere\u00a0a loro volta\u00a0correlati tra loro.</p> <p>Questo \u00e8 un esempio molto semplificato: provate a immaginare se ciascuno dei punti disegnati fosse un pixel!</p>","tags":["2d","loadpixels","noise","perlin-noise","pixels","texture","updatepixels"]},{"location":"math/2016-07-12-2d-perlin-noise/#generiamo-una-texture","title":"Generiamo una texture","text":"<p>\u00c8 arrivato il momento di sporcarsi le mani e scrivere un po' di codice: lo scopo del programma di oggi \u00e8 generare una texture con Processing utilizzando Perlin Noise bidimensionale.</p> <p>Partiamo da un'analisi del risultato finale per capire tutti i passaggi e il codice che ci serve:</p> <p></p> <p>Per\u00a0generare la texture dobbiamo prendere ciascun pixel della nostra finestra facendo in modo che il suo colore sia correlato ai pixel vicini: \u00e8 facile notare come ci siano delle aree pi\u00f9 scure e altre pi\u00f9 chiare e che, in generale, la texture generata sia\u00a0uniforme.</p> <p>Per farvi capire la differenza,\u00a0nell'immagine qui sotto ho sostituito nel programma la funzione noise() con random():</p> <p></p> <p>Sostituendo la funzione noise() con random() il risultato \u00e8 molto differente.</p> <p>Per lavorare con i pixel utilizzeremo le funzioni\u00a0loadPixels()\u00a0e\u00a0updatePixels() che avremo modo di analizzare in modo approfondito in futuro. Per il momento vi basti sapere che la prima funzione carica tutti i pixel della finestra in un array chiamato pixels[] e che la seconda ricarica i pixel nella finestra dopo che sono stati modificati.</p> <p>Un altro punto molto importante \u00e8 sapere che, bench\u00e9 i pixel presenti in una finestra siano un insieme di righe e colonne, nell'array pixels[] vengono salvati con numero progressivo.</p> <p>Per modificare il colore di ciascun pixel della finestra abbiamo\u00a0bisogno di due cicli for annidati: uno per i valori di x, l'altro per quelli di y.\u00a0La funzione noise() entra in gioco proprio in questa fase: attraverso due variabili \u2013\u00a0xOff e yOff\u00a0\u2013 imposteremo\u00a0il colore di ciascun pixel.</p> <p>Ecco il codice finale:</p> <pre><code>/*\n * Texture con Perlin Noise 2D\n * by Federico Pepe\n *\n */\n\nfloat increment = 0.015;\n\nvoid setup() {\n  size(500, 500);\n}\n\nvoid draw() {\n  // Carico i pixel della finestra\n  loadPixels();\n  float xOff = 0;\n  for(int x = 0; x &lt; width; x++) {\n    xOff += increment;\n    float yOff = 0;\n    for (int y = 0; y &lt; height; y++) {\n      yOff += increment;\n      // Ottengo il valore noise passando le variabili xOff e yOff.\n      float bright = noise(xOff, yOff) * 255;\n      // Riassegno a ogni pixel il nuovo colore\n      pixels[x+y*width] = color(bright);\n    }\n  }\n  // Aggiorno tutti i pixel della finestra\n  updatePixels();\n}\n</code></pre> <p>Domanda:\u00a0perch\u00e9 non ho inizializzato le due variabili xOff e yOff all'inizio del programma? Cosa succede se\u00a0non reimposto a 0 la variabile yOff a ogni ciclo?</p> <p>Per aggiungere l'interazione con l'utente,\u00a0aggiungiamo\u00a0subito dopo\u00a0updatePixels() la seguente riga:\u00a0<code>increment = map(mouseX, 0, width, 0.1, 0.01);</code></p> <p>In questo modo\u00a0rimapperemo la posizione X del mouse che pu\u00f2 andare da 0 alla larghezza della finestra in un nuovo range compreso tra 0.1 e 0.01.</p>","tags":["2d","loadpixels","noise","perlin-noise","pixels","texture","updatepixels"]},{"location":"math/2016-07-19-angoli-randians-e-degree/","title":"Angoli: randians() e degrees()","text":"<p>Prima di passare a studiare funzioni matematiche come sin(), cos() e tan() che, come vedremo, potranno essere molto utili per i nostri esperimenti con Processing, \u00e8 necessario\u00a0fare una breve premessa sugli angoli.</p> <p>La maggior parte delle persone \u00e8 abituata a misurare gli angoli con i gradi (in inglese degrees): un angolo retto \u00e8 90\u00b0, un angolo piatto \u00e8 180\u00b0 mentre un angolo giro \u00e8 360\u00b0. Quando si lavora con la trigonometria \u00e8 pi\u00f9 semplice\u00a0usare i radianti (in inglese\u00a0radians).</p> <p>Quando usiamo i radianti dobbiamo tenere presente che i valori degli angoli sono espressi in relazione al valore del \u03c0. Ragionando in radianti, dunque, un angolo retto \u00e8 \u03c0/2, un angolo piatto \u00e8 \u03c0 mentre un angolo giro \u00e8 2\u03c0.</p> <p>Per chi fosse spaventato da tutto questo e non pi\u00f9 molto fresco con l'argomento che stiamo trattando, ricordo che il valore del\u00a0pi greco \u00e8:</p> <p>il rapporto tra la misura della lunghezza della circonferenza e la misura della lunghezza del diametro di un cerchio</p> <p>Per aiutarci, gli sviluppatori di Processing hanno inserito una serie di variabili che possiamo utilizzare nei nostri sketch: PI, QUARTER_PI, HALF_PI, TWO_PI (nota bene: devono essere scritte in maiuscolo cos\u00ec come le ho riportate) oltre, ovviamente, a due funzioni che ci permettono\u00a0di passare dai gradi ai radianti e viceversa:</p> <ul> <li>La funzione radians() accetta come parametro un valore in gradi e restituisce il valore in radianti.</li> <li>La funzione degrees() accetta come parametro un valore in radianti e restituisce i gradi.</li> </ul> <p>Ecco un semplice programma che vi aiuter\u00e0 a familiarizzare con quanto appena detto:</p> <pre><code>/*\n * Angoli: radians() e degrees();\n * by Federico Pepe\n *\n */\n// COSTANTI\nprintln(\"QUARTER_PI = \"+ QUARTER_PI);\nprintln(\"HALF_PI = \" + HALF_PI);\nprintln(\"PI = \"+ PI);\nprintln(\"TWO_PI = \" + TWO_PI);\n\n// CONVERSIONE\n// Gradi -&gt; Radianti\nprintln();\nprintln(\"Gradi -&gt; Radianti\");\nprintln(\"90 gradi in radianti: \" + radians(90));\nprintln(\"180 gradi in radianti: \" + radians(180));\n\n// Radianti -&gt; Gradi\nprintln();\nprintln(\"Radianti -&gt; Gradi\");\nprintln(\"PI in gradi: \" + degrees(PI));\nprintln(\"TWO_PI in gradi:\" + degrees(TWO_PI));\n</code></pre> <p>Spero di non avervi spaventato con questa parentesi matematica. Prima di procedere oltre ci tengo a sottolineare che al liceo ho avuto sempre molte difficolt\u00e0 in questa materia\u00a0quindi cercher\u00f2 sempre di utilizzare spiegazioni semplici che permettano a chiunque di capire il punto a cui voglio arrivare. Ti auguro, come \u00e8 successo con me, che la programmazione sia il mezzo per riavvicinarsi alla matematica e, perch\u00e9 no, per capirla un po' di pi\u00f9.</p>","tags":["angoli","degrees","radians"]},{"location":"math/2016-07-21-sin-e-cos-onde-funzioni-cicliche/","title":"sin() e cos(): onde e funzioni cicliche","text":"<p>Rimaniamo nel campo della trigonometria e analizziamo le funzioni\u00a0<code>sin()</code> e <code>cos()</code> che, rispettivamente, ci consentono di calcolare il\u00a0seno e il\u00a0coseno di un angolo.</p> <p>Entrambe le funzioni necessitano di un solo parametro: la misura di un angolo espressa in radianti\u00a0e restituiscono un numero\u00a0float il cui valore \u00e8 sempre compreso tra -1.0 e 1.0.</p> <p>Con questo snippet di codice potete verificare voi stessi nella console di Processing:</p> <p>for(int angle = 0; angle &lt; 360; angle++) {  println(sin(radians(angle))); }</p> <p>Entrambe queste funzioni sono importanti per due motivi: restituendo valori compresi tra -1.0 e 1.0 \u00e8 possibile sfruttarle\u00a0per controllare altri parametri all'interno di uno sketch, il secondo \u00e8 che sono funzioni cicliche.</p>","tags":["cos","sin"]},{"location":"math/2016-07-21-sin-e-cos-onde-funzioni-cicliche/#esempi-utilizzo-funzione-sin","title":"Esempi utilizzo funzione sin()","text":"","tags":["cos","sin"]},{"location":"math/2016-07-21-sin-e-cos-onde-funzioni-cicliche/#esempio-1","title":"Esempio 1:","text":"<p>L'immagine qui sopra \u00e8 generata utilizzando questo codice:</p> <pre><code>/*\n * Angoli II: sin() e cos()\n * by Federico Pepe\n *\n*/\n\nvoid setup() {\n  size(640, 360);\n  background(255);\n  fill(0);\n  noStroke();\n}\n\nvoid draw() {\n  float angle = 0;\n\n  for(int x = 0; x &lt;= width; x+=5) {\n    float y = height/2 + (sin(radians(angle))*35);\n    rect(x, y, 2, 4);\n    angle += 10;\n  }\n\n}\n</code></pre> <p>Non credo che il codice abbia bisogno di molte spiegazioni: con un semplice ciclo for, disegniamo dei piccoli rettangoli la cui posizione \u00e8 determina dal ciclo for stesso, per il valore di x e, per quanto riguarda la y, da un valore calcolato con la funzione\u00a0sin(). Ovviamente a ogni ciclo for dobbiamo incrementare la variabile\u00a0angle.</p>","tags":["cos","sin"]},{"location":"math/2016-07-21-sin-e-cos-onde-funzioni-cicliche/#esempio-2-controllo-di-altri-parametri","title":"Esempio 2: controllo di altri parametri","text":"<p>Come dicevo prima, le cose si fanno pi\u00f9 interessanti quando sfruttiamo\u00a0il valore ciclico del seno all'interno di draw() per controllare altri parametri:</p> <p></p> <pre><code>/*\n * Sin() with Circle\n * by Federico Pepe\n *\n */\nfloat angle = 0;\nfloat diameter;\n\nvoid setup() {\n  size(500, 500);\n}\n\nvoid draw() {\n  background(255);\n  diameter = sin(angle)*200;\n  ellipse(width/2, height/2, diameter, diameter);\n  angle += 0.1;\n}\n</code></pre> <p>In questo esempio animato, ad esempio, utilizziamo la funzione sin() per controllare la grandezza del cerchio in modo ciclico. Se avessimo incrementato la variabile diameter in modo standard <code>diameter++</code>, avremmo dovuto inserire un controllo if per determinare la grandezza massima e per far cambiare segno al valore... insomma un sacco di righe di codice in pi\u00f9.</p>","tags":["cos","sin"]},{"location":"math/2016-07-21-sin-e-cos-onde-funzioni-cicliche/#esempio-3","title":"Esempio 3","text":"<p>Basta una piccolissima modifica al codice per ottenere un effetto completamente diverso:</p> <p></p> <pre><code>/*\n * Sin() e Cos() with Circle\n * by Federico Pepe\n *\n */\nfloat angle = 0;\nfloat sin, cos;\n\nvoid setup() {\n  size(500, 500);\n}\n\nvoid draw() {\n  background(255);\n  sin = sin(angle)*200;\n  cos = cos(angle)*200;\n  ellipse(width/2, height/2, sin, cos);\n  angle += 0.1;\n}\n</code></pre> <p>Queste funzioni sono cos\u00ec divertenti da usare che potrei fare molti esempi; l'obiettivo di oggi era comunque darvi un'idea delle potenzialit\u00e0 e lasciarvi la possibilit\u00e0 di sperimentare liberamente. Come al solito,\u00a0se volete potete lasciare un commento con le vostre animazioni!</p>","tags":["cos","sin"]},{"location":"math/2016-08-04-funzioni-ricorsive/","title":"Funzioni ricorsive","text":"<p>In programmazione definiamo\u00a0ricorsive\u00a0quelle funzioni che richiamo se stesse all'interno di un programma.\u00a0A parole si tratta di un concetto molto semplice ma \u00e8 bene fare qualche esempio per fugare ogni possibile dubbio.</p> <p>Prima di procedere \u00e8 bene puntualizzare che quando\u00a0creiamo e usiamo queste funzioni dobbiamo fare attenzione a inserire sempre una\u00a0condizione di uscita altrimenti\u00a0lo sketch\u00a0andr\u00e0 in\u00a0StackOverflowError.</p>","tags":["funzioni-ricorsive","recursion","ricorsivita"]},{"location":"math/2016-08-04-funzioni-ricorsive/#funzioni-ricorsive-removeone","title":"Funzioni ricorsive: removeOne();","text":"<p>Ecco il primo esempio:</p> <pre><code>/*\n * Funzioni Ricorsive\n * by Federico Pepe\n *\n*/\n\nvoid setup() {\n  noLoop();\n}\n\nvoid draw() {\n  removeOne(5);\n}\n\nvoid removeOne(int n) {\n  println(n);\n  if(n &gt; 1) {\n    n--;\n    removeOne(n);\n  }\n}\n</code></pre> <p>Analizziamo il funzionamento: tramite il comando noLoop() in setup() sappiamo che la funzione draw() verr\u00e0 ripetuta una sola volta. Dopodich\u00e9 creiamo la nostra funzione\u00a0removeOne()\u00a0che, ogni volta che viene chiamata, eseguir\u00e0 i seguenti comandi:</p> <ul> <li>stampa in console il valore di n</li> <li>controlla se il valore di\u00a0n \u00e8 maggiore di 1 se\u00a0true<ul> <li>sottrai 1 a\u00a0n</li> <li>richiama la funzione\u00a0removeOne passando il nuovo valore di\u00a0n</li> </ul> </li> </ul> <p>Il risultato in console sar\u00e0, ovviamente:</p> <p>5 4 3 2 1</p> <p>Nota:\u00a0spostando n--; dopo removeOne(n), il programma andr\u00e0 in un loop infinito generando un errore:\u00a0StackOverflowError. Gli sviluppatori di Processing sono stati cos\u00ec furbi\u00a0da riconoscere questo tipo di errore e da\u00a0far stoppare\u00a0automaticamente il programma evitando, cos\u00ec, di far bloccare il computer.</p> <p>Fino a qui niente di eccezionale, avremmo potuto ottenere lo stesso risultato in mille modi diversi utilizzando, ad esempio, un ciclo for. Le cose possono diventare interessanti quando cominciamo a utilizzare\u00a0le funzioni ricorsive per disegnare qualcosa sullo schermo come nel secondo esempio:</p>","tags":["funzioni-ricorsive","recursion","ricorsivita"]},{"location":"math/2016-08-04-funzioni-ricorsive/#funzioni-ricorsive-drawcircle","title":"Funzioni ricorsive: drawCircle();","text":"<pre><code>/*\n * Funzioni Ricorsive: drawCircle()\n * by Federico Pepe\n *\n*/\n\nvoid setup() {\n  size(700, 400);\n  noLoop();\n  noFill();\n  background(255);\n}\n\nvoid draw() {\n  drawCircle(width/2, height/2, width/2, 7);\n}\n\nvoid drawCircle(int x, int y, int radius, int recursion) {\n  ellipse(x, y, radius, radius);\n  if (recursion &gt; 1) {\n    recursion--;\n    drawCircle(x + radius/2, y, radius/2, recursion);\n    drawCircle(x - radius/2, y, radius/2, recursion);\n  }\n}\n</code></pre> <p>Il classico esempio che si vede quando si parla di ricorsivit\u00e0:\u00a0utilizziamo una variabile per definire quante ripetizioni dovranno esserci (in questo caso 7) e poi disegniamo dei cerchi la cui posizione\u00a0x e il cui raggio vengono dimezzati ogni volta. Per vedere i singoli passaggi potete modificare manualmente l'ultimo parametro in drawCircle() oppure creare una nuova variabile che viene incrementata alla pressione del mouse.</p>","tags":["funzioni-ricorsive","recursion","ricorsivita"]},{"location":"math/2016-10-06-trasformazioni-translate-rotate-scale/","title":"Trasformazioni: translate(), rotate(), scale()","text":"<p>Abbiamo gi\u00e0 avuto modo all'inizio del percorso base di prendere esplorare il sistema di coordinate in Processing. Una cosa che non abbiamo affrontato in modo approfondito \u00e8 che questo sistema non \u00e8 statico. Esistono, infatti delle funzioni dette\u00a0trasformazioni che ci permettono di modificare il nostro impianto di base. Tali funzioni sono translate(), rotate() e scale() che, come \u00e8 chiaro dai loro nomi, ci permettono di traslare, ruotare e scalare le forme che rappresentiamo sullo schermo.</p> <p>Perch\u00e9\u00a0usare le trasformazioni \u00e8 utile? Semplicemente perch\u00e9 quando lavoriamo con geometria complesse \u00e8 pi\u00f9 semplice modificare una sola linea di codice per spostare una o pi\u00f9 forme\u00a0invece che ripensare nuovamente a tutte le coordinate. In poche parole, \u00e8 un ottimo sistema per semplificarci la vita.</p>","tags":["rotate","scale","translate","trasformazioni"]},{"location":"math/2016-10-06-trasformazioni-translate-rotate-scale/#translate","title":"translate()","text":"<p>La funzione translate sposta il punto di origine della nostra forma; accetta due parametri: le coordinate x e y del nostro spostamento. Ovviamente quando chiamiamo questa funzione, lo spostamento viene applicato per tutte le forme che vengono disegnate\u00a0dopo la funzione stessa.</p> <pre><code>void setup() {\n  size(500, 500);\n  background(255);\n}\n\nvoid draw() {\n  rect(50, 50, 200, 50);\n  translate(50, 100);\n  rect(50, 50, 200, 50);\n}\n</code></pre> <p></p> <p>Ecco che pur utilizzando le stesse coordinate per i due rettangoli, il secondo si trova spostato di 50 pixel verso destra e 100 pi\u00f9 in basso.</p> <p>Un particolare di questa funziona \u00e8 che, se ripetuta, \u00e8\u00a0incrementale:</p> <pre><code>void setup() {\n  size(500, 500);\n  background(255);\n}\n\nvoid draw() {\n  rect(50, 50, 200, 50);\n  translate(50, 100);\n  rect(50, 50, 200, 50);\n  translate(50, 100);\n  rect(50, 50, 200, 50);\n}\n</code></pre> <p>In questo secondo esempio il terzo rettangolo risulta spostato, rispetto al primo, di 100 pixel verso destra e 200 in basso.</p> <p></p> <p>Importante notare anche che pur essendo inserite all'interno di un ciclo draw(), a ogni loop l'intero sistema viene resettato.</p>","tags":["rotate","scale","translate","trasformazioni"]},{"location":"math/2016-10-06-trasformazioni-translate-rotate-scale/#rotate","title":"rotate()","text":"<p>La funzione rotate() ruota il sistema di coordinate. Accetta un solo parametro, la quantit\u00e0 di rotazione che deve essere espresso in radianti. Le forme vengono sempre ruotate relativamente al punto di origine (0, 0) della finestra e non relativamente al punto di riferimento della forma.\u00a0Se il parametro di rotazione \u00e8 positivo, il movimento sar\u00e0 in senso orario.</p> <p>Esempio di rotazione di 45 gradi convertiti nel valore in radianti.</p> <pre><code>void setup() {\n  size(500, 500);\n  background(255);\n}\n\nvoid draw() {\n  rect(50, 50, 200, 50);\n  rotate(radians(45));\n  rect(50, 50, 200, 50);\n}\n</code></pre> <p></p>","tags":["rotate","scale","translate","trasformazioni"]},{"location":"math/2016-10-06-trasformazioni-translate-rotate-scale/#scale","title":"scale()","text":"<p>La funzione scale() modifica il sistema di coordinate ingrandendo o rimpicciolendo le forme. Questa funzione accetta uno o due parametri: nel primo caso verr\u00e0 applicato quel valore a tutte le dimensioni mentre, nel secondo, il primo scaler\u00e0 l'asse x e il secondo l'y.</p> <p>Per far funzionare la funzione scale() correttamente i valori devono essere espressi in percentuale usando i numeri decimali: scrivendo 2 otterremo un incremento del 200%, scrivendo 0.5 la forma sar\u00e0 rimpicciolita del 50%.</p> <pre><code>void setup() {\n  size(500, 500);\n  background(255);\n}\n\nvoid draw() {\n  fill(255);\n  rect(50, 50, 200, 50);\n  scale(0.5);\n  fill(255, 0, 0);\n  rect(50, 50, 200, 50);\n}\n</code></pre> <p></p>","tags":["rotate","scale","translate","trasformazioni"]},{"location":"math/2016-10-25-trasformazioni-pushmatrix-popmatrix/","title":"Controllare le trasformazioni: pushMatrix() e popMatrix()","text":"<p>Le funzioni di trasformazione viste nell'ultimo post ci hanno dato prova di\u00a0come sia possibile andare a modificare dinamicamente il sistema di coordinate di Processing. In questo articolo, introdurremo\u00a0due nuove funzioni chiamate\u00a0pushMatrix() e\u00a0popMatrix() che, come vedremo insieme, ci permettono\u00a0di avere maggiore controllo sulle trasformazioni.</p>","tags":["popmatrix","pushmatrix","rotate","scale","translate","trasformazioni"]},{"location":"math/2016-10-25-trasformazioni-pushmatrix-popmatrix/#matrici","title":"Matrici","text":"<p>Ogni volta che usiamo le funzioni\u00a0translate(),\u00a0rotate() e\u00a0scale() andiamo a modificare\u00a0una\u00a0matrice \u2013\u00a0in inglese matrix. Per spiegarlo nel modo pi\u00f9 semplice possibile: una matrice non \u00e8 altro che un insieme di numeri che descrivono, a livello matematico, come vengono disegnate le geometrie su uno schermo. Le funzioni di trasformazione vanno a modificare questi numeri.</p>","tags":["popmatrix","pushmatrix","rotate","scale","translate","trasformazioni"]},{"location":"math/2016-10-25-trasformazioni-pushmatrix-popmatrix/#pushmatrix-e-popmatrix","title":"pushMatrix() e popMatrix()","text":"<p>Le funzioni\u00a0pushMatrix()\u00a0e\u00a0popMatrix() vanno inserite nei nostri programmi sempre in coppia e la loro funzione \u00e8 quella di salvare lo stato delle trasformazioni (push) e richiamarle (pop) al momento opportuno.</p> <p>Quando ho cominciato a studiare Processing, non riuscivo a capire il senso di questa cosa. Alla fine, in un video tutorial trovato on-line, ho trovato la similitudine corretta per spiegarlo. Spero che quanto sto per scrivere aiuti anche voi, come \u00e8 stato per me, a capire meglio il senso di pushMatrix e popMatrix.</p> <p>Trattandosi di operazioni che facciamo sul sistema delle coordinate, dobbiamo immaginare di spostare il foglio su cui stiamo scrivendo e non la punta della penna con cui scriviamo.</p> <p>Provo a spiegarmi meglio con un esempio:</p> <pre><code>void setup() {\n  size(500, 500);\n}\n\nvoid draw() {\n  background(255);\n  translate(100, 0);\n  rect(0, 20, 200, 75);\n  rect(0, 105, 200, 75);\n}\n</code></pre> <p>In setup() creiamo il nostro canvas di dimensione 500x500 pixel dopodich\u00e9 in\u00a0draw()\u00a0per ogni ciclo della funzione, coloriamo lo sfondo di bianco, spostiamo la punta della nostra penna di 100 pixel verso destra (oppure possiamo pensare che il foglio si sia spostato 100 pixel nella direzione opposta) e poi disegniamo due rettangoli con dimensioni uguali e con valori di x identici e y differente.</p> <p>Ci aspettiamo, ovviamente, che i due rettangoli siano allineati a sinistra uno con l'altro e infatti questo \u00e8 risultato:Se modifichiamo il codice aggiungendo pushMatrix() e popMatrix() ecco che il risultato cambia:</p> <pre><code>void setup() {\n  size(500, 500);\n}\n\nvoid draw() {\n  background(255);\n  pushMatrix();\n  translate(100, 0);\n  rect(0, 20, 200, 75);\n  popMatrix();\n  rect(0, 105, 200, 75);\n}\n</code></pre> <p></p> <p>Perch\u00e9 il secondo rettangolo non \u00e8 pi\u00f9 allineato con il primo? Quando chiamiamo la funzione pushMatrix() nella nostra matrice viene salvata la posizione corrente del nostro sistema di coordinate, cio\u00e8 senza alcuna trasformazione perch\u00e9 il comando translate viene invocato successivamente. Dopodich\u00e9 viene applicato uno spostamento verso destra, viene disegnato il primo rettangolo e, infine, utilizzando\u00a0popMatrix() ripristiniamo il salvataggio precedente, annullando, cio\u00e8, la traslazione di 100 pixel.</p> <p>In questo modo, il secondo rettangolo, con coordinate 0, 105, verr\u00e0 disegnato vicino al bordo sinistro della nostra finestra.</p>","tags":["popmatrix","pushmatrix","rotate","scale","translate","trasformazioni"]},{"location":"math/2016-10-25-trasformazioni-pushmatrix-popmatrix/#perche-usare-pushmatrix-e-popmatrix","title":"Perch\u00e9 usare pushMatrix() e popMatrix()?","text":"<p>Qualcuno potrebbe chiedersi quale sia l'utilit\u00e0 di utilizzare pushMatrix() e popMatrix() all'interno di uno sketch in Processing. La risposta \u00e8\u00a0abbastanza semplice ma, come scrivevo prima, personalmente non \u00e8 stata immediata: se realizziamo animazioni complesse con una somma di trasformazioni continue pu\u00f2 risultare difficile ricordarsi in ogni momento le coordinate di una determinata forma. Con queste due funzioni possiamo, invece, spostare le coordinate e fare in modo che le nostre figure abbiano sempre coordinate x = 0 e y = 0.</p>","tags":["popmatrix","pushmatrix","rotate","scale","translate","trasformazioni"]},{"location":"primi-passi/array-bidimensionali-esercizio-alta-difficolta-soluzione/","title":"Esercizio alta difficolt\u00e0","text":""},{"location":"primi-passi/array-bidimensionali-esercizio-alta-difficolta-soluzione/#array-bidimensionali-esercizio-alta-difficolta-soluzione","title":"Array bidimensionali: esercizio alta difficolt\u00e0 (soluzione)","text":"<p>Ecco la soluzione all\u2019esercizio di difficolt\u00e0 media proposto nell\u2019articolo\u00a0Array bidimensionali.</p>"},{"location":"primi-passi/array-bidimensionali-esercizio-alta-difficolta-soluzione/#esercizio","title":"Esercizio","text":"<p>Partendo dalla soluzione all\u2019esercizio di difficolt\u00e0 media, sareste in grado di modificarlo ulteriormente\u00a0per fare in modo che\u00a0la griglia non sia necessariamente 8\u00d78?</p>"},{"location":"primi-passi/array-bidimensionali-esercizio-alta-difficolta-soluzione/#soluzione","title":"Soluzione","text":"<pre><code>/*\n * Array bidimensionali: esercizio alta difficolt\u00e0\n * Federico Pepe, 19.02.2017\n * http://blog.federicopepe.com/processing\n */\n\nvoid setup() {\n  size(480, 480);\n\n  int rows = 16;\n  int cols = 16;\n\n  boolean[][] scacchiera = new boolean[rows][cols];\n\n  boolean tileColor = false;\n\n  // Riempi i dati\n  for (int i = 0; i &lt; rows; i++) {\n    for (int j = 0; j &lt; cols; j++) {\n      scacchiera[i][j] = tileColor;\n      tileColor = !tileColor;\n    }\n    if(cols % 2 == 0) {\n      tileColor = !tileColor;\n    }\n  }\n\n\n  // Disegna la scacchiera\n  float tileSizeX = width/rows;\n  float tileSizeY = height/cols;\n\n  for (int i = 0; i &lt; rows; i++) {\n    for (int j = 0; j &lt; cols; j++) {\n      if (scacchiera[i][j]) {\n        fill(0);\n      } else {\n        fill(255);\n      }\n      rect(i*tileSizeX, j*tileSizeY, tileSizeX, tileSizeY);\n    }\n  }\n}\n\nvoid draw() {\n}\n</code></pre>"},{"location":"primi-passi/array-bidimensionali-esercizio-media-difficolta-soluzione/","title":"Esercizio media difficolt\u00e0","text":""},{"location":"primi-passi/array-bidimensionali-esercizio-media-difficolta-soluzione/#array-bidimensionali-esercizio-media-difficolta-soluzione","title":"Array bidimensionali: esercizio media difficolt\u00e0 (soluzione)","text":"<p>Ecco la soluzione all'esercizio di difficolt\u00e0 media proposto nell'articolo\u00a0Array bidimensionali.</p>"},{"location":"primi-passi/array-bidimensionali-esercizio-media-difficolta-soluzione/#esercizio","title":"Esercizio:","text":"<p>Siete in grado di modificare lo script affinch\u00e9, ad esempio, modificando i valori all\u2019interno di size() mi venga disegnata sempre una scacchiera di 8\u00d78 che occupi l\u2019intera grandezza della finestra (anche quando non \u00e8 quadrata)?</p>"},{"location":"primi-passi/array-bidimensionali-esercizio-media-difficolta-soluzione/#soluzione","title":"Soluzione:","text":"<pre><code>/*\n * Array bidimensionali - esercizio media difficolt\u00e0\n * Federico Pepe, 19.02.2017\n * http://blog.federicopepe.com/processing\n*/\n\nint[][] scacchiera = { \n  {1, 0, 1, 0, 1, 0, 1, 0}, \n  {0, 1, 0, 1, 0, 1, 0, 1}, \n  {1, 0, 1, 0, 1, 0, 1, 0}, \n  {0, 1, 0, 1, 0, 1, 0, 1}, \n  {1, 0, 1, 0, 1, 0, 1, 0}, \n  {0, 1, 0, 1, 0, 1, 0, 1}, \n  {1, 0, 1, 0, 1, 0, 1, 0}, \n  {0, 1, 0, 1, 0, 1, 0, 1} };\n\nvoid setup() {\n  size(480, 700);\n\n  int rows = 8;\n  int cols = 8;\n\n  float tileSizeX = width/rows;\n  float tileSizeY = height/cols;\n\n  for (int i = 0; i &lt; rows; i++) {\n    for(int j = 0; j &lt; cols; j++) {\n      if(scacchiera[i][j] == 0) {\n        fill(0);\n      } else {\n        fill(255);\n      }\n      rect(i*tileSizeX, j*tileSizeY, tileSizeX, tileSizeY);\n    }\n  }\n}\n\nvoid draw() {\n}\n</code></pre>"},{"location":"primi-passi/array-bidimensionali-processing/","title":"Array bidimensionali","text":""},{"location":"primi-passi/array-bidimensionali-processing/#array-bidimensionali","title":"Array bidimensionali","text":"<p>In programmazione gli Array sono utili per archiviare in modo ordinato\u00a0una serie di informazioni.\u00a0Per chi avesse bisogno di un recap, questo \u00e8 l'articolo in cui\u00a0ho introdotto il concetto di array e il loro utilizzo in Processing.</p> <p>A volte pu\u00f2 capitare di avere a che fare con informazioni che non possono essere rappresentate in un'unica dimensione. Per questo motivo abbiamo bisogno di una struttura di dati multidimensionale:\u00a0un\u00a0array bidimensionale, ovvero un array di array, ci permette di lavorare con facilit\u00e0 su dati di questo tipo.</p> <p>Per fare un esempio, proviamo a pensare di rappresentare i quadrati neri e bianchi di una scacchiera utilizzando il valore 0 per i primi e 1 per i secondi.</p> <p>Partiamo da un array monodimensionale: </p><pre><code>int[] scacchiera = { 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1 };\n</code></pre> <p>Con questo array ho rappresentato tutti e 64 i tasselli ma non \u00e8 chiara la struttura a righe e colonne tipica della scacchiera. Ecco che, invece, inserendo ciascuna riga in un array separato le cose migliorano sensibilmente:</p> <pre><code>int[][] scacchiera = { \n {1, 0, 1, 0, 1, 0, 1, 0},\n {0, 1, 0, 1, 0, 1, 0, 1},\n {1, 0, 1, 0, 1, 0, 1, 0},\n {0, 1, 0, 1, 0, 1, 0, 1},\n {1, 0, 1, 0, 1, 0, 1, 0},\n {0, 1, 0, 1, 0, 1, 0, 1},\n {1, 0, 1, 0, 1, 0, 1, 0},\n {0, 1, 0, 1, 0, 1, 0, 1} };\n</code></pre> <p>Abbiamo costruito il nostro primo\u00a0array bidimensionale.</p>"},{"location":"primi-passi/array-bidimensionali-processing/#dichiarazione-e-inizializzazione","title":"Dichiarazione e inizializzazione","text":"<p>Le regole da rispettare in merito alla dichiarazione e inizializzazione dell'array bidimensionale rimangono identiche rispetto a quanto gi\u00e0 visto in passato: \u00e8 necessario indicare il tipo di dato, il nome dell'array ed \u00e8 fondamentale\u00a0stabilire una grandezza iniziale.</p> <p>Sempre prendendo come riferimento l'esempio della scacchiera, inizializziamo l'array bidimensionale con 8 valori per le righe e 8 per le colonne:</p> <p><code>int[][] scacchiera = new int[8][8];</code></p>"},{"location":"primi-passi/array-bidimensionali-processing/#array-bidimensionali-e-nested-loop","title":"Array bidimensionali e nested loop","text":"<p>I loop annidati sono il modo migliore per accedere a tutti i dati presenti in un array bidimensionale. Proviamo a disegnare la nostra scacchiera:</p> <pre><code>/*\n * Array bidimensionali e scacchi\n * Federico Pepe, 19.02.2017\n * http://blog.federicopepe.com/processing\n*/\n\nint[][] scacchiera = { \n  {1, 0, 1, 0, 1, 0, 1, 0}, \n  {0, 1, 0, 1, 0, 1, 0, 1}, \n  {1, 0, 1, 0, 1, 0, 1, 0}, \n  {0, 1, 0, 1, 0, 1, 0, 1}, \n  {1, 0, 1, 0, 1, 0, 1, 0}, \n  {0, 1, 0, 1, 0, 1, 0, 1}, \n  {1, 0, 1, 0, 1, 0, 1, 0}, \n  {0, 1, 0, 1, 0, 1, 0, 1} };\n\nvoid setup() {\n  size(480, 480);\n\n  int rows = 8;\n  int cols = 8;\n\n  for (int i = 0; i &lt; rows; i++) {\n    for(int j = 0; j &lt; cols; j++) {\n      if(scacchiera[i][j] == 0) {\n        fill(0);\n      } else {\n        fill(255);\n      }\n      rect(i*60, j*60, 60, 60);\n    }\n  }\n}\n\nvoid draw() {\n}\n</code></pre> <p>All'inizio del programma troviamo l'array bidimensionale che contiene i valori su cui dobbiamo lavorare. All'interno della funzione setup() abbiamo impostato la grandezza della finestra e abbiamo creato due variabili per avere il numero di righe (rows) e il numero di colonne (cols).</p> <p>Utilizzando due loop\u00a0andiamo a vedere tutti i valori presenti all'interno dell'array: se il valore trovato \u00e8 uguale a 0 la casella sar\u00e0 nera, altrimenti bianca.\u00a0Completiamo il programma andando effettivamente a disegnare la singola casella.</p>"},{"location":"primi-passi/array-bidimensionali-processing/#esercizio-di-difficolta-media","title":"Esercizio di difficolt\u00e0 media","text":"<p>In questo script ci sono diversi parametri \"hard-coded\".\u00a0Siete in grado di modificare lo script affinch\u00e9, ad esempio, modificando i valori all'interno di size() mi venga disegnata sempre una scacchiera di 8x8 che occupi l'intera grandezza della finestra (anche quando non \u00e8 quadrata)?</p>"},{"location":"primi-passi/array-bidimensionali-processing/#esercizio-di-difficolta-alta","title":"Esercizio di difficolt\u00e0 alta","text":"<p>Partendo dalla soluzione all'esercizio di difficolt\u00e0 media, sareste in grado di modificarlo ulteriormente\u00a0per fare in modo che\u00a0la griglia non sia necessariamente 8x8?</p>"},{"location":"primi-passi/array-di-oggetti/","title":"Array di oggetti","text":""},{"location":"primi-passi/array-di-oggetti/#array-di-oggetti-bouncing-ball-parte-4","title":"Array di oggetti: Bouncing Ball, parte 4","text":"<p>\u00c8 finalmente arrivato il momento di mettere insieme quanto\u00a0imparato nell'ultimo mese,\u00a0programmazione ad oggetti e\u00a0array,\u00a0e di concludere il nostro esercizio Bouncing Ball. La domanda\u00a0a cui oggi daremo, finalmente, risposta \u00e8 sempre la stessa: come faccio a creare decine o centinaia di oggetti?</p>"},{"location":"primi-passi/array-di-oggetti/#un-array-di-oggetti","title":"Un array di oggetti","text":"<p>Riprendiamo il codice dell'esercizio Bouncing Ball dove l'avevamo lasciato.\u00a0Il primo passo \u00e8 dichiarare un array di oggetti di tipo Ball.</p> <p>La prima riga del nostro programma serviva per dichiarare una variabile di tipo\u00a0Ball (il nostro oggetto) di nome\u00a0myBall.</p> <p><code>Ball myBall;</code></p> <p>Sostituiamo questa riga di codice con un array di oggetti: per mantenere il mio codice chiaro e leggibile modifico anche il nome della variabile da myBall (che identifica un oggetto solo) a myBalls, utilizzando il plurale.</p> <p><code>Ball[] myBalls;</code></p> <p>Nella funzione setup() dove, precedentemente, inizializzavo\u00a0l'oggetto\u00a0ora devo\u00a0dichiarare grandezza del mio array. Decido di avere a disposizione 100 oggetti:</p> <p><code>myBalls = new Ball[100];</code></p> <p>Non mi resta che inizializzare tutti gli oggetti richiamando il constructor all'interno della nostra classe, per sveltire, utilizzo un ciclo for:</p> <p>for(int i = 0; i &lt; myBalls.length; i++) {  myBalls[i] = new Ball(random(width), random(height), random(0.5 ,5), random(0.5, 5));  }</p>"},{"location":"primi-passi/array-di-oggetti/#debugging-di-un-array-di-oggetti","title":"Debugging di un array di oggetti","text":"<p>Con l'ultima porzione di codice abbiamo riempito il nostro array occupando tutte e 100 le caselle con 100 oggetti differenti\u00a0assegnando\u00a0a ciascuno di essi, grazie alle\u00a0funzioni random, la posizione X e Y e la velocit\u00e0 sull'asse orizzontale e verticale.</p> <p>Se volessimo essere sicuri di averlo fatto nel modo corretto, potremmo pensare di utilizzare, come abbiamo sempre fatto finora, la funzione\u00a0println(myBalls);</p> <p></p> <p>Come potete vedere nell'immagine, il testo riportato nella console non \u00e8 per niente chiaro. Trattandosi di un array, proviamo a sostituire println con printArray:</p> <p></p> <p>Un risultato leggermente migliore: vediamo che ci sono effettivamente 100 oggetti, numerati da 0 a 99, ma facciamo ancora fatica a capire se il contenuto del nostro array \u00e8 corretto.</p>"},{"location":"primi-passi/array-di-oggetti/#accedere-alle-variabili-interne-agli-oggetti","title":"Accedere alle variabili interne agli oggetti","text":"<p>Nei nostri esercizi relativi agli oggetti abbiamo imparato a usare la\u00a0dot notation per richiamare i metodi all'interno degli oggetti.\u00a0La riga di codice myBall.display() serviva per richiamare\u00a0la funzione\u00a0display()\u00a0contenuta nell'oggetto creato precedentemente.</p> <p>Utilizzando lo stesso metodo possiamo accedere anche alle variabili interne all'oggetto: scrivendo, ad esempio,\u00a0myBall.ellipseX;\u00a0verr\u00e0 restituito il valore di ellipseX.</p> <p>Dal momento che, per\u00f2, non stiamo lavorando con un singolo oggetto ma con un array\u00a0abbiamo due possibilit\u00e0:</p> <ol> <li>accedere ai dati di un oggetto specifico:\u00a0println(myBalls[34].ellipseX);</li> <li>utilizzare la variabile contatore nel nostro ciclo for per visualizzarli tutti</li> </ol> <p>Aggiungiamo questa riga di codice all'interno del nostro ciclo for:</p> <p><code>println(\"[\"+i+\"] - ellipseX: \" + myBalls[i].ellipseX);</code></p> <p>Ed ecco che il risultato \u00e8 finalmente comprensibile:</p> <p></p>"},{"location":"primi-passi/array-di-oggetti/#bouncing-balls-parte-4","title":"Bouncing Balls, parte 4","text":"<p>Concludiamo modificando il codice contenuto in\u00a0draw() per vedere tutte e cento le nostre sfere rimbalzare sullo schermo.</p> <pre><code>Ball[] myBalls;\n\nvoid setup() {\n  size(700, 500);\n  myBalls = new Ball[100];\n  for(int i = 0; i &lt; myBalls.length; i++) {\n    myBalls[i] = new Ball(random(width), random(height), random(0.5 ,5), random(0.5, 5));\n  }  \n}\n\nvoid draw() {\n  background(0);\n  for(int i = 0; i &lt; myBalls.length; i++) {\n    myBalls[i].display();\n    myBalls[i].move();\n    myBalls[i].checkEdges();\n  } \n}\n</code></pre> <p>Non ho incluso il codice della classe Ball perch\u00e9 non \u00e8 stata toccata nemmeno una riga di codice. Se avete fatto tutto correttamente, il risultato sar\u00e0 il seguente:</p> <p></p>"},{"location":"primi-passi/array/","title":"Array: dichiarazione, inizializzazione e utilizzo","text":""},{"location":"primi-passi/array/#array-dichiarazione-inizializzazione-e-utilizzo","title":"Array: dichiarazione, inizializzazione e utilizzo","text":"<p>Avevo concluso l'ultimo post relativo alla programmazione orientata agli oggetti con una domanda:\u00a0se volessimo creare decine o centinaia di oggetti? Il copia incolla non sarebbe certamente la scelta pi\u00f9 consona.</p> <p>Abbiamo capito gi\u00e0 da tempo\u00a0che\u00a0uno dei principi di base della programmazione \u00e8 scrivere meno righe di codice possibile per ottenere il risultato sperato.\u00a0Introduciamo oggi il concetto di array.</p>"},{"location":"primi-passi/array/#cose-un-array","title":"Cos'\u00e8 un Array?","text":"<p>Nel post dedicato alle\u00a0variabili\u00a0abbiamo parlato di\u00a0come dichiararle e inizializzarle ma non ci siamo mai soffermati su una questione molto importante: una variabile pu\u00f2 contenere\u00a0un solo valore.</p> <p>\u00c8 vero che questo valore pu\u00f2 variare in base all'andamento del nostro programma ma non \u00e8 possibile, ad esempio, che una variabile\u00a0di tipo integer possa valere contemporaneamente 5 e 10.</p> <p>Gli array risolvono questo problema perch\u00e9\u00a0rappresentano una lista di valori: all'interno di un array io posso inserire una serie di valori, purch\u00e9 siano tutti dello stesso\u00a0data type.\u00a0Un altro importante vantaggio \u00e8 che ciascun elemento ha un ordine preciso all'interno della lista che \u00e8 identificato da un indice univoco.</p> <p>\u00c8 fondamentale ricordare che l'indice parte sempre da 0\u00a0di conseguenza se sto utilizzando un array che contiene 10 elementi,\u00a0l'ultimo valore avr\u00e0 un indice pari a 9.</p> <p>Ricapitolo per chiarezza i punti chiave:</p> <ul> <li>Un array rappresenta una lista di elementi</li> <li>Gli elementi all'interno dell'array devono essere tutti dello stesso tipo</li> <li>Gli elementi all'interno dell'array hanno un ordine preciso</li> <li>Ciascun elemento \u00e8 identificato da un indice univoco che parte sempre da 0</li> </ul>"},{"location":"primi-passi/array/#dichiarazione-e-creazione-di-un-array","title":"Dichiarazione e creazione di un array","text":"<p>La sintassi per dichiarare un array \u00e8 molto semplice: rispetto a quella utilizzata per le variabili, dobbiamo solo aggiungere delle parentesi quadre:</p> <p>int[] myArray;</p> <p>Con questa riga di codice ho dichiarato un array di nome\u00a0myArray che conterr\u00e0 al suo interno una lista di valori\u00a0di tipo integer.\u00a0Non ho ancora detto al mio programma\u00a0quanti elementi conterr\u00e0 questo array e,\u00a0di conseguenza, la lista \u00e8 ancora vuota.</p> <p>Passiamo all'inizializzazione di myArray:</p> <p>int[] myArray = new int[10];</p> <p>Ho\u00a0creato un'istanza di un nuovo array e ho gli ho assegnato una dimensione: la lista sar\u00e0 composta da 10 elementi di tipo integer.</p> <p>La grandezza dell'array pu\u00f2 essere\u00a0hard-coded come nell'esempio qui sopra, oppure pu\u00f2 essere una\u00a0variabile (di tipo integer) oppure un'espressione matematica che dia come risultato un\u00a0integer:</p> <pre><code>// Un array di integer con grandezza hard-coded\nint[] myArray = new int[10];\n\n// Un array di float con grandezza passata tramite variabile (integer)\nint sizeOfArray = 5;\nfloat[] mySecondArray = new float[sizeOfArray];\n\n// Un array di oggetti \"Car\" con grandezza passata tramite funzione\nCar[] cars = new Car[2+5];\n</code></pre>"},{"location":"primi-passi/array/#inserire-valori-in-un-array","title":"Inserire valori in un array","text":"<p>Non ci resta che cominciare a riempire il nostro array di informazioni.</p> <p>Una prima opzione \u00e8 quella di inserire le variabili specificando la posizione\u00a0indice di riferimento. Questa scelta, ovviamente, non \u00e8 la pi\u00f9 funzionale.</p> <pre><code>// Dichiaro e inizializzo il mio array che conterr\u00e0 5 elementi di tipo integer\nint[] myArray = new int[5];\n\nmyArray[0] = 5;   // Il primo elemento (indice = 0) sar\u00e0: 5\nmyArray[1] = 10;  // Il secondo elemento (indice = 1) sar\u00e0: 10\nmyArray[2] = 3;   // Il terzo elemento (indice = 2) sar\u00e0: 3\nmyArray[3] = 0;   // Il quarto elemento (indice = 3) sar\u00e0: 0\nmyArray[4] = 340; // Il quinto elemento (indice = 4) sar\u00e0: 340\n</code></pre> <p>Una seconda opzione \u00e8 quella di inserire tutti i valori, separati da virgole, all'interno di parentesi graffe:</p> <pre><code>// Dichiaro un array di tipo integer di nome myArray con all'interno i seguenti valori: 5, 10, 3, 0, 340\n\nint[] myArray = {5, 10, 3, 0, 340};\n</code></pre> <p>Le due porzioni di codice qui sopra rappresentato, di fatto, la stessa identica\u00a0lista.</p>"},{"location":"primi-passi/array/#operazioni-matematiche-con-gli-array","title":"Operazioni matematiche con gli array","text":"<p>Per capire se tutto \u00e8 chiaro, proviamo ad analizzare un problema: se volessimo creare una lista\u00a0di 500 elementi contenenti numeri random compresi tra 0 e 255?</p> <p>Per prima cosa non dobbiamo dimenticare che la funzione\u00a0random()\u00a0restituisce valori di tipo\u00a0float. Avendo\u00a0gi\u00e0 deciso che la nostra lista sar\u00e0 composta da 500 elementi, possiamo anche inizializzare il nostro array:</p> <p>float valori[] = new float[500];</p> <p>Ora dobbiamo inserire tutti i valori; farlo uno ad uno sarebbe un massacro ma, per fortuna, abbiamo gi\u00e0 studiato i cicli while e for\u00a0il cui scopo \u00e8 effettuare operazioni ripetitive.</p> <p>Per comodit\u00e0 utilizzer\u00f2 un ciclo for: posso usare la variabile del ciclo per indicare l'indice dell'array nel quale inserire il valore random:</p> <pre><code>float valori[] = new float[500];\n\nfor(int i = 0; i &lt; 500; i++) {\n  valori[i] = random(255);\n}\n\nprintArray(valori);\n</code></pre> <p></p> <p>Come si pu\u00f2 notare nell'immagine, grazie alla funzione printArray\u00a0nella console visualizzo tutti i valori e il relativo indice all'interno dell'array.</p> <p>Ovviamente\u00a0\u00e8 possibile\u00a0accedere singolarmente a qualsiasi elemento indicando l'indice:</p> <p>println(\"Il valore all'indice 306 \u00e8: \"+ valori[306]);</p>"},{"location":"primi-passi/array/#debugging-degli-array-e-length","title":"Debugging degli array e .length","text":"<p>Un errore in cui si pu\u00f2 incorrere frequentemente quando si lavora con gli array \u00e8:\u00a0ArrayIndexOutOfBoundsExceptions. Tale problema si verifica quando chiediamo al nostro programma di accedere a un valore ad un indice non presente nell'array.</p> <p>Se modifichiamo il codice del ciclo for nel precedente esempio in questo modo:</p> <p>for(int i = 0; i &lt;= 500; i++)</p> <p>riscontreremo proprio questo tipo di errore perch\u00e9 il ciclo si ripeter\u00e0 finch\u00e9 il valore di i sar\u00e0 uguale a 500. Il problema \u00e8 che la grandezza dell'array che ho dichiarato all'inizio \u00e8 pari a 500 ma, partendo da 0, l'ultimo valore dell'indice \u00e8 499.</p> <p>Per ovviare a questo problema possiamo usare una propriet\u00e0 degli array: .length. In pratica, anzich\u00e9 dover ricordarsi quant'\u00e8 la lunghezza di ogni array e, prossimamente, vedremo che questa potrebbe anche variare, diciamo al programma di capire da s\u00e9 quant'\u00e8 la lunghezza\u00a0della nostra lista e di comportarsi di conseguenza.</p> <p>Ecco che il codice finito potrebbe essere:</p> <pre><code>float valori[] = new float[500];\n\nfor(int i = 0; i &lt; valori.length; i++) {\n  valori[i] = random(255);\n}\n\nprintArray(valori);\n</code></pre>"},{"location":"primi-passi/blocchi-di-codice-e-flusso-setup-e-draw/","title":"Blocchi di codice e flusso","text":""},{"location":"primi-passi/blocchi-di-codice-e-flusso-setup-e-draw/#blocchi-di-codice-e-flusso-setup-e-draw","title":"Blocchi di codice e flusso: setup() e draw()","text":"<p>Oggi introduciamo due concetti\u00a0di base molto importanti\u00a0che ci porteranno\u00a0a realizzare dei programmi\u00a0interattivi con Processing.</p> <p>Fino ad oggi, ci siamo limitati a scrivere una linea di codice dopo l'altra e abbiamo imparato che quando clicchiamo sul pulsante Run, se non ci sono errori, ciascuna di esse viene processata in ordine dalla prima all'ultima.</p> <p>Gli sketch che abbiamo realizzato nelle scorse lezioni sono belli ma poco interessanti perch\u00e9 siamo abituati a utilizzare programmi che, una volta lanciati,\u00a0cambiano aspetto in base al procedere del tempo e a come interagiamo con essi attraverso mouse, tastiera, ecc...</p> <p>Pensate, ad esempio, allo screensaver del vostro computer oppure a un qualsiasi gioco per pc: tutte queste applicazioni partono da uno stato iniziale in cui vengono\u00a0settate\u00a0alcune impostazioni e, mentre il programma funziona, il computer controlla costantemente\u00a0la posizione del mouse oppure se abbiamo premuto un determinato tasto. Idealmente questo controllo dovrebbe avvenire 30 volte al secondo.</p>"},{"location":"primi-passi/blocchi-di-codice-e-flusso-setup-e-draw/#le-funzioni-setup-e-draw","title":"Le funzioni setup() e draw()","text":"<p>In Processing esistono due funzioni molto importanti:\u00a0setup()\u00a0e\u00a0draw(). Prima di procedere con la spiegazione del loro funzionamento, dobbiamo capire come dividere in porzioni o, per meglio dire,\u00a0blocchi\u00a0il nostro codice in modo da suddividere in modo preciso\u00a0le operazioni che saranno eseguite in fase iniziale di setup e quelle che, invece, saranno costantemente ripetute dal computer in draw.</p> <p>Per delimitare l'inizio e la fine dei blocchi di codice si usano le parentesi graffe:</p> <pre><code>void setup() {\n  // Blocco di codice di setup\n}\n\nvoid draw() {\n  // Blocco di codice di draw\n}\n</code></pre> <p>Vi chiedo di ignorare, per il momento,\u00a0il significato di\u00a0void e il fatto che, a differenza delle funzioni usate finora, non abbiamo inserito\u00a0nessun parametro all'interno delle parentesi tonde; torneremo su questo argomento pi\u00f9 avanti quando tratteremo\u00a0in modo pi\u00f9 approfondito le funzioni.</p> <p>Ora possiamo riprendere alcuni esempi delle lezioni precedenti e ragionare su quali porzioni di codice siano da inserire in setup() e quali in draw(). Sottolineo ancora una volta che le linee inserite nel blocco di codice setup verranno eseguite\u00a0una sola volta all'avvio del programma mentre, quelle nel blocco draw, saranno processate continuamente dal nostro computer a una velocit\u00e0, di default in Processing, di\u00a060 frame per secondo, d'ora in poi abbreviato in fps.</p> <p>Impostare la dimensione della finestra \u00e8 un'operazione che pu\u00f2 e deve essere eseguita una volta sola; disegnare un cerchio in una determinata posizione e impostare il suo colore \u00e8 un'operazione che, invece, pu\u00f2 essere ripetuta.</p> <p>Ecco dunque che questo codice, preso dalla scorsa lezione:</p> <pre><code>size(500, 500);\nfill(255, 0, 0);\nellipse(250, 250, 150, 150);\n</code></pre> <p>diventa:</p> <pre><code>void setup() {\n  // Questo codice verr\u00e0 eseguito una sola volta\n  size(500, 500);\n}\n\nvoid draw() {\n  // Questo codice verr\u00e0 ripetuto a una frequenza di 60fps\n  fill(255, 0, 0);\n  ellipse(250, 250, 150, 150);\n}\n</code></pre> <p>Se copiate e incollate questi due esempi\u00a0in Processing e cliccate su Run non noterete alcuna differenza a livello visivo ma il computer sta processando questi programmi in modo diverso:</p> <p>Nel primo caso:</p> <pre><code>- Imposta la dimensione della finestra a 500x500px\n-\u00a0Imposta il colore di riempimento: RGB(255, 0, 0)\n- Disegna un ellisse con centro x = 250, y = 250, largh. = 150 e alt. = 150\n</code></pre> <p>Nel secondo caso:</p> <pre><code>- Imposta la dimensione della finestra a 500x500px\n- Imposta il colore di riempimento: RGB(255, 0, 0)\n- Disegna un ellisse con centro x = 250, y = 250, largh. = 150 e alt. = 150\n- Imposta il colore di riempimento: RGB(255, 0, 0)\n- Disegna un ellisse con centro x = 250, y = 250, largh. = 150 e alt. = 150\n- Imposta il colore di riempimento: RGB(255, 0, 0)\n- Disegna un ellisse con centro x = 250, y = 250, largh. = 150 e alt. = 150\n- Imposta il colore di riempimento: RGB(255, 0, 0)\n- Disegna un ellisse con centro x = 250, y = 250, largh. = 150 e alt. = 150\n...\n</code></pre> <p>Le ultime righe di informazioni sono ripetute 60 volte al secondo all'infinito finch\u00e9 non interrompiamo il programma premendo\u00a0il tasto\u00a0Stop.</p>"},{"location":"primi-passi/blocchi-di-codice-e-flusso-setup-e-draw/#la-nostra-prima-animazione","title":"La nostra prima animazione","text":"<p>Dal momento che con questo esempio non riusciamo a vedere nulla di diverso sullo schermo, rendiamo\u00a0le cose un po' pi\u00f9 interessanti introducendo un'altra novit\u00e0 di cui parleremo in modo approfondito nelle prossime lezioni: anzich\u00e9 impostare una posizione x e y predefinita, disegniamo il nostro cerchio rosso\u00a0in base alla posizione del mouse (mouseX\u00a0e mouseY):</p> <pre><code>void setup() {\n  size(500, 500);\n}\n\nvoid draw() {\n  background(0);\n  fill(255, 0, 0);\n  ellipse(mouseX, mouseY, 150, 150);\n}\n</code></pre> <p>Ecco cosa accade:</p> <p></p> <p>Anche se in questa immagine non si vede il cursore del mouse, il nostro occhio percepir\u00e0 il movimento del cerchio come un'animazione: abbiamo creato il nostro primo sketch interattivo perch\u00e9 risponde a un input esterno e che cambia col passare del tempo.</p> <p>A questo punto, per essere sicuri di aver compreso la differenza tra setup e draw possiamo domandarci: cosa accade se spostiamo background(0)\u00a0dal\u00a0blocco draw a quello di setup?</p> <pre><code>void setup() {\n  size(500, 500);\n  background(0);\n}\n\nvoid draw() {\n  fill(255, 0, 0);\n  ellipse(mouseX, mouseY, 150, 150);\n}\n</code></pre> <p>Questa volta il colore di sfondo viene impostato solo una volta all'avvio del programma, questo significa che ogni volta che verr\u00e0 mosso il mouse, un nuovo cerchio verr\u00e0 disegnato sopra ai precedenti.</p> <p></p>"},{"location":"primi-passi/colori-rgb/","title":"Colori RGB","text":""},{"location":"primi-passi/colori-rgb/#colori-rgb","title":"Colori RGB","text":"<p>Nell'ultimo post abbiamo imparato cosa sono le primitive 2D e siamo riusciti a far disegnare al nostro computer alcune semplici forme geometriche sullo schermo.\u00a0Nel realizzare questi semplici sketch forse qualcuno di voi avr\u00e0 notato una particolarit\u00e0: di default Processing colora di bianco l'interno della forma e di nero il bordo mentre lo sfondo dello sketch rimane grigio.</p> <p></p>"},{"location":"primi-passi/colori-rgb/#rgb-red-green-and-blue","title":"RGB: Red, Green and Blue","text":"<p>Prima di cominciare a utilizzare i colori \u00e8 importante capire come funzionano. Alle scuole elementari si impara che\u00a0attraverso la miscelazione dei tre colori primari,\u00a0rosso, giallo e blu, si possono ottenere\u00a0tutti i colori nelle diverse sfumature. Anche gli schermi funzionano in modo simile ma i tre colori di base\u00a0sono\u00a0rosso, verde e\u00a0blu in inglese RGB.</p> <p></p> <p>Grazie a questa immagine si pu\u00f2 capire come ottenere i colori secondari:</p> <ul> <li>rosso + verde = giallo</li> <li>rosso + blu = viola</li> <li>verde + blu = azzurro</li> <li>rosso + verde + blu = bianco</li> <li>nessun colore = nero</li> </ul>"},{"location":"primi-passi/colori-rgb/#le-funzioni-fill-e-stroke","title":"Le funzioni fill() e stroke()","text":"<p>In Processing esistono due funzioni per colorare le forme: fill() e\u00a0stroke(). Con la prima indichiamo il colore di\u00a0riempimento\u00a0della forma mentre, con la seconda, il colore del bordo.</p> <p>Quando lavoriamo nella modalit\u00e0 RGB, che \u00e8 quella di default, queste due funzioni possono accettare\u00a0uno,\u00a0due,\u00a0tre o quattro parametri.</p> <p>Facciamo degli esempi pratici:</p>"},{"location":"primi-passi/colori-rgb/#utilizzo-di-tre-parametri-per-assegnare-un-colore","title":"Utilizzo di tre parametri per assegnare un colore","text":"<pre><code>size(500, 500);\nfill(255, 0, 0);\nellipse(250, 250, 150, 150);\n</code></pre> <p>Se provo a tradurre in italiano quanto scritto nel codice, le istruzioni date al computer sarebbero:</p> <ul> <li>Disegna una finestra di 500 pixel di larghezza e 500 pixel di altezza. -\u00a0Colora la forma con la massima quantit\u00e0 di rosso (255), niente verde (0), e niente blu (0).</li> <li>Disegna un ellisse con centro nella posizione x = 250, y = 250, larghezza = 150 e altezza = 150.</li> </ul> <p>Non avendo specificato un parametro per il colore del bordo, come accaduto in precedenza, Processing utilizzer\u00e0 il parametro di default e colorer\u00e0 il bordo di nero.</p> <p>Ora facciamo una piccola modifica e aggiungiamo una riga al nostro codice:</p> <pre><code>size(500, 500);\nfill(255, 0, 0);\nstroke(0, 0, 255);\nellipse(250, 250, 150, 150);\n</code></pre> <p>Ora abbiamo aggiunto la funzione stroke()\u00a0assegnando i parametri rosso = 0, verde = 0, blu = 255 e questo \u00e8 il risultato:</p> <p></p> <p>Come avrete capito, se utilizzo tre parametri nelle funzioni\u00a0fill() e stroke() sto indicando la quantit\u00e0 di rosso, verde e blu il cui valore deve essere compreso tra 0, il valore minimo, e 255, quello massimo.</p>"},{"location":"primi-passi/colori-rgb/#un-parametro-solo-la-scala-di-grigi","title":"Un parametro solo: la scala di grigi","text":"<p>Come scritto in precedenza,\u00a0entrambe le funzioni possono accettare anche un solo parametro: in questo caso Processing considerer\u00e0\u00a0il valore inserito come valore assegnato a tutti e tre i parametri RGB.</p> <p>Scrivere:</p> <p><code>fill(127):</code></p> <p>Equivale a:</p> <p><code>fill(127, 127, 127);</code></p> <p>Facendo un po' di esperimenti con i colori, scoprirete che quando i parametri RGB sono\u00a0equivalenti, sto lavorando in scala di grigi.</p> <p>Per ottenere il bianco, infatti, mi baster\u00e0 scrivere: fill(255) mentre, per il nero fill(0).</p>"},{"location":"primi-passi/colori-rgb/#due-o-quattro-parametri-la-trasparenza","title":"Due o quattro parametri: la trasparenza","text":"<p>Se utilizziamo due parametri con il primo indichiamo il colore nella scala di grigi che abbiamo scelto e con il secondo impostiamo un livello di trasparenza in una scala da 0 (completamente trasparente) a 255 (completamente opaco).</p> <p>Quando, invece, utilizziamo quattro parametri stiamo aggiungendo\u00a0la\u00a0trasparenza a un colore specifico dettato dai primi tre parametri.</p> <pre><code>size(500, 500);\nfill(255, 0, 0, 100);\nstroke(0, 0, 255);\nellipse(250, 250, 150, 150);\n</code></pre> <p></p>"},{"location":"primi-passi/colori-rgb/#background-nofill-e-nostroke","title":"background(), noFill() e noStroke()","text":"<p>Finora abbiamo sempre parlato di colorare forme. Ma se volessimo modificare lo sfondo della finestra dobbiamo ricorrere alla funzione\u00a0background()\u00a0che, per quanto concerne\u00a0la sintassi e il numero di parametri accettati dalla funzione, ricalca\u00a0fill() e stroke().</p> <pre><code>background(0);\nsize(500, 500);\nfill(255, 0, 0, 100);\nstroke(0, 0, 255);\nellipse(250, 250, 150, 150);\n</code></pre> <p></p> <p>Con le funzioni\u00a0noFill() e noStroke() \u2013 attenzione alle maiuscole! \u2013 possiamo eliminare il colore del bordo o quello di riempimento. Com'\u00e8 facile intuire, queste funzioni non richiedono alcun parametro.</p>"},{"location":"primi-passi/colori-rgb/#color-selector","title":"Color selector","text":"<p>Giustamente vi starete chiedendo: come faccio a conoscere\u00a0i valori RGB di un determinato colore?\u00a0Non vi preoccupate, Processing mette a disposizione uno strumento molto utile chiamato Color Selector accessibile dal menu\u00a0Tools &gt; Color Selector\u00a0la cui funzione \u00e8 esattamente quella di aiutarvi nella selezione dei colori.</p> <p></p> <p>Oltre ai valori RGB, troviamo anche quelli HSB e Hexadecimal di cui parleremo prossimamente.</p>"},{"location":"primi-passi/colori-rgb/#mettiamo-tutto-insieme","title":"Mettiamo tutto insieme","text":""},{"location":"primi-passi/colori-rgb/#esempio-1","title":"Esempio 1:","text":"<pre><code>/*\n *  Colori RGB\n *  Federico Pepe\n *  http://blog.federicopepe.com/processing\n */\n\n// Impostiamo la dimensione della finestra a 500x500px\nsize(500, 500);\n// Impostiamo lo sfondo di colore bianco\nbackground(255);\n// Impostiamo di non avere un bordo\nnoStroke();\n// Impostiamo una tonalit\u00e0 di rosso come riempimento\nfill(255, 157, 157);\n// Disegnamo il primo cerchio\nellipse(100, 250, 100, 100);\n// Impostiamo il bordo di colore nero\nstroke(0);\n// Disegniamo il secondo cerchio\nellipse(250, 250, 100, 100);\n// Impostiamo una tonalit\u00e0 di verde come riempimento\nfill(157, 255, 179);\n// Disegniamo il terzo cerchio\nellipse(400, 250, 100, 100);\n</code></pre> <p>Sono tante linee di codice ma non spaventatevi! Prima di analizzare il risultato vorrei introdurre un'ultima novit\u00e0: l'utilizzo dei commenti nel codice.</p> <p>I programmatori\u00a0spesso commentano il proprio codice per spiegare brevemente come funziona quella porzione di codice oppure per lasciare dei promemoria o delle indicazioni. I commenti sono utili sia se dobbiamo condividere il nostro codice con altre persone sia per ricordare a noi stessi come funzionava quel particolare programma.</p> <p>Quando diventerete dei programmatori esperti, sar\u00e0 interessare recuperare dall'hard disk i vostri primi programmi e confrontarli con gli ultimi. \u00c8 per questo che io ho preso l'abitudine di inserire sempre, all'inizio di ogni programma, la data di creazione o di ultima modifica.</p> <p>Se dovete scrivere un commento di molte righe di testo come, ad esempio, l'intestazione all'inizio del programma, dovete utilizzare\u00a0/* per indicare l'inizio del commento e */ per indicarne la fine.</p> <p>Se, invece, il commento \u00e8 di una sola riga, \u00e8 sufficiente scrivere //\u00a0all'inizio della riga stessa.</p> <p>Il codice qui sopra dar\u00e0 questo risultato:</p> <p></p> <p>La cosa interessante da notare \u00e8 che una volta specificato un colore con la funzione fill() o stroke(), rimarr\u00e0 impostato anche per le forme successive finch\u00e9 non utilizziamo la funzione noFill() o noStroke() oppure finch\u00e9 non impostiamo nuovamente\u00a0il colore.</p> <p>Nello sketch di esempio, infatti, il riempimento di colore rosso viene settato solo una volta all'inizio eppure\u00a0viene applicato ai primi due cerchi cos\u00ec come il bordo nero, inserito subito prima di disegnare la seconda forma, rimane anche per la terza.</p>"},{"location":"primi-passi/colori-rgb/#esempio-2","title":"Esempio 2","text":"<pre><code>/*\n *  Colori RGB e trasparenza\n *  Federico Pepe\n *  http://blog.federicopepe.com/processing\n */\n\n// Impostiamo la dimensione della finestra a 500x500px\nsize(500, 500);\n// Impostiamo lo sfondo di colore nero\nbackground(0);\n// Impostiamo di non avere un bordo\nnoStroke();\n// Impostiamo una tonalit\u00e0 di rosso come riempimento\nfill(255, 0, 0, 127);\n// Disegnamo il primo cerchio\nellipse(200, 250, 150, 150);\n// Disegniamo il secondo cerchio\nellipse(250, 250, 150, 150);\n// Impostiamo una tonalit\u00e0 di verde come riempimento\nfill(127, 255, 127);\n// Disegniamo il terzo cerchio\nellipse(300, 250, 150, 150);\n</code></pre> <p>In questo secondo esempio ho utilizzato la trasparenza nei primi due cerchi rossi (notate cosa succede quando si sovrappongono). Il terzo cerchio, quello verde, non avendo un parametro per la trasparenza ed essendo l'ultimo inserito nello sketch viene disegnato \"sopra\" gli altri due.</p>"},{"location":"primi-passi/colori-rgb/#compiti-per-casa","title":"Compiti per casa","text":"<p>Arrivati a questo punto, \u00e8 il momento di mettersi in gioco. Imparare a programmare non significa soltanto studiare, capire la sintassi e copiare-incollare del codice trovato su internet ma anche porsi dei problemi e provare a risolverli autonomamente.</p> <p>Ho pensato che per rendere questa serie di post pi\u00f9 interessante fosse necessario introdurre dei compiti a casa per dare la possibilit\u00e0, a voi che leggete, di sbattere un po' la testa.</p> <p>Il compito di questa settimana \u00e8 realizzare uno sketch ispirato alle composizioni geometriche di Piet Mondrian. Potete inviare le vostre soluzioni nei commenti qui sotto oppure via twitter @fedpep.</p>"},{"location":"primi-passi/controlli-condizionali-if-else-if-else/","title":"if, else, if else","text":""},{"location":"primi-passi/controlli-condizionali-if-else-if-else/#controlli-condizionali-if-else-if-else","title":"Controlli condizionali: if, else if, else","text":"<p>Abbandoniamo temporaneamente la casualit\u00e0 generata dalla funzione random(), che abbiamo visto la scorsa settimana, per immergerci nel mondo dei\u00a0controlli condizionali.</p> <p>Nella vita di tutti i giorni siamo condizionati da scelte: siamo abituati a pensare che\u00a0se\u00a0facciamo qualcosa\u00a0allora\u00a0accadr\u00e0 qualcosa di specifico altrimenti (cio\u00e8 nel caso in cui non si verifichi la condizione iniziale), non succeder\u00e0\u00a0nulla.</p> <p>Il nostro obiettivo di oggi \u00e8 avere la possibilit\u00e0 di creare una logica simile all'interno dei nostri programmi ovvero far eseguire determinate parti di codice solo al verificarsi di\u00a0condizioni specifiche. Stiamo cercando di fare qualcosa di simile a quello che abbiamo gi\u00e0 visto con mousePressed() e keyPressed() ma, questa volta, vogliamo avere ancora pi\u00f9 controllo.</p>"},{"location":"primi-passi/controlli-condizionali-if-else-if-else/#espressioni-e-variabili-booleane","title":"Espressioni e variabili booleane","text":"<p>I computer, purtroppo (o per fortuna), non sono macchine intelligenti e\u00a0seguono una logica abbastanza semplice: una condizione pu\u00f2 essere\u00a0vera oppure\u00a0falsa, in inglese\u00a0true\u00a0o\u00a0false.\u00a0Nell'elenco dei tipi di variabili pi\u00f9 comuni ho\u00a0volutamente escluso quelle di tipo booleano: variabili, dunque, che possiamo creare e inizializzare e a cui possiamo assegnare solo uno di questi due valori.</p> <p>Una cosa molto importante \u00e8 che non pu\u00f2 esistere in nessun programma una variabile che sia contemporaneamente\u00a0vera\u00a0e\u00a0falsa.</p>"},{"location":"primi-passi/controlli-condizionali-if-else-if-else/#operatori-di-confronto","title":"Operatori di confronto","text":"<p>Dal momento che ci troveremo spesso a lavorare con dei valori numerici,\u00a0possiamo utilizzare gli operatori di confronto/comparazione:</p> <ul> <li>Maggiore: &gt;</li> <li>Minore: &lt;</li> <li>Maggiore o uguale: &gt;=</li> <li>Minore o uguale: &lt;=</li> <li>Uguale: ==</li> <li>Diverso: !=</li> </ul>"},{"location":"primi-passi/controlli-condizionali-if-else-if-else/#controlli-condizionali","title":"Controlli condizionali","text":"<p>Per inserire un controllo condizionale \u00e8 sufficiente tradurre in inglese le parole che ho sottolineato precedentemente e\u00a0creare dei blocchi di codice con le classiche parentesi graffe: il se diventa, dunque,\u00a0if mentre l'altrimenti si traduce con\u00a0else.</p> <pre><code>if(condizione) {\n /* La porzione di codice qui inserita verr\u00e0 eseguita\n * esclusivamente se la condizione sopra indicata\n * sar\u00e0 true, quindi vera.\n */\n} else {\n /* Nel caso in cui la condizione sopra inserita NON\n * sia vera, verr\u00e0 eseguita questa porzione di codice\n */\n}\n</code></pre> <p>Nel campo\u00a0condizione dobbiamo inserire la nostra espressione di controllo.</p>"},{"location":"primi-passi/controlli-condizionali-if-else-if-else/#esempio-1","title":"Esempio 1:","text":"<pre><code>/*\n * Controlli condizionali: if, else if, else\n * by Federico Pepe\n * http://blog.federicopepe.com\n*/\nvoid setup() {\n  size(500, 500);\n  stroke(255);\n}\nvoid draw() {\n  if(mouseX &gt; width/2) {\n    background(0);\n  } else {\n    background(127);\n  }\n  line(width/2, 0, width/2, height); \n}\n</code></pre> <p>Con questo programma verifichiamo se la posizione X del mouse \u00e8 maggiore della met\u00e0 della larghezza. In caso positivo (true), lo sfondo della finestra verr\u00e0 colorato di nero, in caso contrario (false) di un grigio scuro.</p> <p>Per comodit\u00e0 ho creato una linea bianca che mi segnala esattamente il punto da oltrepassare per vedere lo sfondo cambiare colore. Avendo utilizzato la condizione maggiore se il valore di mouse X \u00e8 pari a 250, la met\u00e0 della larghezza, la condizione sar\u00e0 ancora considerata false.</p>"},{"location":"primi-passi/controlli-condizionali-if-else-if-else/#esempio-2","title":"Esempio 2:","text":"<pre><code>/*\n * Controlli condizionali: if, else if, else\n * by Federico Pepe\n * http://blog.federicopepe.com\n */\nvoid setup() {\n  size(500, 500);\n  stroke(255);\n}\nvoid draw() {\n  if (mouseX &gt; 200) {\n    background(200);\n  } else if (mouseX &gt; 100) {\n    background(127);\n  } else {\n    background(0);\n  }\n  line(100, 0, 100, height);\n  line(200, 0, 200, height);\n}\n</code></pre> <p>In questo secondo esempio abbiamo due condizioni differenti: se la X del mouse \u00e8 maggiore di 200 lo sfondo sar\u00e0 grigio chiaro, altrimenti se\u00a0(else if)\u00a0\u00e8 maggiore di 100 lo sfondo sar\u00e0 grigio\u00a0scuro, altrimenti sar\u00e0 nero. \u00c8 possibile concatenare molteplici condizioni else if per coprire tutti i casi che ci interessa verificare.</p> <p>La prossima settimana faremo altri esempi per essere sicuri di aver appreso il funzionamento dei controlli condizionali; nel frattempo sbizzarritevi con i vostri sketch.</p>"},{"location":"primi-passi/controlli-condizionali-ii-operatori-logici/","title":"Operatori logici","text":""},{"location":"primi-passi/controlli-condizionali-ii-operatori-logici/#controlli-condizionali-operatori-logici","title":"Controlli Condizionali: operatori logici","text":"<p>La scorsa settimana abbiamo imparato a utilizzare i controlli condizionali if, else if ed else per fare in modo che i nostri programmi eseguano determinate azioni al verificarsi di condizioni prestabilite.</p>"},{"location":"primi-passi/controlli-condizionali-ii-operatori-logici/#operatori-logici","title":"Operatori Logici","text":"<p>Oggi approfondiamo l'argomento introducendo gli\u00a0Operatori Logici. Pu\u00f2 capitare, infatti, di avere la necessit\u00e0 di concatenare insieme pi\u00f9 controlli condizionali:\u00a0immaginiamo, ad esempio, di voler realizzare un programma\u00a0in cui il colore dello sfondo cambia in base sia alla posizione X che Y del mouse.</p> <p>In italiano dovremmo scrivere una cosa simile a:</p> <p>SE la posizione X del mouse \u00e8 inferiore alla met\u00e0 della larghezza della finestra E la posizione Y del mouse \u00e8 inferiore alla met\u00e0 dell'altezza della finestra\u00a0ALLORA\u00a0colora lo sfondo di nero.</p> <p>Possiamo tradurre in codice la frase di prima\u00a0cos\u00ec:</p> <pre><code>void setup() {\n  size(500, 500);\n}\n\nvoid draw() {\n  if(mouseX &lt; width/2) {\n    if(mouseY &lt; height/2 {\n    }\n  }\n}\n</code></pre> <p>Oppure, in modo pi\u00f9 elegante:</p> <pre><code>void setup() {\n  size(500, 500);\n}\n\nvoid draw() {\n  if((mouseX &lt; width/2) &amp;&amp; (mouseY &lt; height/2)) {\n  }\n}\n</code></pre> <p>Gli operatori logici che possiamo utilizzare sono fondamentalmente 3:</p> <ul> <li>&amp;&amp;\u00a0(AND) quando entrambe le condizioni devono essere true</li> <li>|| (OR) quando \u00e8 sufficiente che una delle due condizioni sia\u00a0true</li> <li>! (NOT) per testare se la condizione \u00e8\u00a0not true oppure not false</li> </ul> <p>Faccio una precisazione: bench\u00e9 non sia richiesto, se non in casi particolari, che le condizioni prima e dopo l'operatore logico siano racchiuse tra parentesi, io preferisco sempre aggiungere delle parentesi tonde per essere sicuro di rendere chiaro quali condizioni sto testando.</p> <p>Ecco un esempio:</p> <pre><code>void setup() {\n  size(500, 500);\n  stroke(255);\n}\n\nvoid draw() {\n  if((mouseX &lt; width/2) &amp;&amp; (mouseY &lt; height/2)) {\n    background(255, 0, 0);\n  } else if((mouseX &gt; width/2) &amp;&amp; (mouseY &lt; height/2)) {\n    background(0, 255, 0);\n  } else {\n    background(0);\n  }\n  line(width/2, 0, width/2, height);\n  line(0, height/2, width, height/2);\n}\n</code></pre> <p>Traduco il codice in italiano:</p> <p>Imposto una finestra di dimensioni 500x500px e che le linee di riferimento disegnate saranno di colore bianco. SE la posizione X del mouse sar\u00e0 inferiore alla met\u00e0 della larghezza della finestra E la posizione Y del mouse sar\u00e0 inferiore alla met\u00e0 dell'altezza della finestra allora lo sfondo sar\u00e0 rosso ALTRIMENTI SE la posizione X del mouse sar\u00e0 superiore alla met\u00e0 della larghezza della finestra E la posizione Y del mouse sar\u00e0 inferiore alla met\u00e0 dell'altezza della finestra allora lo sfondo sar\u00e0 verde ALTRIMENTI lo sfondo sar\u00e0 nero.</p> <p>Questo \u00e8 il risultato:</p> <p></p> <p></p>"},{"location":"primi-passi/controlli-condizionali-ii-operatori-logici/#compiti-per-casa","title":"Compiti per casa","text":"<p>Prendendo spunto dal codice che abbiamo scritto oggi,\u00a0scrivete un programma in cui la finestra, con lo sfondo di colore nero, sia divisa in 4 quadranti (consiglio di fare delle linee di riferimento di colore bianco). L'obiettivo del vostro programma \u00e8 fare in modo che si evidenzi con il\u00a0colore bianco il quadrante su cui passate sopra con il mouse facendo in modo che\u00a0gli altri 3 rimangono di colore nero.</p> <p>Buon lavoro!</p>"},{"location":"primi-passi/controlli-condizionali-iii-variabili-booleane/","title":"Variabili booleane","text":""},{"location":"primi-passi/controlli-condizionali-iii-variabili-booleane/#controlli-condizionali-iii-variabili-booleane","title":"Controlli condizionali III: Variabili booleane","text":"<p>Nel primo post dedicato ai controlli condizionali ho\u00a0fatto un accenno alle variabili di tipo booleano anche se non mi sono soffermato troppo su di esse. Per il momento sappiamo solo che possono assumere un valore\u00a0true oppure\u00a0false\u00a0ma non abbiamo ancora imparato come dichiararle\u00a0o\u00a0utilizzarle.</p> <p>Ovviamente dobbiamo rispettare\u00a0i principi che abbiamo gi\u00e0 visto quando abbiamo parlato di variabili: in fase di dichiarazione dobbiamo assegnare un data type \u2013 boolean in questo caso \u2013 e un nome:</p> <p><code>boolean var = true;</code></p> <p>Ecco che abbiamo creato una variabile chiamata\u00a0var\u00a0di tipo booleano il cui suo valore iniziale sia\u00a0true.</p> <p>Come possiamo utilizzare questa variabile? Ecco un esempio pratico:</p> <pre><code>boolean var = true;\nint ellipseX = 0;\n\nvoid setup() {\n  size(500, 500);\n}\n\nvoid draw() {\n  background(0);\n  ellipse(ellipseX, height/2, 50, 50);\n  if(var) {\n    ellipseX++;\n  }\n}\n\nvoid mousePressed() {\n  var = !var;\n}\n</code></pre> <p>Questo programma \u00e8 molto simile a un altro programma che abbiamo gi\u00e0 visto ma c'\u00e8 una differenza sostanziale: ora, infatti, abbiamo un maggior controllo sul nostro cerchio: quando clicchiamo il mouse all'interno della finestra, il cerchio\u00a0si ferma.</p> <p>All'interno del ciclo draw() aumentiamo il valore della variabile ellipseX\u00a0\u2013 che determina la posizione del cerchio \u2013 solo nel caso in cui la variabile booleana nominata\u00a0var sia\u00a0true.</p> <p>Nella funzione mousePressed()\u00a0abbiamo usato l'operatore logico NOT che inverte il valore della variabile\u00a0var. Se infatti partiamo dal presupposto che la variabile sia\u00a0true, come previsto dall'inizializzazione, al click del mouse\u00a0var diventer\u00e0 NOT true quindi false. Viceversa, se la variabile ha un valore false al click viene assegnato un valore NOT false quindi true.</p> <p>Mi rendo conto che questo passaggio possa essere un po'\u00a0ostico quindi, per aiutarvi, riscrivo la funzione mousePressed() in modo pi\u00f9\u00a0semplice:</p> <pre><code>void mousePressed() {\n if(var) {\n var = false;\n } else {\n var = true;\n }\n}\n</code></pre> <p>Con l'operatore NOT ho reso il mio codice pi\u00f9 leggibile riducendo il numero di righe, da cinque a una soltanto, per cambiare il valore della variabile.</p> <p>A questo punto vi propongo un altro esercizio: e se volessi fare in modo che il mio cerchio anzich\u00e9 fermarsi torni indietro al click del mouse? Buon lavoro!</p>"},{"location":"primi-passi/esercizio-1-piet-mondrian/","title":"Esercizio: Piet Mondrian","text":""},{"location":"primi-passi/esercizio-1-piet-mondrian/#esercizio-piet-mondrian","title":"Esercizio: Piet Mondrian","text":"<p>Ecco\u00a0una delle possibili soluzioni del primo\u00a0compito a casa:\u00a0realizzare uno sketch ispirato alle composizioni geometriche di Piet Mondrian.</p> <p>Come ho gi\u00e0 avuto modo di scrivere:</p> <p>Imparare a programmare non significa soltanto studiare, capire la sintassi e copiare-incollare del codice trovato su internet ma anche porsi dei problemi e provare a risolverli autonomamente.</p> <p>Il mio consiglio \u00e8, ancora una volta, non fermarsi a guardare la soluzione da me proposta ma provare a realizzare una soluzione alternativa. Vi invito a\u00a0condividere i vostri sketch nei commenti!</p> <p></p> <p>E il codice:</p> <pre><code>/*\n *  Esercizio 1: \"Piet Mondrian\"\n *  by Federico Pepe\n *  http://blog.federicopepe.com/processing\n */\nbackground(0);\nsize(700, 500);\nnoStroke();\nfill(255);\nrect(10, 10, 100, 100);\nrect(10, 125, 100, 250);\nfill(0, 0, 255);\nrect(10, 390, 100, 100);\nfill(255, 0, 0);\nrect(120, 10, 400, 365);\nfill(255, 255, 0);\nrect(120, 390, 400, 100);\nfill(255);\nrect(530, 10, 160, 250);\nrect(530, 270, 160, 220);\n</code></pre>"},{"location":"primi-passi/esercizio-2-i-quattro-quadranti/","title":"Esercizio 2","text":""},{"location":"primi-passi/esercizio-2-i-quattro-quadranti/#esercizio-2-i-quattro-quadranti","title":"Esercizio 2: I quattro quadranti","text":"<p>Nell'ultima lezione pubblicata abbiamo parlato di controlli condizionali e operatori logici. Ecco la soluzione all'esercizio dei \"quattro quadranti\":</p> <pre><code>/*\n *  Esercizio 2: I quattro quadranti\n *  by Federico Pepe\n *  http://blog.federicopepe.com/processing\n */\n\n void setup() {\n   size(500, 500);\n   stroke(255);\n   fill(255);\n }\n\n void draw() {\n   // Imposto il colore nero di background\n   background(0);\n\n   // Verifico la posizione X e Y del mouse e disegno il rettangolo\n   // nel quadrante in cui si trova il mouse\n   if(mouseX &lt; width/2 &amp;&amp; mouseY &lt; height/2) {\n     rect(0, 0, width/2, height/2);\n   } else if(mouseX &gt; width/2 &amp;&amp; mouseY &lt; height/2) {\n     rect(width/2, 0, width/2, height/2);\n   } else if(mouseX &lt; width/2 &amp;&amp; mouseY &gt; height/2) {\n     rect(0, height/2, width/2, height/2);\n   } else {\n     rect(width/2, height/2, width/2, height/2);\n   }\n   // Disegno le linee di riferimento\n   line(width/2, 0, width/2, height);\n   line(0, height/2, width, height/2);\n }\n</code></pre> <p>Le linee di codice sembrano molte ma, in realt\u00e0, la logica \u00e8 piuttosto semplice. Nella parte di setup() imposto la grandezza della finestra e alcuni parametri di base: il colore delle linee di riferimento e il fill sar\u00e0 bianco.</p> <p>All'interno di draw() verifico la posizione X e Y del mouse all'interno di una serie di controlli condizionali. Traduco in pseudocodice la condizione che vado a controllare nel primo\u00a0if: se la posizione X del mouse ha un valore minore della met\u00e0 della larghezza della finestra e la posizione Y del mouse ha un valore minore della met\u00e0 dell'altezza della finestra allora disegner\u00f2 un rettangolo il cui punto di partenza sia l'angolo in alto a sinistra, ovvero il punto con coordinate 0, 0 e le cui dimensioni siano la met\u00e0 della finestra sia in larghezza che in altezza.</p> <p>Negli else if successivi verifico le altre condizioni e disegno il\u00a0quadrato bianco di conseguenza. Nell'ultimo else non occorre porre nessuna condizione perch\u00e9 \u00e8, per esclusione, l'ultima possibilit\u00e0 ovvero che il mouse si trovi nel quadrante in basso a destra.</p> <p>Perch\u00e9 utilizzo delle variabili invece di parametri hard-coded? Avrei\u00a0potuto benissimo scrivere:</p> <p><code>if(mouseX &lt; 250 &amp;&amp; mouseY &lt; 250)</code></p> <p>In tal caso, per\u00f2, il codice funzionerebbe\u00a0correttamente solo nel caso in cui\u00a0le dimensioni della mia finestra siano impostate, come nell'esempio, a 500 x 500 pixel. Con le variabili, posso modificare i parametri in size e avere un programma sempre funzionante.</p>"},{"location":"primi-passi/esercizio-bouncing-ball-1/","title":"Esercizio Bouncing Ball 1","text":""},{"location":"primi-passi/esercizio-bouncing-ball-1/#esercizio-bouncing-ball-parte-1","title":"Esercizio: Bouncing Ball, parte 1","text":"<p>Con il post di oggi, cominciamo a lavorare a un classico problema di programmazione che raccoglie\u00a0gran parte delle nozioni viste finora. L'evoluzione di questo esercizio comprender\u00e0, ovviamente, l'utilizzo di funzioni personalizzate e ci servir\u00e0 per\u00a0cominciare a parlare di\u00a0programmazione orientata agli oggetti.</p>"},{"location":"primi-passi/esercizio-bouncing-ball-1/#punto-di-partenza","title":"Punto di partenza","text":"<p>Il nostro obiettivo \u00e8 scrivere un programma in cui faremo muovere un\u00a0cerchio\u00a0all'interno della finestra. Una volta raggiunto\u00a0un bordo, il nostro cerchio non dovr\u00e0 fermarsi o \"sparire\" uscendo dallo spazio a nostra disposizione ma dovr\u00e0\u00a0invertire la direzione del suo movimento.</p> <p>Per comodit\u00e0\u00a0e per seguire un modello di sviluppo coerente, suddivider\u00f2 il nostro obiettivo in problemi pi\u00f9 semplici che affronter\u00f2 uno alla volta facendo riferimento ai post in cui abbiamo gi\u00e0 trattato problemi simili.</p>"},{"location":"primi-passi/esercizio-bouncing-ball-1/#disegniamo-il-cerchio-e-facciamolo-muovere-in-una-direzione","title":"Disegniamo il cerchio e facciamolo muovere in una direzione","text":"<p>Questa \u00e8 la parte pi\u00f9 semplice: ricordate il post\u00a0Variabili in Processing: operazioni matematiche?</p> <p>A differenza dell'esempio sopra citato, creiamo uno sketch con due variabili: ellipseX e ellipseY\u00a0che utilizzeremo per determinare la posizione del cerchio nella finestra.</p> <pre><code>int ellipseX;\nint ellipseY;\n\nvoid setup() {\n  size(700, 500);\n  ellipseX = 0;\n  ellipseY = height/2;\n}\n\nvoid draw() {\n  background(0);\n  ellipse(ellipseX, ellipseY, 50, 50);\n  ellipseX++;\n}\n</code></pre> <p>Il programma funziona correttamente: il cerchio si muove da sinistra verso destra. L'unico problema \u00e8 che una volta raggiunto il bordo destro, la variabile ellipseX continua ad aumentare il suo valore di 1 fino a far scomparire il cerchio. Attenzione: il nostro cerchio \u00e8 sparito dalla finestra ma, anche se noi non lo vediamo, sta proseguendo il suo movimento verso destra.</p>"},{"location":"primi-passi/esercizio-bouncing-ball-1/#abbiamo-raggiunto-il-bordo","title":"Abbiamo raggiunto il bordo?","text":"<pre><code>int ellipseX;\nint ellipseY;\n\nvoid setup() {\n  size(700, 500);\n  ellipseX = 0;\n  ellipseY = height/2;\n}\n\nvoid draw() {\n  background(0);\n  ellipse(ellipseX, ellipseY, 50, 50);\n  if(ellipseX &lt; width) {\n    ellipseX++;\n  }\n}\n</code></pre> <p>Inseriamo un semplice controllo condizionale: se ellipseX \u00e8 minore della larghezza della finestra aumentiamo la variabile. Quando ellipseX sar\u00e0 uguale a 700, in questo caso specifico, il cerchio si fermer\u00e0.</p>"},{"location":"primi-passi/esercizio-bouncing-ball-1/#invertiamo-la-direzione-del-movimento","title":"Invertiamo la direzione del movimento","text":"<p>A questo punto dobbiamo invertire la direzione del movimento. Normalmente si \u00e8 portati a pensare a una cosa del genere:</p> <pre><code>int ellipseX;\nint ellipseY;\n\nvoid setup() {\n  size(700, 500);\n  ellipseX = 0;\n  ellipseY = height/2;\n}\n\nvoid draw() {\n  background(0);\n  ellipse(ellipseX, ellipseY, 50, 50);\n  if(ellipseX &lt; width) {\n    ellipseX++;\n  } else {\n    ellipseX--;\n  }\n}\n</code></pre> <p>Se avviate questo sketch vi accorgerete, per\u00f2, che il cerchio non torna indietro. Com'\u00e8 possibile? Analizziamo i valori che assume la variabile ellipseX: ricordatevi che \u00e8 sempre possibile inserire println();\u00a0per fare il debugging.</p> <p>Cliccando su Run, il valore di ellipseX \u00e8 uguale a 0. A ogni ciclo draw() ellipseX viene aumentato di 1 quindi la variabile assumer\u00e0 i valori, 1, 2, 3 ecc... fino ad arrivare a 700. Chiaramente a ogni ciclo viene effettuato il controllo if: se ellipseX \u00e8 minore della variabile width (che ha valore 700) allora verr\u00e0 aggiunto 1.</p> <p>Quando ellipseX assume il valore 700, la condizione if(ellipseX &lt; width) sar\u00e0 false e\u00a0scatter\u00e0 il blocco di codice presente nell'else e quindi a ellipseX verr\u00e0 assegnato\u00a0un valore di 699. Al ciclo successivo il controllo if(ellipseX &lt; width) sar\u00e0 di nuovo\u00a0true e quindi alla variabile verr\u00e0 sommato 1 e torner\u00e0 a un valore di 700.</p> <p>Questo si ripeter\u00e0 all'infinito e la variabile assumer\u00e0 solo valori pari a 699 o 700 bloccando, di fatto, il movimento del cerchio.</p> <p>Per invertire la direzione del movimento dobbiamo fare qualcosa in pi\u00f9:\u00a0aggiungere una variabile per controllare la direzione dello spostamento a cui invertiremo il segno (da positivo a negativo) per far si che il cerchio torni effettivamente indietro.</p> <p>Per cambiare il segno di un numero da positivo a negativo sappiamo che \u00e8 sufficiente moltiplicarlo per -1. Mi rendo conto che, spiegandolo a parole, questo passaggio \u00e8 un po' complicato; per aiutarvi nella comprensione ho inserito un println() alla fine del codice per mostrare in console i valori di ellipseX e speedX.</p> <p>Altra puntualizzazione: ho modificato anche il controllo condizionale da if(ellipseX &lt; width) a if(ellipseX &gt; width) per far funzionare il programma correttamente e cambiare il segno solo al raggiungimento del bordo destro.</p> <pre><code>int ellipseX;\nint ellipseY;\nint speedX = 1;\n\nvoid setup() {\n  size(700, 500);\n  ellipseX = 0;\n  ellipseY = height/2;\n}\n\nvoid draw() {\n  background(0);\n  ellipse(ellipseX, ellipseY, 50, 50);\n  if(ellipseX &gt; width) {\n    speedX = speedX * -1;\n  }\n  ellipseX = ellipseX + speedX;\n  println(\"EllipseX: \" + ellipseX + \" SpeedX: \" + speedX);\n}\n</code></pre> <p>Il nostro cerchio ora torna indietro ma, una volta raggiunto il bordo sinistro, scompare nuovamente dalla finestra.</p> <p>Ora tocca a voi dimostrare di aver capito come procedere: dovete fare in modo che il cerchio torni indietro una volta raggiunto anche il bordo sinistro e poi, ovviamente, implementare lo stesso procedimento anche sull'asse verticale. La soluzione sar\u00e0 pubblicata nella seconda parte!</p>"},{"location":"primi-passi/esercizio-bouncing-ball-parte-2/","title":"Esercizio Bouncing Ball 2","text":""},{"location":"primi-passi/esercizio-bouncing-ball-parte-2/#esercizio-bouncing-ball-parte-2","title":"Esercizio: Bouncing Ball, parte 2","text":"<p>Prima di procedere con la lettura di questo post, assicuratevi di aver letto la prima parte: Esercizio: Bouncing Ball, parte 1. Avete provato a trovare la soluzione al quesito posto alla fine dell'articolo?</p>"},{"location":"primi-passi/esercizio-bouncing-ball-parte-2/#bouncing-ball","title":"Bouncing Ball","text":"<p>Eravamo rimasti con un cerchio che, una volta disegnato sullo schermo, si muoveva da destra verso sinistra e, una volta raggiunto il bordo, invertiva il suo moto tornando indietro. Una volta raggiunto il bordo destro, per\u00f2, proseguiva il suo moto\u00a0sparendo dalla nostra vista.</p> <p>Per fare in modo che il cerchio rimbalzi avanti e indietro, \u00e8 sufficiente aggiungere una semplice condizione:</p> <p>if(ellipseX &gt; width || ellipseX &lt; 0)</p> <p>Ecco quindi il codice completo:</p> <pre><code>int ellipseX;\nint ellipseY;\nint speedX = 1;\n\nvoid setup() {\n  size(700, 500);\n  ellipseX = 0;\n  ellipseY = height/2;\n}\n\nvoid draw() {\n  background(0);\n  ellipse(ellipseX, ellipseY, 50, 50);\n  if(ellipseX &gt; width || ellipseX &lt; 0) {\n    speedX = speedX * -1;\n  }\n  ellipseX = ellipseX + speedX;\n  println(\"EllipseX: \" + ellipseX + \" SpeedX: \" + speedX);\n}\n</code></pre>"},{"location":"primi-passi/esercizio-bouncing-ball-parte-2/#aggiungiamo-anche-lasse-verticale","title":"Aggiungiamo anche l'asse verticale","text":"<p>Ora che la nostra \"palla\" si muove solo sull'asse X, implementiamo il movimento anche sull'asse verticale. La variabile ellipseY \u00e8 gi\u00e0 presente nel nostro codice, dobbiamo solo creare una nuova variabile speedY e ricopiare parte del codice modificando solo i parametri necessari:</p> <pre><code>int ellipseX;\nint ellipseY;\nint speedX = 1;\nint speedY = 1;\n\nvoid setup() {\n  size(700, 500);\n  ellipseX = 0;\n  ellipseY = height/2;\n}\n\nvoid draw() {\n  background(0);\n  ellipse(ellipseX, ellipseY, 50, 50);\n  if(ellipseX &gt; width || ellipseX &lt; 0) {\n    speedX = speedX * -1;\n  }\n  if(ellipseY &gt; height || ellipseY &lt; 0) {\n    speedY = speedY * -1;\n  }\n  ellipseX = ellipseX + speedX;\n  ellipseY = ellipseY + speedY;\n  //println(\"EllipseX: \" + ellipseX + \" SpeedX: \" + speedX);\n}\n</code></pre> <p>Utilizzando delle variabili per controllare la velocit\u00e0, variando un numero possiamo modificare l'andamento della nostra palla. Se assegniamo a speedX o speedY un valore iniziale di 5, il cerchio si muover\u00e0 molto pi\u00f9 velocemente.</p> <p>Eliminando\u00a0background(0)\u00a0all'inizio del blocco di codice draw(), potrete tenere monitorato il movimento della vostra palla sullo schermo, come mostrato nell'immagine qui sotto:</p> <p></p> <p>A questo punto il nostro sketch \u00e8 pronto per essere migliorato utilizzando funzioni e oggetti; nel prossimo post scopriremo come rendere il nostro codice modulare.</p>"},{"location":"primi-passi/esercizio-bouncing-ball-parte-3-oop/","title":"Esercizio Bouncing Ball 3","text":""},{"location":"primi-passi/esercizio-bouncing-ball-parte-3-oop/#esercizio-bouncing-ball-parte-3-oop","title":"Esercizio: Bouncing Ball, parte 3 (OOP)","text":"<p>Se vi siete persi gli articoli precedenti, qui trovate la parte 1 e la parte 2 di questo esercizio. Con questo post\u00a0non aggiungeremo niente di nuovo al nostro programma ma rivedremo per intero il codice per trasformarlo in una versione ad oggetti.</p>"},{"location":"primi-passi/esercizio-bouncing-ball-parte-3-oop/#bouncing-ball-object-oriented","title":"Bouncing Ball Object Oriented","text":"<p>Per prima cosa aggiungiamo\u00a0una nuova Tab che chiameremo Ball, come la classe che creeremo: </p><pre><code>class Ball {\n\n}\n</code></pre> Per non dimenticarci il constructor, aggiungiamo subito la sintassi necessaria: <pre><code>class Ball {\n Ball() {\n }\n}\n</code></pre> A questo punto facciamo copia-incolla\u00a0delle porzioni di codice che, nel nostro sketch principale, riguardano la nostra palla: ricordatevi di portare nella classe sia le variabili che le funzioni. <p>Questo\u00a0\u00e8 il risultato finale:</p> <pre><code>class Ball {\n  int ellipseX;\n  int ellipseY;\n  int speedX;\n  int speedY;\n\n  Ball() {\n    ellipseX = 0;\n    ellipseY = height/2;\n    speedX = 1;\n    speedY = 1;\n  }\n\n  void display() {\n    ellipse(ellipseX, ellipseY, 50, 50);\n  }\n\n  void move() {\n    ellipseX = ellipseX + speedX;\n    ellipseY = ellipseY + speedY;\n  }\n\n  void checkEdges() {\n    if (ellipseX &gt; width || ellipseX &lt; 0) {\n      speedX = speedX * -1;\n    }\n    if (ellipseY &gt; height || ellipseY &lt; 0) {\n      speedY = speedY * -1;\n    }\n  }\n}\n</code></pre> <pre><code>Ball myBall;\n\nvoid setup() {\n  size(700, 500);\n  myBall = new Ball();\n}\n\nvoid draw() {\n  background(0);\n  myBall.display();\n  myBall.move();\n  myBall.checkEdges();\n}\n</code></pre>"},{"location":"primi-passi/esercizio-bouncing-ball-parte-3-oop/#aggiungiamo-constructor","title":"Aggiungiamo\u00a0constructor","text":"<p>Miglioriamo la nostra classe creando dei nuovi constructor a cui possiamo passare delle variabili. Come gi\u00e0 fatto nell'esempio del post precedente, conviene sostituire il\u00a0data type delle variabili da\u00a0integer\u00a0a\u00a0float.</p> <pre><code>class Ball {\n  // VARIABILI\n  float ellipseX;\n  float ellipseY;\n  float speedX;\n  float speedY;\n\n  // CONSTRUCTOR\n  Ball() {\n    ellipseX = random(width);\n    ellipseY = random(height);\n    speedX = 1;\n    speedY = 1;\n  }\n\n  Ball(float _ellipseX) {\n    ellipseX = _ellipseX;\n    ellipseY = random(height);\n    speedX = 1;\n    speedY = 1;\n  }\n\n  Ball(float _ellipseX, float _ellipseY) {\n    ellipseX = _ellipseX;\n    ellipseY = _ellipseY;\n    speedX = 1;\n    speedY = 1;\n  }\n\n  Ball(float _ellipseX, float _ellipseY, float _speedX) {\n    ellipseX = _ellipseX;\n    ellipseY = _ellipseY;\n    speedX = _speedX;\n    speedY = 1;\n  }\n\n  Ball(float _ellipseX, float _ellipseY, float _speedX, float _speedY) {\n    ellipseX = _ellipseX;\n    ellipseY = _ellipseY;\n    speedX = _speedX;\n    speedY = _speedY;\n  }\n\n  // METODI\n  void display() {\n    ellipse(ellipseX, ellipseY, 50, 50);\n  }\n\n  void move() {\n    ellipseX = ellipseX + speedX;\n    ellipseY = ellipseY + speedY;\n  }\n\n  void checkEdges() {\n    if (ellipseX &gt; width || ellipseX &lt; 0) {\n      speedX = speedX * -1;\n    }\n    if (ellipseY &gt; height || ellipseY &lt; 0) {\n      speedY = speedY * -1;\n    }\n  }\n}\n</code></pre> <p>A questo punto non ci resta che sperimentare se funziona tutto correttamente provando a passare delle variabili alla nostra classe:</p> <p><code>myBall = new Ball(random(width), random(height), 5, 10);</code></p>"},{"location":"primi-passi/eventi-mousepressed-e-keypressed/","title":"Eventi: mouse e tastiera","text":""},{"location":"primi-passi/eventi-mousepressed-e-keypressed/#eventi-mousepressed-e-keypressed","title":"Eventi: mousePressed() e keyPressed()","text":"<p>Un po' alla volta stiamo rendendo i nostri sketch sempre pi\u00f9 interattivi grazie ai movimenti del mouse. Per proseguire il percorso della scorsa lezione e prima\u00a0di imparare a creare e utilizzare a nostro piacere delle variabili, argomento che verr\u00e0 trattato la prossima settimana, oggi parliamo di eventi.</p> <p>Per fare un breve recap: abbiamo imparato\u00a0come utilizzare i blocchi di codice setup() e draw() per suddividere i nostri sketch in due parti e far s\u00ec che parte del nostro codice sia eseguito solo all'avvio del programma e una parte, invece, venga processata in un loop costante. Grazie a questo, abbiamo anche visto che Processing \u00e8 in grado di restituirci in ogni momento la posizione\u00a0X e Y del mouse e di come possiamo usare questi dati per\u00a0arricchire i nostri sketch.</p> <p>Oltre al semplice movimento del mouse possiamo fare in modo che i nostri sketch riconoscano anche altri input disponibili comunemente su un computer: la pressione e il rilascio di\u00a0un tasto del mouse o della tastiera.</p>"},{"location":"primi-passi/eventi-mousepressed-e-keypressed/#cosa-sono-gli-eventi","title":"Cosa sono gli eventi?","text":"<p>Comportandosi in modo simile a setup() e draw(), gli eventi sono descritti, anch'essi, come blocchi di codice. La loro particolarit\u00e0 \u00e8 che il codice\u00a0scritto al loro interno\u00a0non viene eseguito automaticamente all'avvio del programma ma\u00a0\u00a0al verificarsi di\u00a0una condizione specifica come, per l'appunto, il click del mouse. A differenza della funzione draw(), le porzioni di codice all'interno degli eventi non vengono eseguiti in loop ma una volta soltanto.</p>"},{"location":"primi-passi/eventi-mousepressed-e-keypressed/#eventi-del-mouse","title":"Eventi del mouse","text":"<p>La sintassi \u00e8 simile a quella che abbiamo gi\u00e0 visto; per il momento ignoriamo il significato di\u00a0void e facciamo attenzione all'utilizzo delle maiuscole.</p> <pre><code>/*\n * Eventi mousePressed() e mouseReleased()\n * by Federico Pepe\n * http://blog.federicopepe.com\n */\n\nvoid setup() {\n  size(500, 500);\n  background(255);\n}\n\nvoid draw() {\n}\n\nvoid mousePressed() {\n  background(255, 0, 0);\n}\n\nvoid mouseReleased() {\n  background(255);\n}\n</code></pre> <p>Analizziamo insieme questo semplice programma:</p> <ul> <li>dentro setup() impostiamo la grandezza della finestra 500x500px e il colore di sfondo bianco.</li> <li>la funzione draw() per il momento non contiene alcuna riga di codice</li> <li>il codice contenuto all'interno di mousePressed() verr\u00e0 eseguito al click del mouse e imposter\u00e0 rosso come colore di sfondo.</li> <li>nel momento in cui verr\u00e0 rilasciato il tasto del mouse, verr\u00e0 eseguita la funzione mouseReleased() che ripristiner\u00e0 il bianco come background.</li> </ul> <p>Nel\u00a0Reference\u00a0di Processing trovate anche gli altri eventi legati al mouse:</p> <ul> <li>mouseButton</li> <li>mouseClicked()</li> <li>mouseDragged()</li> <li>mouseMoved()</li> <li>mousePressed()</li> <li>mousePressed</li> <li>mouseReleased()</li> <li>mouseWheel()</li> </ul> <p>\u00c8 inutile che mi soffermi ora sul fare un esempio per ciascuno di essi: una volta capito il funzionamento \u00e8 abbastanza intuitivo capire come usare le altre. Vi invito ugualmente a\u00a0sperimentarle tutte ed, eventualmente, lasciare un commento qualora riscontraste dei problemi.</p>"},{"location":"primi-passi/eventi-mousepressed-e-keypressed/#eventi-della-tastiera","title":"Eventi della tastiera","text":"<p>Allo stesso modo e con funzioni simili \u00e8 possibile determinare se un tasto della tastiera \u00e8 stato premuto oppure no:</p> <pre><code>/*\n * Eventi keyPressed() e keyReleased()\n * by Federico Pepe\n * http://blog.federicopepe.com\n */\n\nvoid setup() {\n  size(500, 500);\n  background(255);\n}\n\nvoid draw() {\n}\n\nvoid keyPressed() {\n  background(255, 0, 0);\n}\n\nvoid keyReleased() {\n  background(255);\n}\n</code></pre> <p>Se vi state chiedendo se \u00e8 possibile determinare\u00a0quale\u00a0tasto \u00e8 stato premuto la risposta \u00e8 ovviamente s\u00ec. Per realizzare uno sketch del genere sarebbe, per\u00f2, necessario introdurre alcuni argomenti che tratteremo in futuro: variabili booleane e cicli if... else if... else... per cui, per oggi, non andrei oltre.</p>"},{"location":"primi-passi/fine-del-livello-base/","title":"Fine (del livello base)","text":""},{"location":"primi-passi/fine-del-livello-base/#fine-del-livello-base","title":"Fine (del livello base)","text":"<p>Se siete arrivati a leggere fino a questo post, ho una buona notizia da darvi: abbiamo finito gli argomenti\u00a0base di Processing. Le fondamenta ci sono tutte e, nella pagina riassuntiva dedicata, potete ripercorrere \u2013\u00a0tutorial dopo tutorial \u2013 il percorso iniziato ben\u00a0otto mesi fa.</p> <p>Abbiamo finito? Certo che no. Alcuni argomenti che abbiamo gi\u00e0 trattato\u00a0sarebbero da approfondire e ci sono ancora tantissime cose da imparare e io non ho certo intenzione di fermarmi.</p> <p>Quando ero partito lo scorso luglio avevo pianificato\u00a0soltanto dieci post/argomenti di cui volevo parlare che, col tempo, si sono evoluti in ben trenta articoli.</p> <p>Se devo essere sincero, non ho ancora messo nero su bianco quali saranno i prossimi argomenti\u00a0ma sto valutando una riorganizzazione dei contenuti e della struttura degli articoli\u00a0in modo da renderli ancora migliori.</p> <p>Mi piacerebbe anche ricevere dei suggerimenti sui temi che vorreste che venissero trattati o sulla forma che, secondo voi, dovrebbero avere i contenuti futuri. Potete lasciare un commento a questo post oppure scrivermi via e-mail.</p> <p>Come sempre, vi invito a iscrivervi alla newsletter\u00a0dedicata al creative coding\u00a0per rimanere aggiornati sulle prossime novit\u00e0.</p>"},{"location":"primi-passi/fine-del-livello-base/#soluzione-al-trova-lerrore","title":"Soluzione al \"trova l'errore\"","text":"<p>Prima di concludere il post era rimasto in sospeso l'esercizio\u00a0\"trova l'errore\" del post precedente. Non avendo specificato esattamente qual era il problema nascosto nel codice, prima di darvi la soluzione vorrei assicurarmi che fosse tutto chiaro: come mostrato nell'immagine lo sfondo si \u00e8 colorato di rosso nonostante i due cerchi non fossero sovrapposti uno all'altro.</p> <p>Ecco che il problema era dovuto a una svista nel codice della funzione isOver all'interno della classe\u00a0Ball.pde:</p> <p><code>if(distance &lt;= (radius+b.radius)/2)</code></p> <p>\u00e8, infatti, necessario dividere per due la somma dei due raggi perch\u00e9, bench\u00e9 la variabile si chiami\u00a0radius, quando creiamo i nostri cerchi nel constructor, utilizziamo radius\u00a0come fosse un diametro:</p> <p><code>ellipse(ellipseX, ellipseY, radius, radius);</code></p> <p>Ci eravate arrivati?</p>"},{"location":"primi-passi/funzioni-personalizzate/","title":"Funzioni personalizzate","text":""},{"location":"primi-passi/funzioni-personalizzate/#funzioni-personalizzate","title":"Funzioni Personalizzate","text":"<p>Iniziamo con un nuovo importante capitolo nel nostro percorso di introduzione alla programmazione con Processing. Se state seguendo questa serie di post dall'inizio, arrivati a questo punto vi sarete resi conto che negli esempi che ho proposto ho sempre cercato di seguire\u00a0due regole auree\u00a0della programmazione:</p> <ol> <li>scrivere il minor numero di righe di codice possibile</li> <li>scrivere codice semplice da leggere e interpretare.</li> </ol> <p>Per quanto riguarda il primo punto, non penso che i programmatori siano pigri ma, al contrario, mi piace pensare che amino\u00a0arrivare dritti al punto, senza perdersi in fronzoli o distrazioni.</p> <p>In merito alla leggibilit\u00e0, capirete quanto \u00e8 importante scrivere bene il proprio codice quando vi capiter\u00e0\u00a0di dover rimettere mano a dei progetti realizzati qualche mese o, addirittura, qualche anno prima.</p> <p>Come anticipavo nell'incipit, con questo post\u00a0cominceremo \u00a0un percorso che ci porter\u00e0 a capire e a utilizzare la programmazione orientata agli oggetti (OOP), uno dei paradigmi fondamentali della programmazione moderna.</p>"},{"location":"primi-passi/funzioni-personalizzate/#un-mondo-di-funzioni","title":"Un mondo di funzioni","text":"<p>Fin dal primo post\u00a0abbiamo parlato\u00a0di funzioni e, con il susseguirsi degli articoli, ne\u00a0abbiamo utilizzate parecchie. Abbiamo imparato che queste funzioni ci permettono, ad esempio, di impostare la grandezza della finestra di lavoro oppure di disegnare forme geometriche.</p> <p>Alcune di esse hanno bisogno di uno o pi\u00f9 parametri per funzionare correttamente, penso, ad esempio, a fill()\u00a0altre, invece, devono semplicemente essere richiamate e non necessitano di ulteriori dati come setup() o draw().</p> <p>I creatori di Processing hanno gi\u00e0 inserito all'interno del linguaggio una serie di funzioni per rendere il linguaggio semplice da utilizzare. Provate a pensare a quanto sarebbe difficile disegnare un cerchio senza avere a disposizione la funzione ellipse().</p> <p>Come per le variabili built-in, le parole che identificano le funzioni gi\u00e0 inserite all'interno di Processing sono riconoscibili perch\u00e9 vengono evidenziate automaticamente. Ovviamente \u00e8 possibile creare delle funzioni personalizzate a patto che il nome scelto non sia gi\u00e0 riservato da una funzione built-in.</p>"},{"location":"primi-passi/funzioni-personalizzate/#modularita-e-riusabilita","title":"Modularit\u00e0 e riusabilit\u00e0","text":"<p>Il numero di righe di codice di un programma determina la sua complessit\u00e0; cominciare a utilizzare funzioni personalizzate e, come vedremo tra qualche settimana, gli oggetti ci permette di rendere il codice modulare e riusabile.</p> <p>Perch\u00e9 questo punto \u00e8 molto importante? Un programma modulare \u00e8 facile da debuggare e da modificare e/o riadattare alle proprie esigenze. Vi ricordate la differenza tra un programma con parametri hard-coded e lo stesso programma scritto con le variabili?</p> <p>Il principio \u00e8 lo stesso ed \u00e8 come dividere il contenuto di un manuale in capitoli: grazie alla modularit\u00e0 delle funzioni possiamo trovare subito le porzioni di codice che ci interessa leggere o modificare.</p> <p>In merito alla riusabilit\u00e0: se scriviamo delle funzioni complesse, possiamo tranquillamente copiarle e incollarle in un nuovo progetto senza perdere tempo a riscriverle da capo con un notevole risparmio di tempo e risorse.</p>"},{"location":"primi-passi/funzioni-personalizzate/#return-e-void","title":"Return e void","text":"<p>Arriviamo al punto: come si scrive una funzione? Innanzitutto dobbiamo capire se la nostra funzione \u00e8 pensata per restituire un valore oppure no. Facciamo un esempio per ciascun caso:</p> <ol> <li>Una funzione che, ogni volta che viene richiamata, mi disegni un fiore sullo schermo.</li> <li>Una funzione matematica che aggiunga 5 a ogni numero che viene utilizzato come parametro.</li> </ol> <p>Nel primo caso la funzione non restituisce alcun valore: disegna semplicemente un fiore sullo schermo. In questa funzione potremmo comunque passare dei parametri come, ad esempio, la posizione iniziale del fiore ma non ci verr\u00e0 restituito nessun valore n\u00e9 numerico n\u00e9 di testo dalla funzione stessa.</p> <p>Nel secondo caso, invece, utilizziamo una funzione proprio per ricevere in cambio un numero.</p> <p>Le due parole magiche che dovr\u00f2 utilizzare in Processing sono\u00a0void e\u00a0return.</p>"},{"location":"primi-passi/funzioni-personalizzate/#la-nostra-prima-funzione-flower","title":"La nostra prima funzione: Flower","text":"<pre><code>void setup() {\n  size(700, 700);\n  background(255);  \n}\n\nvoid draw() {\n  flower(width/2, height/2);\n}\n\nvoid flower(int posizioneX, int posizioneY) {\n  noStroke();\n  fill(0, 255, 0);\n  rectMode(CENTER);\n  rect(posizioneX, posizioneY+100, 25, 100);\n  fill(255, 0, 255);\n  ellipse(posizioneX-50, posizioneY, 70, 70);\n  ellipse(posizioneX, posizioneY-50, 70, 70);\n  ellipse(posizioneX+50, posizioneY, 70, 70);\n  ellipse(posizioneX, posizioneY+50, 70, 70);\n  fill(255, 255, 0);\n  ellipse(posizioneX, posizioneY, 50, 50);\n  noFill();\n}\n</code></pre> <p>Ecco il risultato:</p> <p>La parte di codice che ci interessa parte dalla linea 10:</p> <p>void flower(int posizioneX, int posizioneY) {</p> <p>Sto dicendo a Processing di creare una funzione che non restituir\u00e0 nessun parametro (void)\u00a0di nome\u00a0flower\u00a0che accetta due parametri in input di tipo integer:\u00a0posizioneX\u00a0e\u00a0posizioneY. La parentesi graffa alla fine mi serve per aprire il blocco di codice della funzione.</p> <p>Nelle linee successive disegno\u00a0il fiore utilizzando pi\u00f9 volte la funzione\u00a0ellipse per i petali e il pistillo e un\u00a0rect per il gambo. I parametri\u00a0posizioneX e\u00a0posizioneY vengono richiamati per impostare correttamente la posizione del fiore nella finestra.</p> <p>Con la parentesi graffa finale, chiudo il blocco di codice della funzione.</p> <p>Una volta scritta la funzione, \u00e8 sufficiente richiamarla\u00a0in setup() o in\u00a0draw()\u00a0passandogli le due variabili di tipo integer che la funzione si aspetta di ricevere.</p> <p>Ora se io volessi disegnare pi\u00f9 fiori all'interno della finestra, sarebbe sufficiente richiamare la funzione flower il numero di volte necessario:</p> <pre><code>void setup() {\n  size(700, 700);\n  background(255);  \n}\n\nvoid draw() {\n  flower(width/2, height/2);\n  flower(100, 200);\n  flower(500, 300);\n  flower(100, 600);\n}\n\nvoid flower(int posizioneX, int posizioneY) {\n  noStroke();\n  fill(0, 255, 0);\n  rectMode(CENTER);\n  rect(posizioneX, posizioneY+100, 25, 100);\n  fill(255, 0, 255);\n  ellipse(posizioneX-50, posizioneY, 70, 70);\n  ellipse(posizioneX, posizioneY-50, 70, 70);\n  ellipse(posizioneX+50, posizioneY, 70, 70);\n  ellipse(posizioneX, posizioneY+50, 70, 70);\n  fill(255, 255, 0);\n  ellipse(posizioneX, posizioneY, 50, 50);\n  noFill();\n}\n</code></pre> <p></p> <p>Se volessi creare un prato pieno di fiori, potrei inserire la funzione all'interno di un ciclo e, ovviamente, potrei aggiungere dei parametri ulteriori per creare, ad esempio, fiori di colore e grandezza diversi:</p> <pre><code>void setup() {\n  size(700, 700);\n  background(255);\n  for(int i = 0; i &lt; 20; i++) {\n    flower(int(random(width)), int(random(height)), color(random(255), random(255), random(255)), int(random(60, 100)));\n  }\n}\n\nvoid draw() {\n\n}\n\nvoid flower(int posizioneX, int posizioneY, color colore, int petali) {\n  noStroke();\n  fill(0, 255, 0);\n  rectMode(CENTER);\n  rect(posizioneX, posizioneY+100, 25, 100);\n  fill(colore);\n  ellipse(posizioneX-50, posizioneY, petali, petali);\n  ellipse(posizioneX, posizioneY-50, petali, petali);\n  ellipse(posizioneX+50, posizioneY, petali, petali);\n  ellipse(posizioneX, posizioneY+50, petali, petali);\n  fill(255, 255, 0);\n  ellipse(posizioneX, posizioneY, 50, 50);\n  noFill();\n}\n</code></pre> <p></p>"},{"location":"primi-passi/funzioni-personalizzate/#funzioni-che-restituiscono-valori","title":"Funzioni che restituiscono valori","text":"<p>Passiamo ora al secondo esempio:</p> <pre><code>void setup() {\n  println(aggiungiCinque(10));\n}\n\nvoid draw() {\n}\n\nint aggiungiCinque(int numero) {\n  return numero+5;\n}\n</code></pre> <p>Abbiamo creato una funzione che restituisce un tipo di dato\u00a0integer chiamata aggiungiCinque che accetta un parametro di tipo\u00a0integer. Con la parola chiave\u00a0return restituiamo il valore passato come parametro a cui abbiamo sommato 5;</p> <p>Nella funzione setup()\u00a0abbiamo chiamato la nostra funzione\u00a0aggiungiCinque(10) passando il valore 10. Nella console, ci verr\u00e0 stampato, correttamente, il valore 15.</p> <p>\u00c8 di fondamentale importanza indicare correttamente sia il tipo di valore che la funzione restituir\u00e0 in output sia quello che pu\u00f2 accettare in input. Se, infatti, passassimo il valore 10.5, un float, Processing ci restituirebbe un errore come nell'immagine:</p> <p></p> <p>Modificando la funzione per accettare un float ma lasciando la restituzione di un parametro integer otteniamo un altro tipo di errore sul return:</p> <p></p>"},{"location":"primi-passi/interazione-tra-oggetti/","title":"Interazione tra oggetti","text":""},{"location":"primi-passi/interazione-tra-oggetti/#interazione-tra-oggetti","title":"Interazione tra oggetti","text":"<p>Dopo la parentesi sugli array (parte 1, parte 2), torniamo a parlare di oggetti. Una domanda che pu\u00f2 sorgere spontanea \u00e8: possono due oggetti interagire tra loro?</p> <p>Riprendendo porzioni di codice che gi\u00e0 abbiamo\u00a0usato\u00a0in precedenza oggi realizzeremo uno sketch in cui sar\u00e0 presente\u00a0un'interazione tra due oggetti: cambieremo il colore dello sfondo da nero a rosso quando\u00a0due cerchi si\u00a0sovrapporranno uno all'altro.</p>"},{"location":"primi-passi/interazione-tra-oggetti/#analizziamo-il-problema","title":"Analizziamo il problema","text":"<p>Come posso sapere se due cerchi si intersecano? Per crearli in Processing utilizziamo la funzione ellipse() che accetta quattro parametri: posizione x e y del centro pi\u00f9 la larghezza e l'altezza. Nel caso in cui questi ultimi due parametri coincidano avr\u00f2 un cerchio.</p> <p>Grazie agli studi fatti alle scuole elementari e medie sappiamo che esiste una cosa chiamata raggio che determina la distanza tra il centro e il bordo del cerchio. A questo punto, la soluzione al problema dovrebbe esservi chiara: se la distanza tra\u00a0il centro del primo cerchio e del secondo \u00e8 inferiore alla somma dei due raggi, allora i cerchi saranno sovrapposti, altrimenti no.</p> <p>Se avete dimenticato la geometria, questa immagine dovrebbe esservi d'aiuto per visualizzare quello che ho appena scritto:</p> <p></p>"},{"location":"primi-passi/interazione-tra-oggetti/#punto-di-partenza-copia-incolla","title":"Punto di partenza: copia-incolla","text":"<p>Ora che abbiamo individuato il fulcro del nostro programma, faccio copia-incolla del codice dall'esercizio Bouncing Ball, semplificandolo in alcune parti:\u00a0all'interno della mia classe \"Ball\" utilizzer\u00f2 un solo constructor\u00a0a cui passer\u00f2 solo il valore relativo al\u00a0raggio del\u00a0cerchio. Posizione x e y del centro e velocit\u00e0 di spostamento saranno creati in modo casuale.</p> <p>Mantengo inalterato il metodo display() mentre\u00a0modifico leggermente il\u00a0metodo move() nel quale inserisco anche la parte di codice relativa al controllo sui bordi.</p> <p>Nel programma principale creo e inizializzo due oggetti di tipo Ball chiamati myBall1 e myBall2\u00a0e, all'interno di draw() li visualizzo e li faccio muovere:</p> <pre><code>class Ball {\n  // Variabili\n  int radius;\n  float ellipseX, ellipseY, speedX, speedY;\n  // Constructor\n  Ball(int _radius) {\n    radius = _radius;\n    ellipseX = random(width);\n    ellipseY = random(height);\n    speedX = random(2, 5);\n    speedY = random(2, 5);\n  }\n  // Metodi\n  void display() {\n    ellipse(ellipseX, ellipseY, radius, radius);\n  }\n\n  void move() {\n    ellipseX = ellipseX + speedX;\n    ellipseY = ellipseY + speedY;\n    if (ellipseX &gt; width || ellipseX &lt; 0) {\n      speedX = speedX * -1;\n    }\n    if (ellipseY &gt; height || ellipseY &lt; 0) {\n      speedY = speedY * -1;\n    }\n  }\n}\n</code></pre> <pre><code>Ball myBall1, myBall2;\n\nvoid setup() {\n  size(700, 500);\n  myBall1 = new Ball(100);\n  myBall2 = new Ball(50);\n}\n\nvoid draw() {\n  background(0);\n  myBall1.display();\n  myBall2.display();\n  myBall1.move();\n  myBall2.move();\n}\n</code></pre>"},{"location":"primi-passi/interazione-tra-oggetti/#determinare-la-sovrapposizione","title":"Determinare la sovrapposizione","text":"<p>Ora non mi resta che creare un nuovo metodo all'interno della classe per verificare l'effettiva sovrapposizione dei due cerchi. Il primo passo che potremmo pensare di fare \u00e8 creare una funzione in cui utilizziamo sei\u00a0parametri (posizione x, y e raggio dei due cerchi) per verificare l'intersezione dei due cerchi.</p> <p>Dal momento che utilizziamo gli oggetti, possiamo arrivare a una soluzione pi\u00f9 semplice: l'oggetto myBall1 interseca myBall2?</p> <p>Aggiungiamo un metodo alla nostra classe: il tipo di dato che verr\u00e0 restituito da questo nuovo metodo sar\u00e0 di tipo\u00a0booleano (true in caso di sovrapposizione e false in caso contrario) per cui scriviamo quanto segue:</p> <p>boolean isOver() {</p> <p>}</p> <p>Per calcolare la distanza tra due punti utilizziamo la funzione dist()\u00a0che accetta quattro parametri e restituisce un dato di tipo\u00a0float:</p> <p><code>dist(x1, y1, x2, y2);</code></p> <p>Chiaramente\u00a0i primi due parametri saranno ellipseX ed ellipseY del cerchio che stiamo prendendo in esame. Ma come facciamo a passare i dati del secondo cerchio? Nel secondo post relativo agli oggetti abbiamo visto come passare dei parametri all'interno del costructor, possiamo usare lo stesso sistema per passare delle variabili anche ai metodi.</p> <p>La cosa davvero interessante \u00e8 che anzich\u00e9 passare una variabile, passeremo l'intero oggetto:</p> <p>boolean isOver(Ball b) {  float distance = dist(ellipseX, ellipseY, b.ellipseX, b.ellipseY);  if(distance &lt;= (radius+b.radius)) {   return true;  } else {   return false;  } }</p> <p>Ecco il codice completo della classe Ball:</p> <pre><code>class Ball {\n\n  int radius;\n  float ellipseX, ellipseY, speedX, speedY;\n\n  Ball(int _radius) {\n    radius = _radius;\n    ellipseX = random(width);\n    ellipseY = random(height);\n    speedX = random(2, 5);\n    speedY = random(2, 5);\n  }\n\n  void display() {\n    ellipse(ellipseX, ellipseY, radius, radius);\n  }\n\n  void move() {\n    ellipseX = ellipseX + speedX;\n    ellipseY = ellipseY + speedY;\n    if (ellipseX &gt; width || ellipseX &lt; 0) {\n      speedX = speedX * -1;\n    }\n    if (ellipseY &gt; height || ellipseY &lt; 0) {\n      speedY = speedY * -1;\n    }\n  }\n\n  boolean isOver(Ball b) {\n    float distance = dist(ellipseX, ellipseY, b.ellipseX, b.ellipseY);\n    if(distance &lt;= (radius+b.radius)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n</code></pre>"},{"location":"primi-passi/interazione-tra-oggetti/#interazione-tra-due-oggetti","title":"Interazione tra due oggetti","text":"<p>Aggiorniamo il codice dello sketch principale aggiungendo all'interno di draw le seguenti righe di codice:</p> <p>if(myBall2.isOver(myBall1)) {  background(255, 0, 0); }</p> <p>Ed il gioco \u00e8 fatto.</p>"},{"location":"primi-passi/interazione-tra-oggetti/#trova-lerrore","title":"Trova l'errore","text":"<p>Anzich\u00e9 lasciarvi con un esercizio, questa volta\u00a0ho un'altra sfida per voi. Il nostro programma funziona ma c'\u00e8 un piccolo errore che non lo fa funzionare esattamente come ci eravamo prefissati. Sapete individuarlo?</p> <p>Per aiutarvi allego un'immagine:</p> <p></p>"},{"location":"primi-passi/introduzione-agli-oggetti/","title":"Introduzione agli oggetti","text":""},{"location":"primi-passi/introduzione-agli-oggetti/#introduzione-agli-oggetti","title":"Introduzione agli oggetti","text":"<p>\u00c8 finalmente arrivato il momento di cominciare a parlare di\u00a0programmazione orientata agli oggetti ma, prima di addentrarci nel codice e modificare i nostri sketch, \u00e8 importante\u00a0dare una definizione chiara e semplice\u00a0di che cosa sono gli oggetti e di come li possiamo utilizzare.</p> <p>Questo post, quindi, non conterr\u00e0 esempi pratici\u00a0ma fornir\u00e0 un'introduzione generale all'argomento.\u00a0Ho deciso di muovermi in questo modo perch\u00e9 quando mi sono trovato ad affrontare per la prima volta l'OOP ho faticato a capire il reale vantaggio di un approccio ad oggetti. Oggi invece, non potrei farne a meno.</p> <p>Partiamo con una buona notizia: per utilizzare gli oggetti non dobbiamo imparare nulla di nuovo rispetto a quanto fatto fino ad ora. Utilizzeremo variabili, controlli condizionali, loop e funzioni. Se siete arrivati a questo punto e avete ancora dei dubbi in merito anche solo ad uno\u00a0di questi argomenti, il mio consiglio \u00e8 di fermarsi ora\u00a0e andare a rileggere i vecchi post. Se, invece, \u00e8 tutto chiaro,\u00a0procediamo!</p>"},{"location":"primi-passi/introduzione-agli-oggetti/#oggetti-questione-di-astrazione","title":"Oggetti: questione di astrazione","text":"<p>Nella realt\u00e0 di tutti i giorni siamo abituati ad avere a che fare con oggetti specifici ciascuno con caratteristiche peculiari che dipendono, in gran parte, dalla marca e dal modello che possediamo. Questi oggetti, per\u00f2, possono essere astratti a un livello pi\u00f9 alto: pensiamo, ad esempio a una macchina.</p> <p>Se potessi leggere nelle vostre menti, vedrei che ciascuno di voi sta pensando a una macchina differente dagli altri ma che, in quanto oggetto-macchina, ha delle caratteristiche comuni a tutte le altre:\u00a0ad esempio il numero di ruote sar\u00e0 uguale per tutti mentre il colore della carrozzeria sar\u00e0 differente.</p> <p>\u00c8 importante notare come l'oggetto-macchina possa avere dei\u00a0dati (colore, lunghezza, numero porte, ...) e delle funzioni (si muove in avanti, si muove indietro, ...).</p> <p>Facciamo un passo in pi\u00f9: l'astrazione della macchina non rappresenta di per s\u00e9 una macchina vera e propria. Il modello-macchina astratto funge da\u00a0template.\u00a0In programmazione, l'oggetto astratto\u00a0viene chiamato classe. Ciascuna macchina che prender\u00e0 come base il modello astratto ma avr\u00e0 caratteristiche peculiari sar\u00e0 a tutti gli effetti un\u00a0oggetto\u00a0vero e proprio. In programmazione, quando richiamiamo la classe per costruire un nuovo oggetto stiamo creando un'istanza della classe.</p>"},{"location":"primi-passi/introduzione-agli-oggetti/#ricapitolando","title":"Ricapitolando","text":"<p>Abbiamo un modello astratto che funger\u00e0 da \u00abtemplate\u00bb\u00a0per tutti gli oggetti che andremo a creare che chiamiamo\u00a0classe mentre\u00a0creando un'istanza della classe creiamo effettivamente un\u00a0oggetto.</p>"},{"location":"primi-passi/introduzione-agli-oggetti/#cosa-ce-di-nuovo","title":"Cosa c'\u00e8 di nuovo?","text":"<p>Fino a qui tutto ok, ma qual \u00e8 la vera novit\u00e0? Le variabili legate agli oggetti, cos\u00ec come le funzioni legate alle azioni che questi oggetti devono compiere all'interno del nostro programma, saranno all'interno della classe.</p> <p>Con la programmazione a oggetti il codice si semplificher\u00e0 ulteriormente perch\u00e9 non andremo a \u00absporcare\u00bb il codice con informazioni inutili. Ci baster\u00e0 richiamare la classe perch\u00e9 ciascun oggetto avr\u00e0 tutto quello di cui necessita al suo interno.</p> <p>Nel prossimo post vedremo la sintassi corretta da utilizzare sia delle classi che degli oggetti e poi, finalmente, cominceremo a sporcarci un po' le mani.</p>"},{"location":"primi-passi/loop-for-e-nesting/","title":"For e nesting","text":""},{"location":"primi-passi/loop-for-e-nesting/#loop-ii-for-e-nesting","title":"Loop II: for e nesting","text":"<p>Come accennato nel post precedente, esistono due tipologie di loop: quelli con while e quelli con for.\u00a0Oggi ci concentreremo su questi ultimi che, come dicevo, sono quelli che\u00a0preferisco utilizzare.</p> <p>Ripassiamo velocemente come funziona il\u00a0ciclo while: questa tipologia di loop esegue\u00a0un blocco di codice finch\u00e9 la condizione prevista tra parentesi \u00e8 true. </p><pre><code>while(condizione) {\n // Blocco di codice\n}\n</code></pre> Il motivo per cui io non amo utilizzare il while\u00a0nasce dal fatto che la variabile deve essere dichiarata e inizializzata all'esterno del loop, verificata nella\u00a0condizione e incrementata all'interno del loop. <p>La stessa variabile viene quindi utilizzata in punti diversi del codice e questo, nel caso di programmi piuttosto complessi, pu\u00f2 creare non poca confusione.</p>"},{"location":"primi-passi/loop-for-e-nesting/#for","title":"For","text":"<p>Per ovviare al problema sopra descritto, ci affidiamo ai cicli for dove l'inizializzazione, la verifica e l'incremento della variabile \"contatore\" avviene all'interno della condizione.</p> <p>Riprendiamo l'esempio del post precedente e riscriviamolo utilizzando il for:</p> <pre><code>void setup() {\n  size(700, 500);\n  background(255);\n  for(int y = 10; y &lt; height; y+=10) {\n    line(100, y, 600, y);\n  }\n}\n\nvoid draw() {\n}\n</code></pre> <p>Il codice ora risulta pi\u00f9 pulito e pi\u00f9 facile da leggere: in una sola riga abbiamo iniziato il ciclo, dichiarato e inizializzato la variabile\u00a0contatore\u00a0int y = 10;\u00a0posto la condizione\u00a0y &lt; height; e, infine, incrementato la variabile di 10 a ogni ciclo:\u00a0y += 10.\u00a0\u00c8 importante sottolineare che questi tre blocchi devono essere separati dal punto e virgola, come mostrato nell'esempio.</p>"},{"location":"primi-passi/loop-for-e-nesting/#loop-in-draw","title":"Loop in draw()","text":"<p>Prendiamo in considerazione la possibilit\u00e0 di inserire un ciclo all'interno della funzione draw() che, come abbiamo avuto modo di ripetere fino alla nausea, \u00e8 essa stessa una funzione che si ripete costantemente.</p> <pre><code>void setup() {\n  size(700, 500);\n  background(255);\n}\n\nvoid draw() {\n  for(int y = 10; y &lt; height; y+=10) {\n    line(100, y, 600, y);\n  }\n}\n</code></pre> <p>Il funzionamento di questo programma \u00e8 pi\u00f9 semplice di quello che si pu\u00f2 pensare: nel primo ciclo di draw() il programma processer\u00e0 per intero il loop for (quindi la variabile y partir\u00e0 da un valore 10 e poi verr\u00e0 aumentata di 10 fino al raggiungimento del valore 690).\u00a0Quando la condizione diventa\u00a0false\u00a0e il loop\u00a0for si conclude, il ciclo\u00a0draw()\u00a0aggiorna lo schermo visualizzando tutte le linee e poi riparte per il secondo ciclo. A quel punto y verr\u00e0 reimpostata al suo valore iniziale 10 e ripeter\u00e0 nuovamente l'interno processo.\u00a0Alla velocit\u00e0 di 60fps, non si riesce a vedere nessun tipo di animazione; per farlo, \u00e8 sufficiente aggiungere una variabile\u00a0random:</p> <pre><code>void setup() {\n  size(700, 500);\n  background(255);\n}\n\nvoid draw() {\n  for(int y = 10; y &lt; height; y+=10) {\n    stroke(random(255), 0, random(255));\n    line(100, y, 600, y);\n  }\n}\n</code></pre>"},{"location":"primi-passi/loop-for-e-nesting/#loop-nesting","title":"Loop nesting","text":"<p>La parola inglese nesting significa\u00a0annidamento; quando usato in programmazione e, in particolare, in questo contesto, intendiamo la possibilit\u00e0 di inserire un loop for all'interno di un altro loop. Se, ad esempio, volessimo\u00a0disegnare una griglia di rettangoli\u00a0a coprire l'intera larghezza e altezza della nostra finestra potremmo procedere cos\u00ec:</p> <pre><code>void setup() {\n  size(700, 500);\n  background(255);\n}\n\nvoid draw() {\n  for(int x = 0; x &lt;= width; x += 20) {\n    rect(x, 0, 10, 10);\n  }\n}\n</code></pre> <p>Una serie di quadrati\u00a0vengono disegnati per tutta la larghezza della finestra.</p> <p></p> <p>Facciamo la stessa cosa in verticale. Per comodit\u00e0 ho lasciato anche il codice di prima, commentandolo:</p> <pre><code>void setup() {\n  size(700, 500);\n  background(255);\n}\n\nvoid draw() {\n  /* Disegna i quadrati in orizzontale\n  for(int x = 0; x &lt;= width; x += 20) {\n    rect(x, 0, 10, 10);\n  }\n  */\n  for(int y = 0; y &lt;= height; y += 20) {\n    rect(0, y, 10, 10);\n  }\n}\n</code></pre> <p></p> <p>A questo punto uniamo le due cose:</p> <pre><code>void setup() {\n  size(700, 500);\n  background(255);\n}\n\nvoid draw() {\n  for(int x = 0; x &lt;= width; x += 20) {\n    for(int y = 0; y &lt;= height; y += 20) {\n      rect(x, y, 10, 10);\n    }\n  }\n}\n</code></pre> <p></p> <p>Per ogni quadrato sull'asse x viene disegnata per intero la colonna.</p> <p>Per concludere il post di oggi, aggiungiamo un po' di psichedelia: copiando e incollando il codice qui sotto i colori cambieranno a ogni ciclo di draw().</p> <pre><code>void setup() {\n  size(700, 500);\n  background(255);\n}\n\nvoid draw() {\n  for(int x = 5; x &lt;= width; x += 20) {\n    for(int y = 5; y &lt;= height; y += 20) {\n      fill(random(255), 0, random(255));\n      rect(x, y, 10, 10);\n    }\n  }\n}\n</code></pre> <p></p>"},{"location":"primi-passi/loop-while/","title":"While","text":""},{"location":"primi-passi/loop-while/#loop-while","title":"Loop: while","text":"<p>Grazie ai controlli condizionali, abbiamo imparato come risolvere un importante\u00a0problema: fare in modo che il nostro programma rispetti una logica eseguendo alcune porzioni di codice\u00a0solo al verificarsi di determinate condizioni. Ora, per\u00f2, ci troviamo di fronte a un'altra questione importante per il nostro futuro da programmatori: siamo in grado di\u00a0disegnare qualcosa sullo schermo una volta ma\u00a0non sappiamo come ripetere, in modo semplice e veloce,\u00a0pi\u00f9 volte la stessa figura sullo schermo.</p> <p>Ovviamente possiamo fare copia-incolla della nostra funzione, ad esempio ellipse(), modificare qualche parametro affinch\u00e9 le figure non si sovrappongano una all'altra ma questo non \u00e8 certamente il modo migliore di procedere. Provate a pensare, infatti, cosa succederebbe se\u00a0volessimo disegnare 500 cerchi: sarebbe complicato tenere il conto del numero esatto di copie. Se, poi, ci accorgessimo di voler fare una piccola modifica probabilmente ci passerebbe la voglia di cambiare 500 righe di codice.</p> <p>Introduciamo oggi il concetto di loop.</p>"},{"location":"primi-passi/loop-while/#loop","title":"Loop","text":"<p>Lo scopo del loop \u00e8, per l'appunto, racchiudere in un blocco di codice delle istruzioni\u00a0che devono essere ripetute un esatto numero di volte. Esistono fondamentalmente due tipologie di loop: while e for. In questo post ci concentreremo di pi\u00f9 sul primo anche se, lo ammetto, io preferisco di gran lunga utilizzare i cicli for. Nel prossimo post, quando li approfondiremo, scoprirete anche il perch\u00e9.</p>"},{"location":"primi-passi/loop-while/#while","title":"While","text":"<p>Concettualmente i cicli di loop sono molto simili ai controlli condizionali:</p> <pre><code>if(condizione) {\n // Blocco di codice\n}\n</code></pre> <p>Abbiamo imparato che, in un if, il blocco di codice viene eseguito quando la condizione inserita tra le parentesi \u00e8 vera.</p> <pre><code>while(condizione) {\n // Blocco di codice\n}\n</code></pre> <p>Nel loop while, il blocco di codice verr\u00e0 eseguito\u00a0finch\u00e9 la condizione inserita tra le parentesi \u00e8 vera.</p>"},{"location":"primi-passi/loop-while/#esempio-pratico","title":"Esempio pratico","text":"<p>Come al solito facciamo subito un esempio e analizziamo il codice che ha generato l'immagine:</p> <p></p> <pre><code>int y = 10;\n\nvoid setup() {\n  size(700, 500);\n  background(255);\n  while(y &lt; height) {\n    line(100, y, 600, y);\n    y += 10;\n  }\n}\n\nvoid draw() {\n}\n</code></pre> <p>Lo scopo di questo programma \u00e8 disegnare delle linee orizzontali distanziate di 10 pixel l'una dall'altra fino al raggiungimento dell'altezza della finestra.</p> <p>Come potete vedere nel codice, all'inizio abbiamo dichiarato e inizializzato\u00a0la variabile, chiamata y, che utilizzeremo per verificare la condizione all'interno del ciclo while. In setup()\u00a0abbiamo impostato la grandezza della finestra e il colore dello sfondo e poi abbiamo inserito il nostro loop:</p> <p>finch\u00e9 il valore della variabile y sar\u00e0 inferiore all'altezza della finestra, disegna una linea orizzontale le cui coordinate saranno: 100, y, 600, y. Aumenta poi il valore di y di 10.</p> <p>Quando il codice viene eseguito il programma lo analizza in questo modo:</p> <ul> <li>Il valore iniziale di y \u00e8 10 (valore con cui abbiamo inizializzato la variabile all'inizio del programma), y \u00e8 minore dell'altezza della finestra (500px)? Si, allora disegna una linea con le seguenti coordinate: 100, 10, 600, 10. y = 10+10;</li> <li>y = 20. y \u00e8 minore di 500? Si, allora disegna una linea con le coordinate: 100, 20, 600, 20. y = 20+10;</li> <li>y = 30. y \u00e8 minore di 500? Si, allora disegna una linea con le coordinate: 100, 30, 600, 30. y = 30+10;</li> <li>y = 40. y \u00e8 minore di 500? Si, allora disegna una linea con le coordinate: 100, 40, 600, 40. y = 40+10;</li> <li>...</li> <li>y = 490. y \u00e8 minore di 500? Si, allora disegna una linea con le coordinate: 100, 490, 600, 490. y = 490+10;</li> <li>y = 500. y \u00e8 minore di 500?\u00a0No, allora esci dal ciclo while.</li> </ul> <p>Provate a pensare a quanto tempo avremmo perso a disegnare quelle righe una alla volta e, soprattutto, nel caso in cui volessimo modificare la distanza tra le linee da 10 a 5 pixel, ci basta modificare un singolo parametro: y += 5.</p>"},{"location":"primi-passi/loop-while/#attenzione","title":"Attenzione!","text":"<p>Ecco alcune cose importanti che dobbiamo tenere a mente quando utilizziamo un ciclo loop di tipo while:</p> <ul> <li>Abbiamo bisogno di creare una variabile da utilizzare come \"contatore\" per verificare se la condizione \u00e8\u00a0true.</li> <li>Il valore della variabile contatore\u00a0deve essere modificato all'interno del ciclo while.</li> <li>Bisogna fare attenzione che ci sia una condizione di uscita dal loop altrimenti\u00a0il ciclo\u00a0si ripeter\u00e0 all'infinito mandando in blocco il computer.</li> </ul>"},{"location":"primi-passi/modularita-delle-funzioni/","title":"Modularit\u00e0 delle funzioni","text":""},{"location":"primi-passi/modularita-delle-funzioni/#modularita-delle-funzioni","title":"Modularit\u00e0 delle funzioni","text":"<p>Proseguiamo la nostra esplorazione nel mondo delle funzioni personalizzate\u00a0e rendiamo lo sketch che abbiamo realizzato con l'esercizio\u00a0Bouncing Ball (parte 1, parte 2)\u00a0modulare.</p> <p>Per diventare dei buoni programmatori \u00e8 necessario lavorare costantemente alla riscrittura del proprio codice: \u00e8 un processo continuo di riorganizzazione e ottimizzazione.</p> <p>Riprendiamo il codice a cui eravamo arrivati con l'ultimo esercizio:</p> <pre><code>int ellipseX;\nint ellipseY;\nint speedX = 1;\nint speedY = 1;\n\nvoid setup() {\n  size(700, 500);\n  ellipseX = 0;\n  ellipseY = height/2;\n}\n\nvoid draw() {\n  background(0);\n  ellipse(ellipseX, ellipseY, 50, 50);\n  if(ellipseX &gt; width || ellipseX &lt; 0) {\n    speedX = speedX * -1;\n  }\n  if(ellipseY &gt; height || ellipseY &lt; 0) {\n    speedY = speedY * -1;\n  }\n  ellipseX = ellipseX + speedX;\n  ellipseY = ellipseY + speedY;\n  //println(\"EllipseX: \" + ellipseX + \" SpeedX: \" + speedX);\n}\n</code></pre>"},{"location":"primi-passi/modularita-delle-funzioni/#divisione-in-moduli","title":"Divisione in \u00a0moduli","text":"<p>In quanti moduli possiamo suddividere il nostro programma?\u00a0Rileggiamo il codice e analizziamo\u00a0ogni porzione di codice:</p> <ul> <li>Righe 1 - 4: dichiarazione delle variabili</li> <li>Righe 6- 10: configurazione generale con la funzione setup()</li> <li>Righe 13-14: disegniamo la nostra palla</li> <li>Righe 15-20: controlliamo che la palla non vada oltre i bordi della finestra e, se necessario, invertiamo la direzione del movimento.</li> <li>Righe 21-22: facciamo muovere la nostra palla</li> </ul> <p>Chiaramente i primi due punti\u00a0non possono essere modificati: le variabili devono\u00a0funzionare in vari punti del nostro programma quindi sono pubbliche mentre la parte di configurazione \u00e8 gi\u00e0 all'interno della funzione setup().</p> <p>Gli altri 3 punti, invece, sono tutti all'interno della funzione draw() ma si occupano di tre attivit\u00e0 differenti: disegnare, controllare e muovere la palla. Creiamo\u00a0un modulo per ciascuna di esse.</p> <p>Ricordo che non dovendo restituire nessun valore,\u00a0utilizzeremo la parola\u00a0void e che possiamo nominare ciascuna funzione come preferiamo purch\u00e9 non si utilizzino parole gi\u00e0 riservate.</p> <p>La funzione drawBall() sar\u00e0 quella\u00a0dedicata al disegno della palla</p> <pre><code>void drawBall() {\n background(0);\n ellipse(ellipseX, ellipseY, 50, 50);\n}\n</code></pre> <p>moveBall() si occuper\u00e0 del movimento</p> <pre><code>void moveBall() {\n ellipseX = ellipseX + speedX;\n ellipseY = ellipseY + speedY;\n}\n</code></pre> <p>E infine checkEdges() verificher\u00e0 se la palla ha raggiunto un bordo</p> <pre><code>void checkEdges() {\n if (ellipseX &gt; width || ellipseX &lt; 0) {\n speedX = speedX * -1;\n }\n if (ellipseY &gt; height || ellipseY &lt; 0) {\n speedY = speedY * -1;\n }\n}\n</code></pre>"},{"location":"primi-passi/modularita-delle-funzioni/#bouncing-ball-modulare","title":"Bouncing Ball: modulare","text":"<p>Ecco il\u00a0codice riscritto:</p> <pre><code>int ellipseX;\nint ellipseY;\nint speedX = 1;\nint speedY = 1;\n\nvoid setup() {\n  size(700, 500);\n  ellipseX = 0;\n  ellipseY = height/2;\n}\n\nvoid draw() {\n  drawBall();\n  checkEdges();\n  moveBall();\n}\n\nvoid drawBall() {\n  background(0);\n  ellipse(ellipseX, ellipseY, 50, 50);\n}\n\nvoid moveBall() {\n  ellipseX = ellipseX + speedX;\n  ellipseY = ellipseY + speedY;\n}\n\nvoid checkEdges() {\n  if (ellipseX &gt; width || ellipseX &lt; 0) {\n    speedX = speedX * -1;\n  }\n  if (ellipseY &gt; height || ellipseY &lt; 0) {\n    speedY = speedY * -1;\n  }\n}\n</code></pre> <p>Se clicchiamo su Run non noteremo alcuna differenza di funzionamento tra questo codice e quello incollato a inizio post.</p> <p>Qualcuno potrebbe giustamente notare che, per\u00f2, siamo passati da 24 linee di codice a 34: ben 10 righe di codice in pi\u00f9 senza aver, di fatto, cambiato nulla nel funzionamento del nostro programma. Di contro, per\u00f2,\u00a0il nostro codice \u00e8 pi\u00f9 pulito e leggibile.</p> <p>Il reale miglioramento si capir\u00e0 quando, con il prossimo post, cominceremo a parlare di oggetti.</p>"},{"location":"primi-passi/oop-classi-e-oggetti-parte-2/","title":"Classi e oggetti, parte 2","text":""},{"location":"primi-passi/oop-classi-e-oggetti-parte-2/#oop-classi-e-oggetti-parte-2","title":"OOP: Classi e oggetti, parte 2","text":"<p>Ripartiamo da dove ci siamo fermati con l'ultimo post: abbiamo scritto la nostra prima classe e abbiamo creato il nostro primo oggetto. Nell'approfondimento di oggi\u00a0su classi e oggetti parleremo di alcune questioni importanti: come mantenere pulito il codice quando si lavora con le classi, come\u00a0passare parametri al constructor e, infine,\u00a0come creare\u00a0n oggetti.</p>"},{"location":"primi-passi/oop-classi-e-oggetti-parte-2/#operazione-pulizia-utilizzare-le-tab","title":"Operazione pulizia: utilizzare le Tab","text":"<pre><code>Car myCar;\n\nvoid setup() {\n  size(500, 500);\n  myCar = new Car();\n}\n\nvoid draw() {\n  background(255);\n  myCar.display();\n  myCar.move();\n}\n\n\nclass Car {\n  // Dati\n  int carLength;\n  int xPos;\n  int yPos;\n  int speed;\n\n  // Constructor\n  Car() {\n    carLength = 10;\n    xPos = 0;\n    yPos = 200;\n    speed = 1;\n  }\n\n  // Metodi\n  void display() {\n    rectMode(CENTER);\n    fill(0);\n    rect(xPos, yPos, carLength, 10);\n  }\n\n  void move() {\n    xPos = xPos + speed;\n  }\n}\n</code></pre> <p>Il nostro codice ora \u00e8 lungo 40 righe in tutto e la classe\u00a0Car\u00a0occupa la maggior parte dello spazio. Immaginate per un secondo di avere tra le mani un programma molto complesso, che utilizza tante tipologie di oggetti differenti. Sarebbe davvero problematico andare a cercare di volta in volta scorrendo in su e in gi\u00f9 la porzione di codice\u00a0che si riferisce all'oggetto che vogliamo utilizzare.</p> <p>Per fortuna Processing viene in nostro aiuto con una funzione molto comoda: le Tab.</p> <p></p> <p>Cliccando sulla freccia che punta in basso accanto al nome del nostro sketch, si aprir\u00e0 un menu con diverse opzioni. Clicchiamo su New Tab (su Mac la scorciatoia \u00e8 \u21e7\u2318N). A questo punto il programma ci chieder\u00e0 il\u00a0nome che vogliamo dare alla nostra tab; dovendo spostare l\u00ec la classe Car, utilizziamo lo stesso nome sempre con l'iniziale maiuscola.</p> <p>Una volta cliccato su OK, l'editor creer\u00e0 un altro file .pde che verr\u00e0 aggiunto automaticamente alla cartella dove abbiamo salvato il nostro sketch (la scorciatoia per vedere velocemente la cartella \u00e8\u00a0\u2318K).</p> <p></p> <p>A questo punto\u00a0facciamo copia-incolla del codice della classe nella nuova tab e proviamo a cliccare\u00a0Run.\u00a0Il programma dovrebbe aprirsi e funzionare esattamente come prima con la differenza che, ora, il codice del file principale \u2013 quello nominato sketch_160115a.pde in questo esempio \u2013 \u00e8 molto pi\u00f9 breve e pulito.</p>"},{"location":"primi-passi/oop-classi-e-oggetti-parte-2/#passare-parametri-al-constructor","title":"Passare\u00a0parametri al constructor","text":"<p>La nostra classe Car\u00a0\u00e8 ora funzionale e pulita ma \u00e8 ancora migliorabile: ho scritto pi\u00f9 volte dell'importanza di utilizzare le variabili invece di parametri hard-coded ma il constructor che abbiamo ora generer\u00e0 sempre oggetti con le stesse caratteristiche: la lunghezza sar\u00e0 sempre pari a 10 pixel, la posizione di partenza sar\u00e0 x = 0 e y = 200 e la velocit\u00e0 pari a 1.</p> <p>La buona notizia \u00e8 che possiamo inserire nella nostra classe pi\u00f9 constructor mantenendo una sintassi simile a quella che gi\u00e0 conosciamo; dobbiamo solo aggiungere, all'interno della parentesi tonda, le variabili che decidiamo di passare ai nostri oggetti.</p> <p>In questo primo esempio, aggiungiamo la possibilit\u00e0 di modificare la lunghezza della nostra macchina.</p> <pre><code>class Car {\n  // Dati\n  int carLength;\n  int xPos;\n  int yPos;\n  int speed;\n\n  // Constructor\n  Car() {\n    carLength = 10;\n    xPos = 0;\n    yPos = 200;\n    speed = 1;\n  }\n\n  // Secondo Constructor\n  Car(int tempCarLength) {\n    carLength = tempCarLength;\n    xPos = 0;\n    yPos = 200;\n    speed = 1;\n  }\n\n  // Metodi\n  void display() {\n    rectMode(CENTER);\n    fill(0);\n    rect(xPos, yPos, carLength, 10);\n  }\n\n  void move() {\n    xPos = xPos + speed;\n  }\n}\n</code></pre> <p>In questa nuova versione ho aggiunto alla classe un nuovo constructor che accetta un solo parametro di tipo integer. Quando il parametro viene passato devo utilizzare una variabile temporanea, motivo per cui ho inserito la variabile\u00a0tempCarLength.\u00a0La variabile temporanea dovr\u00e0 poi essere assegnata alla variabile relativa all'interno del costructor:\u00a0carLength = tempCarLength.</p> <p>Questo \u00e8 il momento in cui \u00e8 necessario diventare molto ordinati e scrupolosi con i nomi che diamo alle nostre variabili, il rischio \u00e8 di complicarci\u00a0inutilmente la vita.</p> <p>Ora che abbiamo un nuovo constructor, torniamo al nostro sketch principale e modifichiamo l'inizializzazione da cos\u00ec:</p> <p>myCar = new Car();</p> <p>a cos\u00ec:</p> <p>myCar = new Car(25);</p> <p>Proviamo a lanciare il nostro sketch.</p> <p></p> <p>Il nostro rettangolo sar\u00e0 ora lungo 25 pixel.</p> <p>Cosa succede se proviamo a passare al nostro constructor una variabile di tipo float?</p> <p>myCar = new Car(25.7);</p> <p>Ovviamente ci verr\u00e0 restituito un errore:\u00a0The constructor \"Car(float)\" does not exist.</p>"},{"location":"primi-passi/oop-classi-e-oggetti-parte-2/#constructor-constructor-constructor","title":"Constructor, constructor, constructor","text":"<p>Il prossimo passaggio sar\u00e0 creare tanti constructor quanti sono i dati che il nostro oggetto contiene: nel nostro programma vorremmo, ad esempio, decidere anche la posizione x e y di partenza oltre, ovviamente, diversi valori di velocit\u00e0. Possiamo fare anche un passaggio in pi\u00f9: aggiungiamo una nuova variabile che contenga anche il colore della macchina.</p> <p>Vi invito a provare a modificare la classe per conto vostro e di non guardare subito il codice qui sotto. In questo modo capirete se, effettivamente, vi \u00e8 tutto chiaro.</p> <pre><code>class Car {\n  // Dati\n  int carLength;\n  float xPos;\n  int yPos;\n  float speed;\n  color c;\n\n  // Constructor\n  Car() {\n    carLength = 10;\n    xPos = 0;\n    yPos = 200;\n    speed = 1;\n    c = color(0);\n  }\n\n  // Secondo Constructor\n  Car(int tempCarLength) {\n    carLength = tempCarLength;\n    xPos = 0;\n    yPos = 200;\n    speed = 1;\n    c = color(0);\n  }\n\n  // Secondo Constructor\n  Car(int tempCarLength, int tempXPos) {\n    carLength = tempCarLength;\n    xPos = tempXPos;\n    yPos = 200;\n    speed = 1;\n    c = color(0);\n  }\n\n  Car(int tempCarLength, int tempXPos, int tempYPos) {\n    carLength = tempCarLength;\n    xPos = tempXPos;\n    yPos = tempYPos;\n    speed = 1;\n    c = color(0);\n  }\n\n  Car(int tempCarLength, int tempXPos, int tempYPos, float tempSpeed) {\n    carLength = tempCarLength;\n    xPos = tempXPos;\n    yPos = tempYPos;\n    speed = tempSpeed;\n    c = color(0);\n  }\n\n  Car(int tempCarLength, int tempXPos, int tempYPos, float tempSpeed, color tempColor) {\n    carLength = tempCarLength;\n    xPos = tempXPos;\n    yPos = tempYPos;\n    speed = tempSpeed;\n    c = tempColor;\n  }\n\n  // Metodi\n  void display() {\n    rectMode(CENTER);\n    fill(c);\n    rect(xPos, yPos, carLength, 10);\n  }\n\n  void move() {\n    xPos = xPos + speed;\n  }\n}\n</code></pre> <p>Sottolineo un paio di cose:</p> <ol> <li>Ho\u00a0aggiornato la nostra classe senza toccare il codice del nostro sketch principale. Questa \u00e8 la potenza della programmazione orientata agli oggetti: modificare porzioni di codice senza andare a intaccare\u00a0le altre parti che compongono il programma.</li> <li>Ho utilizzato per la prima volta il datatype color. Non \u00e8 niente di difficile ma, dal momento che non ho intenzione di spiegare come funziona in questo post, vi invito a leggere il manuale.</li> <li>Ho cambiato il datatype di speed in\u00a0float e sono stato costretto a cambiarlo anche per\u00a0xPos\u00a0dal momento che nella funzione move() i due parametri vengono sommati. Se avessi lasciato xPos come int, Processing mi avrebbe restituito un errore.</li> </ol> <p>Ora che la nostra classe \u00e8 completa, possiamo sbizzarrirci a passare quanti parametri vogliamo, l'importante\u00a0\u00e8 \u00a0ricordarsi l'ordine dei parametri e i tipi di dati accettati:</p> <p>myCar = new Car(25, 50, 200, 0.5, color(255, 255, 0));</p> <p>Il bello \u00e8 che possiamo utilizzare anche delle funzioni per passare i parametri. Vi ricordate di random?</p> <p>myCar = new Car(25, 50, 200, random(5), color(random(255), random(255), random(255)));</p>"},{"location":"primi-passi/oop-classi-e-oggetti-parte-2/#creiamo-n-oggetti","title":"Creiamo\u00a0n\u00a0oggetti","text":"<p>Nell'introduzione agli oggetti avevo specificato che un punto di forza dell'OOP \u00e8 poter creare pi\u00f9 istanze dello stesso oggetto.\u00a0Come possiamo, dunque, creare 3\u00a0macchine?</p> <p>Riprendiamo in mano il nostro sketch principale e aggiungiamo altre due variabili di tipo\u00a0Car chiamate myCar2 e myCar3, in setup() creiamo due nuove istanze degli oggetti e, in draw() ci assicuriamo di richiamare, per ciascuna, i\u00a0metodi\u00a0display() e move().</p> <pre><code>Car myCar, myCar2, myCar3;\n\nvoid setup() {\n  size(500, 500);\n  myCar = new Car(25, 50, 200, random(5), color(random(255), random(255), random(255)));\n  myCar2 = new Car(int(random(5, 50)), int(random(width)), int(random(height)), random(5), color(random(255), random(255), random(255)));\n  myCar3 = new Car(int(random(5, 50)), int(random(width)), int(random(height)), random(5), color(random(255), random(255), random(255)));\n}\n\nvoid draw() {\n  background(255);\n  myCar.display();\n  myCar.move();\n\n  myCar2.display();\n  myCar2.move();\n\n  myCar3.display();\n  myCar3.move();\n}\n</code></pre> <p>Premiamo su\u00a0Run:</p> <p></p> <p>Fino a qui tutto bene, ma, a questo punto la domanda che sorge spontanea \u00e8: se volessimo creare\u00a0decine o\u00a0centinaia\u00a0di oggetti? Dovremmo impazzire con il copia-incolla. Chiaramente esiste una soluzione pi\u00f9 comoda: utilizzare gli array che, per l'appunto, saranno il prossimo argomento che tratteremo.</p>"},{"location":"primi-passi/oop-classi-e-oggetti-parte-2/#compiti-a-casa","title":"Compiti a casa","text":"<p>\u00c8 arrivato il momento di dimostrare di aver capito come funziona la programmazione ad oggetti: riprendete in mano l'esercizio Bouncing Ball (parte 1 e parte 2) e modificate il codice per renderlo object-oriented.</p>"},{"location":"primi-passi/oop-sintassi-di-classi-e-oggetti/","title":"Sintassi di classi e oggetti","text":""},{"location":"primi-passi/oop-sintassi-di-classi-e-oggetti/#oop-sintassi-di-classi-e-oggetti","title":"OOP: Sintassi di classi e oggetti","text":"<p>La settimana scorsa abbiamo fatto un'introduzione generale alla programmazione orientata agli oggetti; con questo post\u00a0entreremo nello specifico analizzando la sintassi corretta da utilizzare quando si scrive una\u00a0classe e quando si usa un\u00a0oggetto in Processing.</p>"},{"location":"primi-passi/oop-sintassi-di-classi-e-oggetti/#sintassi-della-classe","title":"Sintassi della classe","text":"<p>Ricordo che per\u00a0classe intendiamo il template\u00a0di partenza che utilizzeremo per creare nuovi oggetti.\u00a0Per creare una nuova classe abbiamo solo bisogno di assegnargli un nome ma, se vogliamo sfruttare al massimo l'OOP, ciascuna classe avr\u00e0 le seguenti caratteristiche:\u00a0nome, dati, constructor\u00a0e\u00a0metodi.</p> <pre><code>class Car {\n  // Dati\n  int carLength;\n  int xPos;\n  int yPos;\n  int speed;\n\n  // Constructor\n  Car() {\n    carLength = 10;\n    xPos = 0;\n    yPos = 200;\n    speed = 1;\n  }\n\n  // Metodi\n  void display() {\n    rectMode(CENTER);\n    fill(0);\n    rect(xPos, yPos, carLength, 10);\n  }\n\n  void move() {\n    xPos = xPos + speed;\n  }\n}\n</code></pre> <p>Abbiamo scritto la nostra prima classe:\u00a0Car. Per prima cosa sottolineo che le classi hanno sempre la prima lettera maiuscola: questo serve per differenziarle da tutti gli altri componenti che possiamo trovare in un programma (variabili, funzioni, ecc...).</p> <p>Come potete vedere, la classe ha dei dati\u00a0al suo interno che scriviamo sotto forma di variabili: la lunghezza dell'oggetto-macchina, la posizione X e Y di partenza e la velocit\u00e0. Tali dati sono solo dichiarati ma non inizializzati. Per questo ci serve il\u00a0constructor\u00a0che\u00a0\u00e8 quella funzione speciale che\u00a0serve per creare l'oggetto vero e proprio: per funzionare il constructor deve avere\u00a0lo stesso nome della classe.</p> <p>Nell'esempio qui sopra, ogni volta che creeremo l'oggetto Car\u00a0gli assegneremo di default i dati del constructor quindi una lunghezza di 10 pixel, x = 0, y = 200 e velocit\u00e0 pari a 1.</p> <p>Infine ci sono i metodi ovvero le\u00a0funzionalit\u00e0 che vogliamo dare al nostro oggetto: in questo esempio la nostra macchina sar\u00e0 visualizzata sullo schermo (display) e poi si muover\u00e0\u00a0(move).</p>"},{"location":"primi-passi/oop-sintassi-di-classi-e-oggetti/#sintassi-delloggetto","title":"Sintassi dell'oggetto","text":"<pre><code>Car myCar;\n\nvoid setup() {\n  size(500, 500);\n  myCar = new Car();\n}\n\nvoid draw() {\n  background(255);\n  myCar.display();\n  myCar.move();\n}\n</code></pre> <p>Nella prima riga\u00a0stiamo dichiarando una variabile globale il cui nome \u00e8\u00a0myCar il cui data-type non sar\u00e0 uno dei classici incontrati finora (integer, float, stringa, ecc...) ma sar\u00e0 un oggetto\u00a0Car.</p> <p>All'interno del blocco di\u00a0setup() inizializziamo la nostra variabile myCar creando una nuova istanza dell'oggetto. In pratica con la sintassi myCar = new Car() stiamo richiamando il\u00a0constructor presente all'interno della classe. Con una sola riga di codice abbiamo assegnato alla nostra myCar una serie di valori: carLength = 10, xPos = 0, yPos = 200; speed = 1\u00a0senza doverli riscrivere.</p> <p>Nel ciclo\u00a0draw() richiamiamo i metodi della classe. Da notare che a differenza delle funzioni che abbiamo visto fino ad ora, dobbiamo utilizzare la cosiddetta dot syntax ovvero\u00a0myCar.display() perch\u00e9 display \u00e8 un metodo presente all'interno di myCar. Se scrivessimo solo display(); chiaramente non funzionerebbe.</p>"},{"location":"primi-passi/oop-sintassi-di-classi-e-oggetti/#il-nostro-primo-programma-ad-oggetti","title":"Il nostro primo programma ad oggetti","text":"<pre><code>Car myCar;\n\nvoid setup() {\n  size(500, 500);\n  myCar = new Car();\n}\n\nvoid draw() {\n  background(255);\n  myCar.display();\n  myCar.move();\n}\n\n\nclass Car {\n  // Dati\n  int carLength;\n  int xPos;\n  int yPos;\n  int speed;\n\n  // Constructor\n  Car() {\n    carLength = 10;\n    xPos = 0;\n    yPos = 200;\n    speed = 1;\n  }\n\n  // Metodi\n  void display() {\n    rectMode(CENTER);\n    fill(0);\n    rect(xPos, yPos, carLength, 10);\n  }\n\n  void move() {\n    xPos = xPos + speed;\n  }\n}\n</code></pre> <p>Ecco il codice completo del nostro programma. Potete notare come\u00a0la classe costituisca un nuovo blocco di codice all'interno del programma. Il codice diventa pi\u00f9 pulito e facile da leggere perch\u00e9 all'interno di setup e draw troviamo pochissime righe di codice. Copiando e incollando il codice e cliccando su Run vedrete un quadratino di 10x10px che si muover\u00e0 sullo schermo.</p> <p>Mi rendo conto che in alcuni punti la spiegazione possa essere arzigogolata ma spero che vi sia tutto chiaro; potete provare a cambiare alcune porzioni di codice per verificare se tutto vi torna.</p>"},{"location":"primi-passi/primitive-2d-point-line-rect-ellipse-triangle/","title":"Primitive 2D: point(), line(), rect(), ellipse(), triangle()","text":"<p>Nel capitolo precedente abbiamo realizzato il nostro primo sketch\u00a0disegnando una linea sullo schermo\u00a0in Processing. Proseguiamo il nostro percorso con una panoramica\u00a0sulle altre forme di base, chiamate primitive 2D, che utilizzeremo di frequente\u00a0nei nostri programmi futuri.</p> <p>Cominciare a imparare a memoria i nomi delle funzioni che usiamo maggiormente e la loro sintassi corretta\u00a0\u00e8 di fondamentale importanza quando si impara a programmare.\u00a0Talvolta, per\u00f2, pu\u00f2 capitare di avere dei dubbi e di non essere sicuri al cento per cento\u00a0della sintassi o dei parametri di una funzione.</p> <p>Se vi trovate in questa situazione, anzich\u00e9 andare per tentativi e perdere tempo inutilmente, consiglio di andare a dare un'occhiata nel Reference.</p>"},{"location":"primi-passi/primitive-2d-point-line-rect-ellipse-triangle/#reference-la-nostra-guida","title":"Reference: la nostra guida","text":"<p>Sul sito di Processing all'indirizzo\u00a0https://processing.org/reference/\u00a0trovate l'elenco di tutte le funzioni disponibili in questo linguaggio, cliccando su\u00a0una di esse \u2013 potete provare, ad esempio, a cliccare su line() \u2013 troviamo il dettaglio di quella funzione: nome, esempi, descrizione, sintassi e parametri.</p> <p> </p> <p>Se non abbiamo accesso a internet, quando installiamo Processing sul nostro computer viene copiata sul nostro hard disk anche\u00a0una copia completa e aggiornata del Reference. Per aprirla \u00e8 sufficiente cliccare sul menu <code>Help &gt; Reference</code></p> <p>Un altro trucco che ci permette di velocizzare molto il lavoro di ricerca \u00e8 l'utilizzo\u00a0del\u00a0Find in Reference.\u00a0Se stiamo lavorando a uno sketch e abbiamo gi\u00e0 scritto del codice, evidenziando il nome della funzione su cui abbiamo dei dubbi possiamo cliccare su\u00a0<code>Help &gt; Find in Reference</code> \u2013\u00a0su Mac abbreviato con <code>\u21e7\u2318F</code> (Shift + Command + F) \u2013 per accedere direttamente alla pagina del manuale che tratta di quella funzione specifica.</p>"},{"location":"primi-passi/primitive-2d-point-line-rect-ellipse-triangle/#come-leggere-il-reference","title":"Come leggere il reference","text":"<p>La documentazione\u00a0\u00e8 disponibile solo in inglese ma, con un piccolo sforzo, non \u00e8 difficile carpire le informazioni che ci interessano.</p> <p>Quando clicchiamo su una funzione, troviamo le seguenti sezioni:</p> <ul> <li>Name: viene riportato il nome della funzione.</li> <li>Examples: con poche righe di codice e delle immagini ci vengono mostrati degli esempi di funzionamento.</li> <li>Description: in modo pi\u00f9 o meno dettagliato in base alla complessit\u00e0 della funzione, viene descritto il suo funzionamento e i parametri\u00a0accettati. Nel caso di line(), vengono indicate\u00a0anche altre funzioni che possiamo usare in concomitanza con la prima per, ad esempio, colorare la nostra linea.</li> <li>Syntax:\u00a0la sintassi corretta\u00a0per la funzione. Alcune funzioni possono accettare un numero diverso di parametri \u2013 nel caso di line()\u00a0quattro\u00a0se stiamo lavorando in 2D oppure sei nel caso in cui il nostro sketch sia in 3D \u2013\u00a0che portano, ovviamente, a risultati diversi.</li> <li>Parameters: i tipi di parametri\u00a0che sono accettati. Questo sar\u00e0 pi\u00f9 chiaro quando parleremo, per l'appunto, di variabili e tipi di dati prossimamente.</li> <li>Returns: che tipo di dati la funzione restituisce in output. Anche in questo caso, sar\u00e0 pi\u00f9 chiaro quando\u00a0tratteremo in modo pi\u00f9 approfondito le funzioni.</li> <li>Related: le funzioni correlate a quella cercata.</li> </ul>"},{"location":"primi-passi/primitive-2d-point-line-rect-ellipse-triangle/#primitive-2d","title":"Primitive 2D","text":"<p>\u00c8 arrivato il momento di disegnare un po' di primitive 2D. Per comodit\u00e0 utilizzer\u00f2 sempre la funzione size(), che abbiamo gi\u00e0 incontrato precedentemente, all'inizio di ogni sketch per impostare la dimensione della finestra a 500 pixel di altezza e larghezza.</p>"},{"location":"primi-passi/primitive-2d-point-line-rect-ellipse-triangle/#punto-point","title":"Punto \u2013 point()","text":"<p>La funzione point() disegna un punto di dimensione pari a 1 pixel sullo schermo.\u00a0Quando lavoriamo in 2D, accetta due parametri:\u00a0x\u00a0e y che sono, rispettivamente, la coordinata orizzontale e quella verticale.</p> <pre><code>size(500, 500);\npoint(250, 250);\n</code></pre> <p>Il punto, di colore nero, \u00e8 stato disegnato\u00a0al centro della finestra nella posizione x = 250 e y = 250. Data la dimensione ridotta del pixel sullo schermo, \u00e8 possibile che facciate fatica a vederlo.</p>"},{"location":"primi-passi/primitive-2d-point-line-rect-ellipse-triangle/#linea-line","title":"Linea \u2013 line()","text":"<p>Della funzione line()\u00a0abbiamo gi\u00e0 discusso ma, per completezza, non potevo escluderla\u00a0da questo post. A differenza di point(), per disegnare una linea abbiamo bisogno di quattro parametri: x e y del punto di partenza e di arrivo.</p> <pre><code>size(500, 500);\nline(100, 150, 400, 250);\n</code></pre>"},{"location":"primi-passi/primitive-2d-point-line-rect-ellipse-triangle/#rettangolo-rect","title":"Rettangolo \u2013 rect()","text":"<p>rect() \u00e8 la funzione che ci permette di disegnare un rettangolo sullo schermo.\u00a0Se per disegnare un punto occorrevano due parametri e per una linea ne sono serviti quattro, potreste pensare che per il rettangolo ne servano almeno otto, due parametri x e y per ogni angolo. Ma non \u00e8 cos\u00ec! Se, infatti, avessimo le coordinate dei quattro punti sarebbe comunque difficile stabilire quale punto deve essere collegato al seguente\u00a0e questo ci causerebbe forti mal di testa.</p> <p>La funzione rect(), quando si lavora in 2D, ha bisogno sempre di quattro parametri: x e y del punto di origine e poi larghezza e altezza del rettangolo.</p> <pre><code>size(500, 500);\nrect(250, 250, 100, 150);\n</code></pre> <p>Queste due linee di codice si possono quindi tradurre in:</p> <ul> <li>Imposta la misura della finestra: 500 pixel in altezza e 500 in larghezza</li> <li>Disegna un rettangolo il cui punto di origine sia x = 250, y = 250, largo 100 pixel e alto 150 pixel.</li> </ul> <p>Ecco l'immagine che verr\u00e0 prodotta:</p> <p></p> <p>Come\u00a0avrete sicuramente notato, cos\u00ec come per lo schermo il punto di origine \u00e8 sempre l'angolo in alto a sinistra, anche per i rettangoli viene considerato di default come punto di origine lo stesso angolo della forma. Se vogliamo modificare questo comportamento esiste una funzione chiamata\u00a0rectMode(). </p> <p>Modifichiamo leggermente il codice precedente:</p> <pre><code>size(500, 500);\nrectMode(CENTER);\nrect(250, 250, 100, 150);\n</code></pre> <p>Ed ecco come cambia il risultato:</p> <p></p> <p>Dal momento che il computer esegue in ordine un'operazione alla volta, dobbiamo ovviamente impostare rectMode() prima di disegnare il rettangolo, altrimenti l'istruzione verr\u00e0 ignorata.</p> <p>Se volessimo disegnare un quadrato, \u00e8 sufficiente utilizzare la funzione rect() impostando larghezza e altezza del rettangolo di pari dimensioni.</p>"},{"location":"primi-passi/primitive-2d-point-line-rect-ellipse-triangle/#ellisse-ellipse","title":"Ellisse \u2013 ellipse ()","text":"<p>Con lo stesso principio usato per rect() possiamo usare la funzione ellipse() per disegnare ellissi e cerchi. Anche questa funzione accetta quattro parametri: x e y del punto di origine e larghezza e altezza dell'ellisse (nel caso siano uguali, verr\u00e0 disegnato un cerchio).</p> <pre><code>size(500, 500);\nellipse(250, 250, 150, 150);\n</code></pre> <p></p> <p>Da notare che esiste la funzione\u00a0ellipseMode() ma, a differenza dei rettangoli, di default il punto di riferimento degli ellissi e dei cerchi \u00e8 sempre il centro della forma.</p>"},{"location":"primi-passi/primitive-2d-point-line-rect-ellipse-triangle/#triangolo-triangle","title":"Triangolo \u2013 triangle()","text":"<p>Infine la funzione triangle() ci permette di disegnare un triangolo indicando come parametri le coordinate x e y dei tre vertici del triangolo.</p> <pre><code>size(500, 500);\ntriangle(250, 200, 300, 300, 200, 300);\n</code></pre> <p></p> <p>Queste sono le forme che utilizzeremo maggiormente nei nostri prossimi esercizi. Come indicato nel reference, tra le primitive 2D ci sono altre due funzioni:\u00a0quad()\u00a0e\u00a0arc()\u00a0che in questo momento non \u00e8 il caso di approfondire.</p>"},{"location":"primi-passi/println-e-random/","title":"println e random","text":""},{"location":"primi-passi/println-e-random/#le-funzioni-println-e-random","title":"Le funzioni println() e random()","text":""},{"location":"primi-passi/println-e-random/#println","title":"println()","text":"<p>La settimana scorsa ho accennato alla funzione println(); per mostrarne bene il funzionamento, ho realizzato questo breve video:</p> <p></p> <p>Il codice di questo sketch \u00e8 molto semplice:</p> <pre><code>void setup() {\n  size(700, 500);\n}\nvoid draw() {\n  println(\"Mouse X: \" + mouseX + \" : Mouse Y: \" + mouseY);\n}\n</code></pre> <p>Ho creato una finestra di 700x500 pixel e, senza che venga disegnato nulla, chiedo al programma di mostrarmi nella console di debug il valore di mouseX e di mouseY in ogni istante.\u00a0Anche se in questo caso le variabili sono soltanto due, per aiutarmi a capire di quale stiamo parlando ho aggiunto un breve testo esplicativo. Come si evince dal codice, questo\u00a0testo aggiuntivo \u00e8\u00a0inserito tra virgolette \" \" e utilizzo il simbolo + per concatenare le varie parti della frase.</p> <p>Per completezza \u00e8 giusto dire che esistono anche le funzioni print()\u00a0e\u00a0printArray().\u00a0Quest'ultima ci sar\u00e0 molto utile quando cominceremo a utilizzare gli array, mentre, per quanto riguarda la prima, l'unica differenza rispetto a println() \u00e8 che il testo non va automaticamente a capo alla fine della frase.</p>"},{"location":"primi-passi/println-e-random/#random","title":"random()","text":"<p>Possiamo utilizzare la funzione random() per generare un po' di caos e rendere i nostri sketch interessanti affidandoci alla casualit\u00e0. Questa funzione\u00a0pu\u00f2 accettare uno o due valori\u00a0float in input e restituisce sempre un valore di tipo\u00a0float.\u00a0Se usiamo un parametro, la funzione restituir\u00e0 un valore causale compreso tra 0 e il parametro che abbiamo inserito; se, invece, inseriamo\u00a0due parametri, il valore in output\u00a0sar\u00e0 compreso tra essi.</p> <p>Come dicevo, questa funzione \u00e8 utile per creare dei programmi semplici ma di impatto.</p> <pre><code>/*\n * Utilizzo della funzione random() - Esempio: 1\n * by Federico Pepe\n * http://blog.federicopepe.com\n */\n\nvoid setup() {\n  size(700, 500);\n  background(255);\n}\nvoid draw() {\n  ellipse(random(width), random(height), 10, 10 );\n}\n</code></pre> <p>Questo sketch\u00a0crea dei cerchi di dimensioni 10, 10 in posizioni casuali all'interno della finestra: la x \u00e8 compresa tra 0 e la larghezza della finestra e la y tra 0 e l'altezza.</p> <p></p>"},{"location":"primi-passi/println-e-random/#problema","title":"Problema:","text":"<p>Se volessimo fare in modo che i cerchi abbiano tutti dimensioni diverse comprese tra 10 e 50? Immagino che qualcuno di voi abbia pensato a qualcosa del genere:</p> <p>ellipse(random(width), random(height), random(10, 50), \u00a0random(10,50));</p> <p>Purtroppo questa soluzione non \u00e8 corretta: quante possibilit\u00e0 abbiamo che il numero casuale estratto sia per la larghezza che per l'altezza del cerchio sia uguale disegnando, dunque, un cerchio? Se inserite questa riga di codice nell'esempio qui sopra, noterete che verranno disegnati principalmente ellissi.</p> <p>Dobbiamo, quindi, fare in modo che la dimensione sia casuale e compresa tra 10 e 50 ma che sia uguale per larghezza e altezza. Vi viene qualche idea?</p> <p>Forse una variabile potrebbe tornarci utile!</p> <p>Creiamo una variabile di nome radius\u00a0di tipo float e in ogni ciclo draw() gli assegnamo un valore compreso tra 0 e 50 con la funzione random. Utilizziamo, poi, la variabile all'interno della funzione ellipse sia per la larghezza che per l'altezza.</p> <pre><code>/*\n * Utilizzo della funzione random() - Esempio: 2\n * by Federico Pepe\n * http://blog.federicopepe.com\n */\nfloat radius;\n\nvoid setup() {\n  size(700, 500);\n  background(255);\n}\nvoid draw() {\n  radius = random(10, 50);\n  ellipse(random(width), random(height), radius, radius);\n}\n</code></pre> <p>]</p> <p>Come ultimo esempio, modifichiamo ulteriormente il nostro programma per aggiungere un po' di colore. Anche in questo caso, utilizziamo la funzione random limitandola in un range compreso tra 0 e 255 (vi ricordate la lezione sui colori RGB, vero?).</p> <p>Aggiungiamo nel nostro programma:</p> <p><code>fill(random(255), random(255), random(255));</code></p> <p></p> <p>Voil\u00e0!</p>"},{"location":"primi-passi/schermo-pixel-e-linee/","title":"Schermo, pixel e linee","text":"<p>Una volta scaricato e installato Processing, \u00e8 arrivato il momento di cominciare sporcarsi le mani e a programmare il nostro primo\u00a0sketch.\u00a0Se apriamo l'IDE e clicchiamo sul pulsante\u00a0Run\u00a0senza scrivere alcuna riga di codice, dopo qualche secondo comparir\u00e0 una finestra simile a quella nell'immagine qui sotto.</p> <p></p> <p>Complimenti! Questo \u00e8 il vostro primo programma funzionante realizzato con questo linguaggio di programmazione.\u00a0Mi rendo conto che per molti, a prima vista, potrebbe non sembrare una grande conquista ma vi assicuro che se avessimo dovuto raggiungere\u00a0lo stesso risultato con altri linguaggi, non sarebbe stato cos\u00ec semplice.</p>"},{"location":"primi-passi/schermo-pixel-e-linee/#lavorare-con-i-pixel","title":"Lavorare\u00a0con i pixel","text":"<p>Lo schermo \u00e8 la nostra tela.\u00a0Prima di cominciare a disegnare qualcosa su di esso\u00a0\u00e8\u00a0dunque necessario fare un paio di considerazioni a riguardo: per prima cosa lo schermo \u00e8\u00a0composto da una griglia di pixel che, per semplicit\u00e0, possiamo\u00a0paragonare a un foglio di carta millimetrata.</p> <p>Il pixel \u00e8 dunque la nostra unit\u00e0 di misura\u00a0e la sua dimensione \u00e8 cos\u00ec ridotta\u00a0che, a occhio nudo, \u00e8 difficile distinguere un pixel da quello adiacente.</p> <p>Quando alle elementari abbiamo cominciato a disegnare\u00a0punti, linee e forme geometriche sulla carta millimetrata,\u00a0siamo stati abituati a lavorare\u00a0all'interno di un piano cartesiano con punto di origine (0, 0) normalmente posizionato al centro del foglio come nell'immagine seguente.</p> <p></p> <p>La differenza principale rispetto a come siamo sempre stati abituati a ragionare\u00a0\u00e8 che sullo schermo del computer il punto di origine non si trova al centro ma nell'angolo in alto a sinistra.</p> <p></p> <p>Come \u00e8 facile intuire, il vantaggio di questo sistema \u00e8 che qualsiasi punto sullo schermo ha sempre un valore positivo; questo ci torner\u00e0 molto utile quando cominceremo a fare dei programmi pi\u00f9 complessi.</p>"},{"location":"primi-passi/schermo-pixel-e-linee/#disegnamo-una-linea-sullo-schermo","title":"Disegnamo una linea sullo schermo","text":"<p>Copiate e incollate questo codice su Processing e poi premete il tasto\u00a0Run.</p> <pre><code>size(500, 500);\nline(100, 150, 400, 250);\n</code></pre> <p>Questo \u00e8 il risultato che dovrebbe comparirvi: una linea nera su sfondo grigio.</p> <p></p> <p>Nel caso in cui questo non avvenga, \u00e8 possibile che abbiate sbagliato qualcosa nel copia-incolla. Provate a cliccare su\u00a0view raw e ricopiare nuovamente le due linee di codice.</p> <p>Per\u00a0questo\u00a0sketch abbiamo utilizzato due linee di codice con due funzioni: size() e line().\u00a0Se andiamo a cercare nel Reference, il manuale sul sito di Processing, scopriamo a cosa servono\u00a0e qual \u00e8 la sintassi corretta da utilizzare: size(width, height) serve per determinare la grandezza della finestra su cui vogliamo lavorare e accetta due parametri: larghezza (in inglese width)\u00a0e altezza (in inglese height); line(x1, y1, x2, y2), invece, disegna una linea sullo schermo e, per funzionare, ha bisogno di quattro parametri: le coordinate x e y del punto di partenza\u00a0e di arrivo.</p> <p>In buona sostanza abbiamo scritto un programma con le seguenti istruzioni:</p> <ol> <li>Disegna una finestra di 500 pixel di altezza e 500 pixel di larghezza.</li> <li>Disegna una linea dal punto con coordinata x = 100 e y = 150 al punto con coordinate x = 450, y = 250.</li> </ol> <p>Non abbiamo dato nessun'altra indicazione e Processing ha utilizzato dei valori di default per tutto il resto: il grigio dello sfondo e il nero della linea.</p>"},{"location":"primi-passi/schermo-pixel-e-linee/#limportanza-del-punto-e-virgola","title":"L'importanza del punto e virgola","text":"<p>Un'ultima cosa da notare \u00e8 che,\u00a0a differenza di\u00a0quando scriviamo, in programmazione utilizziamo\u00a0il punto e virgola per separare le varie istruzioni anzich\u00e9 il punto fermo. Questa \u00e8 una cosa da\u00a0memorizzare e imparare subito: molto spesso, i nostri programmi non funzionano perch\u00e9 ci siamo dimenticati di mettere proprio un punto e virgola al termine di un'istruzione (nei prossimi post vi insegner\u00f2 come riconoscere questo genere di errori grazie al debugger).\u00a0A differenza di noi umani che non abbiamo problemi a leggere un testo anche se manca un punto, i computer non riescono\u00a0capire se un'istruzione \u00e8 finita in assenza del punto e virgola.</p>"},{"location":"primi-passi/variabili-built-in/","title":"Variabili built-in","text":""},{"location":"primi-passi/variabili-built-in/#variabili-built-in","title":"Variabili built-in","text":"<p>Nell'ultimo post, abbiamo creato il nostro primo programma interattivo\u00a0sfruttando le potenzialit\u00e0 della funzione draw() che, vi ricordo, viene eseguita in un loop costante a 60fps (di default) dal momento in cui avviamo il nostro programma fino a quando non lo fermiamo.</p> <p>Negli ultimi due esempi di codice che ho postato ho aggiunto, senza dare troppe spiegazioni, due parole\u00a0mouseX\u00a0e\u00a0mouseY che possiamo definire come\u00a0variabili built-in.</p> <p>\u00c8 arrivato il momento di capire cosa intentiamo per\u00a0variabili, come funzionano\u00a0e se ce ne sono altre che possiamo utilizzare.</p>"},{"location":"primi-passi/variabili-built-in/#hard-coding-vs-variabili","title":"Hard coding vs variabili","text":"<p>In tutti i programmi che abbiamo realizzato finora, abbiamo\u00a0sempre scritto i parametri che volevamo utilizzare direttamente nelle funzioni. Per fare un esempio: per disegnare un cerchio con un diametro di 100 pixel al centro di una finestra di dimensione 500x500 pixel, la linea di codice che abbiamo usato \u00e8:</p> <p><code>ellipse(250, 250, 100, 100);</code></p> <p>Questa pratica viene definita\u00a0hard coding ed \u00e8 fortemente sconsigliata perch\u00e9\u00a0rende i nostri programmi lunghi da modificare e inutilizzabili o imprecisi al variare di alcune condizioni (se, riprendendo l'esempio di cui sopra, modifico la dimensione della finestra portandola a 700x700 pixel, il cerchio non sar\u00e0 pi\u00f9 centrato come prima).</p> <p>Pi\u00f9 avanti, in questo post, riprender\u00f2 l'esempio qui descritto con codice e screenshot.</p> <p>Per ovviare a questo problema si utilizzano delle variabili ovvero dei parametri che possono assumere un valore che pu\u00f2 essere cambiato durante l'esecuzione del programma attraverso, ad esempio, semplici funzioni matematiche.</p>"},{"location":"primi-passi/variabili-built-in/#variabili-built-in_1","title":"Variabili built-in","text":"<p>\u00c8 possibile creare un numero di variabili a nostro piacimento e con tipologie di dati differenti e, in un altro post, vi spiegher\u00f2 come fare. In questo articolo\u00a0voglio concentrarmi su un\u00a0insieme particolare di variabili: quelle\u00a0cosiddette\u00a0built-in ovvero gi\u00e0 presenti \"all'interno\" di Processing.</p> <p>Una cosa molto importante quando si utilizzano variabili\u00a0\u00e8 prestare attenzione alla sintassi corretta:\u00a0Processing ci viene in aiuto colorandole di rosa.</p> <p></p>"},{"location":"primi-passi/variabili-built-in/#mousex-mousey","title":"mouseX, mouseY","text":"<p>Abbiamo gi\u00e0 usato mouseX e mouseY in uno sketch e abbiamo capito che,\u00a0se inseriamo queste variabili, all'interno del blocco di codice draw()\u00a0ci restituiscono\u00a0in tempo reale\u00a0i valori\u00a0X e Y del mouse quando ci muoviamo all'interno della finestra.</p>"},{"location":"primi-passi/variabili-built-in/#width-height","title":"width, height","text":"<p>width e height significano letteralmente larghezza e altezza e, com'\u00e8 facile intuire, restituiscono le dimensioni\u00a0della finestra dopo che queste sono state impostate nel blocco di codice setup().</p> <p>Analizziamo insieme questo codice e il risultato finale:</p> <pre><code>/*\n * Hard coding vs built-in variables\n * by Federico Pepe\n * http://blog.federicopepe.com\n */\nvoid setup() {\n  // Imposto la grandezza della finestra a 500x500px\n  size(500, 500);\n  // Imposto colore di riempimento ed elimino il bordo\n  noStroke();\n  fill(255, 0, 0, 100);\n  // Disegno un cerchio di diametro 100px al centro\n  // della finestra utilizzando l'hard-coding\n  ellipse(250, 250, 100, 100);\n  // Disegno un cerchio di diametro 150px al centro\n  // della finestra utilizzando due variabili built-in\n  ellipse(width/2, height/2, 150, 150);\n}\n</code></pre> <p></p> <p>Abbiamo disegnato due cerchi di diametro differente in una finestra di 500x500px. Nel primo caso i parametri x e y sono stati inseriti direttamente (hard-coding) quindi:</p> <p><code>ellipse(250, 250, 100, 100);</code></p> <p>Nel secondo cerchio, invece, abbiamo utilizzato le variabili width e height e, per\u00a0centrare il cerchio, le abbiamo divise per 2.</p> <p><code>ellipse(width/2, height/2, 150, 150);</code></p> <p>Cosa accade se modifico la dimensione della finestra?</p> <pre><code>/*\n * Hard coding vs built-in variables\n * by Federico Pepe\n * http://blog.federicopepe.com\n */\nvoid setup() {\n  // Imposto la grandezza della finestra a 700x700px\n  size(700, 700);\n  // Imposto colore di riempimento ed elimino il bordo\n  noStroke();\n  fill(255, 0, 0, 100);\n  // Disegno un cerchio di diametro 100px al centro\n  // della finestra utilizzando l'hard-coding\n  ellipse(250, 250, 100, 100);\n  // Disegno un cerchio di diametro 150px al centro\n  // della finestra utilizzando due variabili built-in\n  ellipse(width/2, height/2, 150, 150);\n}\n</code></pre> <p></p> <p>Come previsto, il primo cerchio si trova spostato in alto a sinistra rispetto al centro della finestra mentre, il secondo, \u00e8 rimasto perfettamente centrato. Per ottenere a livello visivo lo stesso effetto di prima nel caso del primo cerchio dovrei andare a modificare direttamente i parametri (oppure sostituirli con delle variabili).</p>"},{"location":"primi-passi/variabili-built-in/#pmousex-pmousey","title":"pmouseX, pmouseY","text":"<p>Le ultime due variabili built-in di cui voglio parlarvi sono pmouseX e pmouseY che, a differenza di mouseX e mouseY restituiscono\u00a0i valori x e y del mouse\u00a0del frame\u00a0precedente\u00a0a quello corrente.</p> <p>Come possiamo utilizzarle in modo creativo? Con poche righe di codice possiamo, ad esempio, creare un programma per disegnare:</p> <pre><code>/*\n * Drawing Tool\n * by Federico Pepe\n * http://blog.federicopepe.com\n */\nvoid setup() {\n  size(700, 700);\n  background(0);\n}\n\nvoid draw() {\n  stroke(255);\n  line(pmouseX, pmouseY, mouseX, mouseY);\n}\n</code></pre> <p></p>"},{"location":"primi-passi/variabili-in-processing-creazione-e-personalizzazione/","title":"Creazione e personalizzazione","text":""},{"location":"primi-passi/variabili-in-processing-creazione-e-personalizzazione/#variabili-in-processing-creazione-e-personalizzazione","title":"Variabili in Processing: creazione e personalizzazione","text":"<p>Abbiamo gi\u00e0 incontrato il termine\u00a0variabile un paio di settimane fa quando avevo descritto, ad esempio,\u00a0come utilizzare\u00a0mouseX e mouseY per rendere i nostri sketch interattivi.</p> <p>Come avevo scritto in quel post:</p> <p>le variabili sono dei parametri che possono assumere un valore che pu\u00f2 essere cambiato durante l\u2019esecuzione del programma attraverso, ad esempio, semplici funzioni matematiche.</p> <p>Oggi impareremo a\u00a0creare delle variabili personalizzate\u00a0e capiremo come\u00a0utilizzarle nei nostri programmi. Quella di oggi \u00e8 una lezione di fondamentale importanza perch\u00e9, come avrete modo di vedere, cambier\u00e0 completamente il vostro modo di programmare.</p>"},{"location":"primi-passi/variabili-in-processing-creazione-e-personalizzazione/#creare-delle-variabili","title":"Creare\u00a0delle variabili","text":"<p>Creare una variabile \u00e8 un processo relativamente\u00a0semplice. I passaggi che dobbiamo fare sono i seguenti:</p> <ol> <li>Dichiarazione della variabile<ul> <li>Assegnazione di un data type</li> <li>Assegnazione di un nome alla variabile</li> </ul> </li> <li>Inizializzazione della variabile</li> <li>Utilizzo della variabile</li> </ol> <p>In poche parole dobbiamo dare un nome alla variabile, dirgli che tipologia di informazione\u00a0vogliamo che contenga e dobbiamo assegnargli un valore iniziale.\u00a0Se questi passaggi sono fatti nel modo corretto (e, tra poco, vi spiegher\u00f2 come fare), poi potremmo usare quelle variabili a nostro piacimento.</p> <p>Partiamo da un esempio:</p> <pre><code>int lunghezza;\nlunghezza = 110;\n</code></pre> <p>Cosa abbiamo fatto con queste due linee di codice? Abbiamo creato una variabile\u00a0di tipo\u00a0integer (abbreviato in\u00a0int) chiamata lunghezza\u00a0e l'abbiamo inizializzata assegnando un valore pari a 110.</p> <p>A una variabile possiamo assegnare il nome che vogliamo senza particolari restrizioni a patto che tale nome\u00a0non\u00a0sia gi\u00e0 utilizzato\u00a0dalla sintassi di Processing. La regola empirica per capire se possiamo utilizzare un nome che abbiamo scelto \u00e8: se il nome che assegnamo\u00a0non cambia colore, non dovremmo avere problemi.</p> <p>Una\u00a0buona pratica da seguire \u00e8 quella di dare un nome alle variabili che sia significativo e rifletta l'utilizzo che verr\u00e0 fatto successivamente: questo render\u00e0 il nostro codice facilmente interpretabile anche a mesi o anni di distanza.\u00a0Quindi, bench\u00e9 io possa nominare delle variabili tizio,\u00a0caio, e\u00a0sempronio se quella variabile verr\u00e0 utilizzata per definire la X di un ellisse \u00e8 meglio chiamarla, ad esempio,\u00a0circleX.</p> <p>Dal momento che il nome\u00a0che assegniamo alle\u00a0variabili deve essere un'unica parola, i programmatori utilizzano il\u00a0cosiddetto CamelCase\u00a0per nominare variabili complesse. Nella pratica, si tratta di unire parole diverse tra loro lasciando le iniziali maiuscole (la prima lettera della variabile sempre minuscola). Ecco perch\u00e9, vedendo dei programmi in Processing, troverete variabili come:\u00a0backgroundColor\u00a0oppure\u00a0radiusValue, ecc...</p> <p>Ultima nota sui nomi delle variabili:\u00a0potendo scegliere\u00a0liberamente le parole da utilizzare non c'\u00e8 restrizione sulla lingua da utilizzare. Se volete rendere il vostro codice leggibile il pi\u00f9 possibile, conviene ovviamente\u00a0usare l'inglese.</p>"},{"location":"primi-passi/variabili-in-processing-creazione-e-personalizzazione/#tipi-di-dati","title":"Tipi di dati","text":"<p>Assegnare il tipo di dato corretto \u00e8 importante per evitare che il nostro programma smetta di funzionare\u00a0e ci restituisca un errore. Se, infatti, il programma si aspetta di trovare un numero intero e riceve\u00a0un numero decimale si bloccher\u00e0.</p> <p>I principali tipi di dati sono:</p> <ul> <li>integer: abbreviato in int e descrive un numero intero (es: 45)</li> <li>float: descrive un numero decimale (es: 34,20394)</li> <li>char: descrive un singolo carattere (es: 'A');</li> <li>String: descrive una sequenza di caratteri (es: 'Questa \u00e8 una stringa')</li> </ul> <p>Esistono anche altri tipi di dati e l'elenco completo pu\u00f2 essere trovato nel Reference. Per il momento \u00e8 sufficiente che impariate quelli descritti qui sopra.</p>"},{"location":"primi-passi/variabili-in-processing-creazione-e-personalizzazione/#scopo-delle-variabili","title":"Scopo delle variabili","text":"<p>Le variabili non devono essere per forza dichiarate e inizializzate tutte all'inizio del nostro programma. Possiamo farlo tranquillamente mentre procediamo con la scrittura del codice. Dobbiamo, per\u00f2, fare attenzione\u00a0allo scopo delle variabili ovvero in quale parte di codice\u00a0verr\u00e0 utilizzata.</p> <p>Anche in questo caso, credo sia meglio partire da un esempio:</p> <pre><code>int circleX; // dichiarazione\n\nvoid setup() {\n  size(400, 400);\n  circleX = 100; // inizializzazione\n}\n\nvoid draw() {\n  ellipse(circleX, 110, 50, 50); // utilizzo\n}\n</code></pre> <p>In questo breve programma ho creato una variabile circleX di tipo integer all'inizio del programma, nel blocco di codice setup() l'ho inizializzata assegnando un valore pari a 110 e l'ho utilizzata\u00a0in draw() per disegnare un cerchio. Se copiate e incollate il codice nell'editor di Processing e provate a farlo funzionare, non avrete alcun problema.</p> <p>Ora cambiamo leggermente il nostro codice:</p> <pre><code>int circleX; // dichiarazione\n\nvoid setup() {\n  size(400, 400);\n  circleX = 100; // inizializzazione\n  int circleY = 110; // dichiarazione e inizializzazione\n}\n\nvoid draw() {\n  ellipse(circleX, circleY, 50, 50); // utilizzo\n}\n</code></pre> <p>In questo secondo esempio ho fatto una piccola modifica: ho creato e inizializzato una variabile chiamata circleY all'interno della funzione\u00a0setup()\u00a0e l'ho utilizzata all'interno della funzione\u00a0draw(). Se proviamo a far partire questo programma, otterremo un errore Cannot find anything named \"circleY\":</p> <p></p> <p>Perch\u00e9 Processing non riesce a trovare la variabile circleY pur essendo stata dichiarata e inizializzata?\u00a0La differenza tra circleX e circleY \u00e8 che la prima \u00e8 una variabile\u00a0pubblica mentre la seconda \u00e8\u00a0privata. Cosa significa? Nel primo caso, essendo stata dichiarata all'inizio, circleX\u00a0pu\u00f2 essere usata ovunque all'interno del programma; circleY, invece,\u00a0\u00e8 stata dichiarata all'interno della funzione\u00a0setup() ma viene utilizzata dalla funzione\u00a0draw() e questo non \u00e8 possibile. \u00c8 come se ogni blocco di codice fosse un'entit\u00e0 privata a s\u00e9 stante e le variabili che vengono dichiarate al suo interno non possono essere utilizzate dagli altri blocchi di codice.</p> <p>Per far\u00a0funzionare questo secondo esempio abbiamo due possibilit\u00e0: spostare la dichiarazione di circleY\u00a0all'inizio del programma \u2013 l'inizializzazione pu\u00f2, invece, rimanere all'interno di setup() o\u00a0all'interno di draw() \u2013 oppure possiamo spostare la funzione ellipse() dentro il blocco di codice setup().</p> <p>Nel prossimo post vedremo insieme come modificare una (o pi\u00f9) variabili, controllarne in ogni momento il valore\u00a0e, attraverso esempi pratici,\u00a0utilizzarle.</p>"},{"location":"primi-passi/variabili-in-processing-ii-operazioni-matematiche/","title":"Operazioni matematiche","text":""},{"location":"primi-passi/variabili-in-processing-ii-operazioni-matematiche/#variabili-in-processing-ii-operazioni-matematiche","title":"Variabili in Processing II: operazioni matematiche","text":"<p>Con il post della settimana scorsa, la vostra vita da programmatori\u00a0ha sub\u00ecto un cambiamento radicale: imparare a utilizzare le variabili \u00e8 un notevole passo avanti che apre scenari inediti.</p>"},{"location":"primi-passi/variabili-in-processing-ii-operazioni-matematiche/#aumentare-il-valore-delle-variabili","title":"Aumentare il valore delle variabili","text":"<p>Il mio obiettivo per questo primo esempio\u00a0\u00e8 di disegnare un cerchio che, partendo da una posizione predefinita, si muova verso destra.</p> <p>Vi ricordo\u00a0che la funzione\u00a0ellipse() accetta quattro parametri: posizione x e y di origine, larghezza e altezza dell'ellisse. Dunque, di quante variabili avr\u00f2 bisogno? Siccome ho deciso di far muovere il mio cerchio da sinistra verso destra sull'asse x, la risposta \u00e8 molto semplice: una soltanto che chiamer\u00f2 ellipseX.</p> <p>Il tipo di dato di cui avr\u00f2 bisogno sar\u00e0 sicuramente numerico ma dovr\u00f2 utilizzare un numero intero (integer) o decimale (float)? Tecnicamente potrei usare entrambi ma, dal momento che i pixel non sono suddivisibile, utilizzer\u00f2 un integer.</p> <p>Ultimo problema: come faccio ad aumentare il valore della variabile? Visto che il blocco di codice draw() viene eseguito ripetutamente dal programma, sar\u00e0 sufficiente fare\u00a0un'addizione all'interno di esso.</p> <p>Per aumentare il valore della variabile di 1 ogni ciclo, abbiamo tre diverse\u00a0possibilit\u00e0:</p> <p><code>ellipseX = ellipseX + 1;</code></p> <p><code>ellipseX += 1;</code></p> <p><code>ellipseX ++;</code></p> <p>Il risultato che otteniamo \u00e8 sempre lo stesso; l'unico caso in cui c'\u00e8 una reale differenza tra le tre linee di codice sopra elencate\u00a0\u00e8 se volessimo aumentare la variabile di un valore diverso da 1\u00a0a ogni ciclo; in tal caso non potremmo usare il terzo modo ma dovremmo scrivere:</p> <p><code>ellipseX = ellipseX + 2;</code></p> <p><code>ellipseX += 2;</code></p> <p>Ecco, dunque,\u00a0il codice del nostro primo esempio:</p> <pre><code>/*\n * Utilizzo delle variabili II: Esempio 1\n * by Federico Pepe\n * http://blog.federicopepe.com\n */\n\nint ellipseX; // dichiarazione della variabile\n\nvoid setup() {\n  size(540, 540);\n  ellipseX = 0; // inizializzazione\n\n}\n\nvoid draw() {\n  background(255);\n  ellipse(ellipseX, height/2, 50, 50);\n  ellipseX = ellipseX + 1; // aumento il valore di ellipseX\n}\n</code></pre> <p>Se vi state chiedendo come mai la funzione background() sia in draw(), consiglio di rileggere questo post.</p> <p>Questo \u00e8 il risultato:</p> <p></p> <p>Attenzione: Per comodit\u00e0 ho creato una gif animata che viene riprodotta in loop; con il codice sopra indicato, una volta che il cerchio esce dallo schermo a dx, non ricompare al suo punto di partenza sulla sinistra.</p>"},{"location":"primi-passi/variabili-in-processing-ii-operazioni-matematiche/#operazioni-matematiche-con-le-variabili","title":"Operazioni matematiche con le variabili","text":"<p>Abbiamo visto come\u00a0effettuare una somma, per le altre operazioni matematiche, il codice \u00e8 simile:</p>"},{"location":"primi-passi/variabili-in-processing-ii-operazioni-matematiche/#sottrazione","title":"Sottrazione:","text":"<pre><code>ellipseX = ellipseX - 1;\n\nellipseX -= 1;\n\nellipseX --;\n</code></pre>"},{"location":"primi-passi/variabili-in-processing-ii-operazioni-matematiche/#moltiplicazione","title":"Moltiplicazione:","text":"<pre><code>ellipseX = ellipseX * 2;\n\nellipseX *= 2\n</code></pre>"},{"location":"primi-passi/variabili-in-processing-ii-operazioni-matematiche/#divisione","title":"Divisione:","text":"<pre><code>ellipseX = ellipseX / 2;\n\nellipseX /= 2;\n</code></pre> <p>Nel caso della moltiplicazione e della divisione \u00e8 molto improbabile trovare esempi di codice che utilizzano il secondo metodo.</p>"},{"location":"primi-passi/variabili-in-processing-ii-operazioni-matematiche/#debugging-delle-variabili-println","title":"Debugging delle variabili: println();","text":"<p>Quando si comincia a lavorare con le variabili, una delle funzioni pi\u00f9 utili da imparare \u00e8\u00a0println(). Essa ci permette di tenere costantemente monitorato il valore che assumono le variabili che stiamo utilizzando attraverso la console di debugging.</p> <p>Aggiungiamo questa nuova funzione nel nostro esempio di prima:</p> <pre><code>/*\n * Utilizzo delle variabili II: Esempio 2\n * by Federico Pepe\n * http://blog.federicopepe.com\n */\n\nint ellipseX; // dichiarazione della variabile\n\nvoid setup() {\n  size(540, 540);\n  ellipseX = 0; // inizializzazione\n\n}\n\nvoid draw() {\n  background(255);\n  ellipse(ellipseX, height/2, 50, 50);\n  ellipseX = ellipseX + 1; // aumento il valore di ellipseX\n  println(ellipseX);\n}\n</code></pre> <p></p> <p>Sulla funzione println() faremo un breve approfondimento in futuro perch\u00e9, essendo una delle funzioni che utilizzeremo di pi\u00f9, \u00e8 importante che sia chiaro il suo funzionamento; nel frattempo sbizzarritevi\u00a0a creare sketch animati utilizzando le variabili.</p>"},{"location":"text/2016-11-11-testi-processing/","title":"Testi in Processing: text(), textSize() e textAlign()","text":"<p>\u00c8 possibile utilizzare Processing non solo per disegnare forme, colori e animazioni sullo schermo ma anche per lavorare con testi.\u00a0Avere pieno controllo delle\u00a0parole sullo schermo pu\u00f2 essere utile in diversi progetti in particolare, per esperienza personale, nelle visualizzazioni di dati dove la giusta combinazione di grafica e testo pu\u00f2 rendere le nostre infografiche pi\u00f9 comprensibili.</p>","tags":["text","textalign","textsize"]},{"location":"text/2016-11-11-testi-processing/#visualizzare-un-testo-text","title":"Visualizzare un testo: text()","text":"<p>La prima funzione da imparare \u00e8\u00a0text().\u00a0Il suo funzionamento \u00e8 piuttosto semplice; i parametri accettati sono tre: il carattere o la stringa che vogliamo scrivere e la posizione x e y.</p> <pre><code>size(500, 200);\ntext(\"Questo \u00e8 un testo\", 10, height/2);\n</code></pre> <p></p> <p>Di default il testo \u00e8 di colore bianco e l'allineamento \u00e8 a sinistra. Come per le forme, per modificare il colore \u00e8 sufficiente utilizzare la funzione fill().</p> <pre><code>size(500, 200);\nfill(0);\ntext(\"Questo \u00e8 un testo\", 10, height/2);\n</code></pre>","tags":["text","textalign","textsize"]},{"location":"text/2016-11-11-testi-processing/#_1","title":"Testi in Processing: text(), textSize() e textAlign()","text":"<p>\u00c8 importante notare che la stringa all'interna della funzione deve essere scritta tra virgolette. Ovviamente \u00e8 possibile passare alla funzione anche una variabile di tipo String.</p> <pre><code>String testo = \"Questo \u00e8 un testo in una variabile\";\nsize(500, 200);\nfill(0);\ntext(testo, 10, height/2);\n</code></pre> <p></p>","tags":["text","textalign","textsize"]},{"location":"text/2016-11-11-testi-processing/#cambiare-la-dimensione-del-testo-textsize","title":"Cambiare la dimensione del testo: textSize()","text":"<p>La funzione textSize() imposta la grandezza della font. Una volta impostata, tutti i testi rappresentati al di sotto di questa funzione, avranno la stessa dimensione.</p> <pre><code>String testo = \"Questo \u00e8 un testo in una variabile\";\nsize(500, 200);\nfill(0);\ntext(testo, 10, 25);\ntextSize(18);\ntext(testo, 10, 50);\ntext(testo, 10, 100);\ntextSize(12);\ntext(testo, 10, 125);\n</code></pre> <p></p>","tags":["text","textalign","textsize"]},{"location":"text/2016-11-11-testi-processing/#allineare-il-testo-textalign","title":"Allineare il testo: textAlign()","text":"<p>L'ultimo controllo di base di cui abbiamo bisogno \u00e8 la funzione\u00a0textAlign() che ci permette di allineare il testo che stiamo mostrando sullo schermo. I parametri accettati sono\u00a0CENTER,\u00a0LEFT o\u00a0RIGHT scritti rigorosamente in maiuscolo.</p> <pre><code>size(500, 200);\nline(width/2, 0, width/2, height);\nfill(0);\ntextAlign(CENTER);\ntext(\"Testo allineato al centro\", width/2, 50);\ntextAlign(LEFT);\ntext(\"Testo allineato a sinistra\", width/2, 100);\ntextAlign(RIGHT);\ntext(\"Testo allineato a destra\", width/2, 150);\n</code></pre> <p></p> <p>La stessa funzione accetta anche un secondo parametro per regolare l'allineamento verticale:\u00a0TOP, CENTER, BOTTOM.</p> <p>Ecco l'esempio:</p> <pre><code>size(500, 200);\nfill(0);\ntextAlign(CENTER, TOP);\nline(0, 50, width, 50);\ntext(\"Allineamento verticale top\", width/2, 50);\ntextAlign(CENTER, CENTER);\nline(0, 100, width, 100);\ntext(\"Allineamento verticale centrato\", width/2, 100);\ntextAlign(CENTER, BOTTOM);\nline(0, 150, width, 150);\ntext(\"Allineamento verticale bottom\", width/2, 150);\n</code></pre> <p></p> <p>Per oggi \u00e8 tutto, nel prossimo post vedremo insieme come modificare le font.</p>","tags":["text","textalign","textsize"]},{"location":"text/2016-12-20-caricare-file-esterni-processing/","title":"Caricare file esterni in Processing","text":"<p>In tutti gli esempi visti finora abbiamo sempre utilizzato le funzioni interne di Processing per disegnare qualcosa sullo schermo. \u00c8 possibile, ovviamente, caricare all'interno dei nostri sketch\u00a0file esterni in vari formati come, ad esempio, font, immagini, file vettoriali, suoni e altro.</p> <p>Dati gli argomenti che affronteremo a breve, \u00e8 importante capire come effettuare questa operazione nel modo corretto per evitare di incorrere in problemi soprattutto quando distribuiamo i nostri programmi ad altre persone.</p> <p>La prima regola fondamentale che dobbiamo sempre tenere a mente\u00a0\u00e8 che prima di poter essere utilizzati, i file devono essere caricati dal nostro sketch. Questo avviene ogni volta che lanciamo il programma.</p> <p>Processing \u00e8 in grado di caricare file che:</p> <ul> <li>si trovano all'interno della cartella dello sketch</li> <li>si trovano in una cartella qualsiasi sul computer</li> <li>si trovano su un server accessibile via internet.</li> </ul> <p>Ciascuna di queste situazioni presenta dei pro e dei contro e non esiste una soluzione che possa andare bene in tutti i casi. La prima opzione \u00e8, per\u00f2, quella pi\u00f9 comune.</p> <p></p> <p>Tutti i file esterni sono generalmente inseriti in una cartella chiamata\u00a0data che troviamo all'interno della cartella dello sketch.</p>","tags":["file","immagini","jpg","media"]},{"location":"text/2016-12-20-caricare-file-esterni-processing/#aggiungere-file-dal-menu","title":"Aggiungere file dal menu","text":"<p>Cliccando sul menu\u00a0Sketch &gt; Add File... si aprir\u00e0 una finestra di dialogo dove andremo a selezionare il file da inserire.</p> <p></p>","tags":["file","immagini","jpg","media"]},{"location":"text/2016-12-20-caricare-file-esterni-processing/#drag-and-drop","title":"Drag and drop","text":"<p>La seconda opzione, forse la pi\u00f9 comoda, permette di trascinare uno o pi\u00f9 file direttamente nella finestra di processing.</p> <p></p>","tags":["file","immagini","jpg","media"]},{"location":"text/2016-12-20-caricare-file-esterni-processing/#aggiunta-manuale","title":"Aggiunta manuale","text":"<p>Oppure \u00e8 possibile aggiungere i file manualmente aprendo la cartella dello sketch dal menu\u00a0Sketch &gt; Show Sketch Folder, scorciatoia \u2318+K, creando una cartella\u00a0data (se non esiste) e copiando direttamente i file all'interno di essa.</p> <p></p>","tags":["file","immagini","jpg","media"]},{"location":"text/2016-12-20-caricare-file-esterni-processing/#consigli","title":"Consigli","text":"<p>Quando andremo a caricare il o i file \u00e8 buona regola specificare l'estensione, ad esempio\u00a0\"file.txt\"\u00a0e fare attenzione all'uso delle lettere maiuscole: se il file si chiama\u00a0immagine.jpg provare a caricare\u00a0Immagine.jpg,\u00a0immAgine.jpg o\u00a0immagine.JPG generer\u00e0 sempre un errore.</p> <p>Per rendere il contenuto del file disponibile all'interno dell'interno programma, normalmente si crea una variabile globale al di fuori dei cicli di\u00a0setup() e\u00a0draw() come avevo spiegato qui\u00a0nel paragrafo scopo delle variabili.</p>","tags":["file","immagini","jpg","media"]},{"location":"text/2017-01-03-font-personalizzati-processing/","title":"Font personalizzati: aggiungerli e utilizzarli","text":"<p>In Processing \u00e8 possibile utilizzare le font\u00a0che abbiamo installato sul nostro computer all'interno dei nostri sketch. In questo post vedremo come aggiungerli al nostro programma e come utilizzarli in modo efficace. Questi argomenti saranno\u00a0sicuramente utili a chi ha un background di tipo grafico e utilizza regolarmente Photoshop o Illustrator.</p>","tags":["createfont","pfont","textfont"]},{"location":"text/2017-01-03-font-personalizzati-processing/#font-vettoriali","title":"Font vettoriali","text":"<p>La prima funzione che dobbiamo usare per aggiungere le font \u00e8 createFont(),\u00a0necessaria per convertire un file in formato\u00a0TrueType (.ttf)\u00a0oppure\u00a0Open Type\u00a0(.otf) in modo tale da poter essere utilizzato con la funzione\u00a0text() di cui abbiamo parlato.</p> <p>Per vedere tutte le font installate compatibili, come indicato anche nell'esempio nel reference, basta scrivere le seguenti righe di codice:</p> <p>String[] fontList = PFont.list(); printArray(fontList);</p> <p>Queste due righe non fanno altro che generare e mostrare in console un'array di stringhe\u00a0con tutti i nomi delle font attualmente installate sul computer:</p> <p>[0] \"Serif\" [1] \"SansSerif\" [2] \"Monospaced\" [3] \"Dialog\" [4] \"DialogInput\" ... [862] \"Verdana\" [863] \"Verdana-Bold\" [864] \"Verdana-BoldItalic\" [865] \"Verdana-Italic\"</p> <p>Ora che sappiamo quali font \u00e8 possibile usare, dobbiamo convertirle. \u00c8 necessario utilizzare un\u00a0data type specifico per salvare tutte le informazioni relative ai caratteri:\u00a0PFont.</p> <p>Creiamo una variabile di tipo PFont e usiamo la funzione createFont() per convertire il formato utilizzando due parametri: il primo \u00e8 il nome della font, il secondo la grandezza di base.</p> <p>Con la funzione\u00a0textFont() diciamo al programma quale font usare.</p> <pre><code>// Rimuovi il commento per vedere l'elenco delle font installate.\n// String[] fontList = PFont.list();\n// printArray(fontList);\n\nPFont gill;\n\nvoid setup() {\n  size(500, 200);\n  gill = createFont(\"GillSans\", 28);\n  textFont(gill);\n  fill(0);\n  text(\"Questo \u00e8 un testo in GillSans\", 10, height/2);\n}\n\nvoid draw() {\n}\n</code></pre> <p>Questo il risultato:</p> <p></p> <p>Nel caso volessimo usare pi\u00f9 font all'interno del nostro programma, \u00e8 sufficiente\u00a0ripetere il processo con tutte i caratteri che vogliamo:</p> <pre><code>// Rimuovi il commento per vedere l'elenco delle font installate.\n// String[] fontList = PFont.list();\n// printArray(fontList);\n\nPFont gill, openSans;\n\nvoid setup() {\n  size(500, 200);\n  gill = createFont(\"GillSans\", 28);\n  openSans = createFont(\"OpenSans\", 28);\n  textFont(gill);\n  fill(0);\n  text(\"Questo \u00e8 un testo in GillSans\", 10, height/2);\n  textFont(openSans);\n  text(\"Questo \u00e8 un testo in OpenSans\", 10, height/2 + 40);\n}\n\nvoid draw() {\n}\n</code></pre> <p></p>","tags":["createfont","pfont","textfont"]},{"location":"text/2017-01-19-esercizio-con-il-testo/","title":"Esercizio: Testo psichedelico","text":"<p>Oggi vi propongo un esercizio molto semplice\u00a0per analizzare alcune funzioni relative al testo che non abbiamo avuto modo di approfondire nei post precedenti. L'esercizio riportato qui sotto mostra come siano sufficienti poche righe di codice per ottenere risultanti interessanti lavorando con del testo all'interno di Processing.</p> <p>Partiamo dal codice completo del programma:</p> <pre><code>/*\n * Esercizio: Testo Psichedelico\n * Federico Pepe, 19.01.2017\n * http://blog.federicopepe.com/processing\n*/\nString letters = \"\";\n\nvoid setup() {\n  size(500, 500);\n  background(255);\n  fill(0);\n  textSize(26);\n  textAlign(CENTER);\n}\n\nvoid draw() {\n  background(255);\n  for(int i = 0; i &lt;= letters.length(); i++) {\n    if(i % 2 == 0) {\n      fill(random(255), random(255), random(255));\n    } else {\n      fill(255);\n    }\n    text(letters, width/3 + i*1.5, height/2+i);\n  }\n}\n\nvoid keyPressed() {\n  if(key == BACKSPACE) {\n    if (letters.length() &gt; 0) {\n      letters = letters.substring(0, letters.length()-1);\n    }\n  }\n  else if(textWidth(letters+key) &lt; width)  {\n    letters = letters+key;\n  }\n}\n</code></pre> <p>L'intero programma si basa sulla variabile di tipo Stringa chiamata\u00a0letters\u00a0che dichiariamo e inizializziamo nella prima riga.</p>"},{"location":"text/2017-01-19-esercizio-con-il-testo/#void-keypressed","title":"void keyPressed()","text":"<p>Di questa funziona-evento abbiamo gi\u00e0 parlato in passato. Sappiamo che il codice all'interno viene eseguito quando viene premuto un tasto della tastiera. Partiamo da un controllo condizionale per verificare se stiamo premendo il tasto backspace, quello che usiamo per cancellare l'ultimo carattere inserito.</p> <p>Se la prima condizione \u00e8\u00a0true verifichiamo che\u00a0la lunghezza della stringa sia maggiore di 0 <code>letters.length() &gt; 0</code>. Se anche questa condizione risulta\u00a0true reimpostiamo il valore della variabile\u00a0letters eliminando l'ultimo carattere inserito: <code>letters = letters.substring(0, letters.length()-1);</code>.</p> <p>Non avendo mai visto prima questi metodi delle variabili String, spiego velocemente come funzionano:</p> <ul> <li>.length()\u00a0restituisce semplicemente il numero di caratteri della stringa.</li> <li>.substring() restituisce una nuova stringa che \u00e8 parte della stringa iniziale. Accetta due parametri la posizione di partenza e quella finale.</li> </ul> <p>Ritornando al primo if: se stiamo premendo un tasto e questo tasto non \u00e8 backspace allora aggiungiamo il tasto premuto (<code>key</code>) alla nostra stringa a patto che la lunghezza della stringa non sia maggiore alla lunghezza della finestra del nostro sketch: <code>textWidth(letters+key) &lt; width</code></p>"},{"location":"text/2017-01-19-esercizio-con-il-testo/#risultato","title":"Risultato","text":"<p>Quello che accade dentro setup() e draw() non dovrebbe essere troppo complesso da capire per cui, inserisco direttamente un'immagine che rappresenta un risultato ottenuto con questo sketch:</p> <p></p>"}]}